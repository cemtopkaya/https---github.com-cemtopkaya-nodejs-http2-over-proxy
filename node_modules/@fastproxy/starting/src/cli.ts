import util from 'util';
import path from 'path';
import fs from 'fs';
import cp from 'child_process';
import os from 'os';
import createDebug from 'debug';
import fse from 'fs-extra2';
import * as comUtil from './util';

const ISDEV = process.env.NODE_ENV === 'development';
const debug = createDebug('@w2.starting');
const BOOTSTRAP_PATH = require.resolve('./bootstrap');

// 默认设置为`~`，防止Linux在开机启动时Node无法获取homedir
const TIMEOUT = 1200;
let defaultDir: string | undefined;
let dataDir: string | undefined;

function getHomeDir() {
  return (
    (typeof os.homedir === 'function'
      ? os.homedir()
      : process.env[process.platform == 'win32' ? 'USERPROFILE' : 'HOME']) || '~'
  );
}

function getDataDir() {
  if (!dataDir) {
    const homedir = process.env.STARTING_DATA_DIR || getHomeDir();
    dataDir = path.join(homedir, '.startingAppData');
    fse.ensureDirSync(dataDir);
  }
  return dataDir;
}

export const getDefaultDir = function (): string {
  defaultDir = defaultDir || path.join(getHomeDir(), '.startingAppData');
  return defaultDir;
};

export function isRunning(pid: any, callback?: (err: boolean) => void): any {
  return new Promise(resolve => {
    if (!pid) {
      callback?.(false);
      return resolve(false);
    }
    cp.exec(
      util.format(
        process.platform === 'win32' ? 'tasklist /fi "PID eq %s" | findstr /i "node.exe"' : 'ps -f -p %s | grep "node"',
        pid
      ),
      (err: any, stdout: any, _stderr: any) => {
        const flag = !err && !!stdout.toString().trim();
        resolve(flag);
        callback?.(flag);
      }
    );
  });
}

export function run(main: any, options: any, callback: any): any {
  options.debugMode = true;
  callback = callback || noop;
  const child = execCmd(main, options, {
    stdio: [0, 1, 2]
  });
  const execCallback = function () {
    timer && callback(null, options);
    timer = undefined;
  };
  let timer: NodeJS.Timeout | undefined = setTimeout(execCallback, TIMEOUT);
  const handleExit = function (code: number | null, signal: NodeJS.Signals | null) {
    debug('run:: invoke handleExit, param=', {code, signal});
    clearTimeout(timer);
    timer = undefined;
  };
  child.on('exit', handleExit);
  child.on('close', handleExit);
}

export async function start(
  main: string,
  options: any,
  callback: (err: Error | null | boolean, options: Record<string, any>) => void,
  version: any,
  isRestart?: boolean
): Promise<void> {
  const config = readConfig(main);
  if (config && !isRestart && config.version != version) {
    return restart(main, options, callback, version);
  }
  callback = callback || noop;

  let isrunning = await isRunning(config.pid);
  debug(`Checking pid(${config.pid}) is running(${isrunning})`);
  if (isrunning) {
    return callback(true, config.options || {});
  }

  isrunning = await isRunning(config._pid);
  debug(`Checking _pid=${config._pid} is running(${isrunning})`);
  if (isrunning) {
    return callback(true, config.options || {});
  }

  const errorFile = path.join(getDataDir(), `error.${encodeURIComponent(main)}`);
  try {
    if (fs.existsSync(errorFile)) {
      fs.unlinkSync(errorFile);
    }
  } catch (e) {
    return callback(e, options);
  }

  const child = execCmd(main, options, {
    detached: true,
    stdio: ['ignore', 'ignore', fs.openSync(errorFile, 'a+')]
  });

  config._pid = child.pid;
  config.main = main;
  config.version = version;
  debug(`Exec child process with _pid=${child.pid}, version=${version}`);
  try {
    writeConfig(main, config);
  } catch (e) {
    return callback(e, options);
  }

  const startTime = Date.now();
  (function execCallback(): NodeJS.Timeout | void {
    let error;
    try {
      error = fs.readFileSync(errorFile, {encoding: 'utf8'});
    } catch (e) {}

    if (error) {
      callback(null, options);
      console.error(error);
      try {
        fs.unlinkSync(errorFile);
      } catch (e) {}
      return;
    }

    if (Date.now() - startTime < TIMEOUT) {
      return setTimeout(execCallback, 200);
    }

    delete config._pid;
    config.pid = child.pid;
    config.options = options;
    writeConfig(main, config);
    child.unref();
    callback(null, options);
  })();
}

export function restart(main: string, options: any, callback: any, version: any): void {
  debug(`restart stage, main:${main}`);
  stop(main, (_: any, _main: any, opts: any) => {
    setTimeout(() => {
      if (!options.clearPreOptions) {
        const {noGlobalPlugins} = opts;
        options = (util as any)._extend(opts, options);
        options.noGlobalPlugins = noGlobalPlugins || options.noGlobalPlugins;
      }
      start(main, options, callback, version, true);
    }, 300);
  });
}

export function stop(main: any, callback: any): void {
  const config = readConfig(main);
  const {pid} = config;
  const {_pid} = config;
  main = config.main;
  callback = callback || noop;
  isRunning(pid, (isrunning: any) => {
    try {
      pid && process.kill(pid);
      removeConfig(main);
    } catch (err) {
      isrunning = isrunning && err;
    }

    if (isrunning) {
      callback(isrunning, main, config.options || {});
    } else {
      isRunning(_pid, (isrunning: any) => {
        try {
          _pid && process.kill(_pid);

          removeConfig(main);
        } catch (err) {
          isrunning = isrunning && err;
        }
        callback(isrunning, main, config.options || {});
      });
    }
  });
}

function getHashIndex(main: any) {
  let lastIndex = main.length - 1;
  if (main[lastIndex] === '#') {
    lastIndex = main.lastIndexOf('#', lastIndex - 1);
  } else {
    lastIndex = -1;
  }
  return lastIndex;
}

function getRunningPath(main: string, dataDir?: string) {
  const index = getHashIndex(main);
  main = encodeURIComponent(index == -1 ? '#' : main.substring(index));
  return path.join(dataDir || getDataDir(), main);
}

function execCmd(main: string, data: any, options: any) {
  debug('Invoke execCmd(), main: %s, options: %o', main, options);
  const lastIndex = getHashIndex(main);
  if (lastIndex != -1) {
    main = main.substring(0, lastIndex);
  }
  const args = [BOOTSTRAP_PATH, 'run', main];
  if (data.inspectBrk) {
    args.unshift(`--inspect-brk${data.inspectBrk === true ? '' : `=${data.inspectBrk}`}`);
  } else if (data.inspect) {
    args.unshift(`--inspect${data.inspect === true ? '' : `=${data.inspect}`}`);
  }

  const execPath = process.env.STARTING_EXEC_PATH || (ISDEV ? 'tsx' : 'node');
  const version = comUtil.getVersion(execPath);
  if (version) {
    const flag = comUtil.getMaxSemiSpaceFlag(version);
    flag && args.unshift(`${flag}=64`);
    const versions = version
      .substring(1)
      .split('.')
      .map(item => parseInt(item, 10));
    const supportTlsMinV1 = versions[0] > 11;
    const supportMaxHeaderSize =
      (versions[0] == 10 && versions[1] >= 15) || (versions[0] == 11 && versions[1] > 5) || versions[0] > 11;
    const maxHeaderSize = data.__maxHttpHeaderSize;
    supportMaxHeaderSize && args.unshift(`--max-http-header-size=${maxHeaderSize > 0 ? maxHeaderSize : 256000}`);
    supportTlsMinV1 && args.unshift('--tls-min-v1.0');
  }
  if (data) {
    args.push('--data');
    args.push(encodeURIComponent(JSON.stringify(data)));
  }

  debug('execCmd:: final args: ', {execPath, args: args.join(' '), options});
  return cp.spawn(execPath, args, options);
}

export function readConfig(main: string, dataDir?: string): Record<string, any> {
  try {
    const runningFile = getRunningPath(main, dataDir);
    const config = fse.readJsonSync(getRunningPath(main, dataDir));
    debug('Read config file1: %s, config: %o', runningFile, config);
    return config;
  } catch (e) {}

  const running = path.join(dataDir || getDataDir(), encodeURIComponent(main));
  try {
    const config = fse.readJsonSync(running);
    debug('Read config file2: %s, config: %o ', running, config);
    return config;
  } catch (e) {}

  return {};
}

function writeConfig(main: any, config: any) {
  const configFile = getRunningPath(main);
  debug(`Write config to file(${configFile}) with config: (%o)`, config);
  fse.outputJsonSync(getRunningPath(main), config || {});
}

export function removeConfig(main: any, dataDir?: string): void {
  let running = getRunningPath(main, dataDir);
  fs.existsSync(running) && fse.removeSync(running);
  running = path.join(dataDir || getDataDir(), encodeURIComponent(main));
  fs.existsSync(running) && fse.removeSync(running);
}

function noop() {
  /** noop */
}
