"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeConfig = exports.readConfig = exports.stop = exports.restart = exports.start = exports.run = exports.isRunning = exports.getDefaultDir = void 0;
const tslib_1 = require("tslib");
const util_1 = tslib_1.__importDefault(require("util"));
const path_1 = tslib_1.__importDefault(require("path"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const child_process_1 = tslib_1.__importDefault(require("child_process"));
const os_1 = tslib_1.__importDefault(require("os"));
const debug_1 = tslib_1.__importDefault(require("debug"));
const fs_extra2_1 = tslib_1.__importDefault(require("fs-extra2"));
const comUtil = tslib_1.__importStar(require("./util"));
const ISDEV = process.env.NODE_ENV === 'development';
const debug = (0, debug_1.default)('@w2.starting');
const BOOTSTRAP_PATH = require.resolve('./bootstrap');
// 默认设置为`~`，防止Linux在开机启动时Node无法获取homedir
const TIMEOUT = 1200;
let defaultDir;
let dataDir;
function getHomeDir() {
    return ((typeof os_1.default.homedir === 'function'
        ? os_1.default.homedir()
        : process.env[process.platform == 'win32' ? 'USERPROFILE' : 'HOME']) || '~');
}
function getDataDir() {
    if (!dataDir) {
        const homedir = process.env.STARTING_DATA_DIR || getHomeDir();
        dataDir = path_1.default.join(homedir, '.startingAppData');
        fs_extra2_1.default.ensureDirSync(dataDir);
    }
    return dataDir;
}
const getDefaultDir = function () {
    defaultDir = defaultDir || path_1.default.join(getHomeDir(), '.startingAppData');
    return defaultDir;
};
exports.getDefaultDir = getDefaultDir;
function isRunning(pid, callback) {
    return new Promise(resolve => {
        if (!pid) {
            callback?.(false);
            return resolve(false);
        }
        child_process_1.default.exec(util_1.default.format(process.platform === 'win32' ? 'tasklist /fi "PID eq %s" | findstr /i "node.exe"' : 'ps -f -p %s | grep "node"', pid), (err, stdout, _stderr) => {
            const flag = !err && !!stdout.toString().trim();
            resolve(flag);
            callback?.(flag);
        });
    });
}
exports.isRunning = isRunning;
function run(main, options, callback) {
    options.debugMode = true;
    callback = callback || noop;
    const child = execCmd(main, options, {
        stdio: [0, 1, 2]
    });
    const execCallback = function () {
        timer && callback(null, options);
        timer = undefined;
    };
    let timer = setTimeout(execCallback, TIMEOUT);
    const handleExit = function (code, signal) {
        debug('run:: invoke handleExit, param=', { code, signal });
        clearTimeout(timer);
        timer = undefined;
    };
    child.on('exit', handleExit);
    child.on('close', handleExit);
}
exports.run = run;
async function start(main, options, callback, version, isRestart) {
    const config = readConfig(main);
    if (config && !isRestart && config.version != version) {
        return restart(main, options, callback, version);
    }
    callback = callback || noop;
    let isrunning = await isRunning(config.pid);
    debug(`Checking pid(${config.pid}) is running(${isrunning})`);
    if (isrunning) {
        return callback(true, config.options || {});
    }
    isrunning = await isRunning(config._pid);
    debug(`Checking _pid=${config._pid} is running(${isrunning})`);
    if (isrunning) {
        return callback(true, config.options || {});
    }
    const errorFile = path_1.default.join(getDataDir(), `error.${encodeURIComponent(main)}`);
    try {
        if (fs_1.default.existsSync(errorFile)) {
            fs_1.default.unlinkSync(errorFile);
        }
    }
    catch (e) {
        return callback(e, options);
    }
    const child = execCmd(main, options, {
        detached: true,
        stdio: ['ignore', 'ignore', fs_1.default.openSync(errorFile, 'a+')]
    });
    config._pid = child.pid;
    config.main = main;
    config.version = version;
    debug(`Exec child process with _pid=${child.pid}, version=${version}`);
    try {
        writeConfig(main, config);
    }
    catch (e) {
        return callback(e, options);
    }
    const startTime = Date.now();
    (function execCallback() {
        let error;
        try {
            error = fs_1.default.readFileSync(errorFile, { encoding: 'utf8' });
        }
        catch (e) { }
        if (error) {
            callback(null, options);
            console.error(error);
            try {
                fs_1.default.unlinkSync(errorFile);
            }
            catch (e) { }
            return;
        }
        if (Date.now() - startTime < TIMEOUT) {
            return setTimeout(execCallback, 200);
        }
        delete config._pid;
        config.pid = child.pid;
        config.options = options;
        writeConfig(main, config);
        child.unref();
        callback(null, options);
    })();
}
exports.start = start;
function restart(main, options, callback, version) {
    debug(`restart stage, main:${main}`);
    stop(main, (_, _main, opts) => {
        setTimeout(() => {
            if (!options.clearPreOptions) {
                const { noGlobalPlugins } = opts;
                options = util_1.default._extend(opts, options);
                options.noGlobalPlugins = noGlobalPlugins || options.noGlobalPlugins;
            }
            start(main, options, callback, version, true);
        }, 300);
    });
}
exports.restart = restart;
function stop(main, callback) {
    const config = readConfig(main);
    const { pid } = config;
    const { _pid } = config;
    main = config.main;
    callback = callback || noop;
    isRunning(pid, (isrunning) => {
        try {
            pid && process.kill(pid);
            removeConfig(main);
        }
        catch (err) {
            isrunning = isrunning && err;
        }
        if (isrunning) {
            callback(isrunning, main, config.options || {});
        }
        else {
            isRunning(_pid, (isrunning) => {
                try {
                    _pid && process.kill(_pid);
                    removeConfig(main);
                }
                catch (err) {
                    isrunning = isrunning && err;
                }
                callback(isrunning, main, config.options || {});
            });
        }
    });
}
exports.stop = stop;
function getHashIndex(main) {
    let lastIndex = main.length - 1;
    if (main[lastIndex] === '#') {
        lastIndex = main.lastIndexOf('#', lastIndex - 1);
    }
    else {
        lastIndex = -1;
    }
    return lastIndex;
}
function getRunningPath(main, dataDir) {
    const index = getHashIndex(main);
    main = encodeURIComponent(index == -1 ? '#' : main.substring(index));
    return path_1.default.join(dataDir || getDataDir(), main);
}
function execCmd(main, data, options) {
    debug('Invoke execCmd(), main: %s, options: %o', main, options);
    const lastIndex = getHashIndex(main);
    if (lastIndex != -1) {
        main = main.substring(0, lastIndex);
    }
    const args = [BOOTSTRAP_PATH, 'run', main];
    if (data.inspectBrk) {
        args.unshift(`--inspect-brk${data.inspectBrk === true ? '' : `=${data.inspectBrk}`}`);
    }
    else if (data.inspect) {
        args.unshift(`--inspect${data.inspect === true ? '' : `=${data.inspect}`}`);
    }
    const execPath = process.env.STARTING_EXEC_PATH || (ISDEV ? 'tsx' : 'node');
    const version = comUtil.getVersion(execPath);
    if (version) {
        const flag = comUtil.getMaxSemiSpaceFlag(version);
        flag && args.unshift(`${flag}=64`);
        const versions = version
            .substring(1)
            .split('.')
            .map(item => parseInt(item, 10));
        const supportTlsMinV1 = versions[0] > 11;
        const supportMaxHeaderSize = (versions[0] == 10 && versions[1] >= 15) || (versions[0] == 11 && versions[1] > 5) || versions[0] > 11;
        const maxHeaderSize = data.__maxHttpHeaderSize;
        supportMaxHeaderSize && args.unshift(`--max-http-header-size=${maxHeaderSize > 0 ? maxHeaderSize : 256000}`);
        supportTlsMinV1 && args.unshift('--tls-min-v1.0');
    }
    if (data) {
        args.push('--data');
        args.push(encodeURIComponent(JSON.stringify(data)));
    }
    debug('execCmd:: final args: ', { execPath, args: args.join(' '), options });
    return child_process_1.default.spawn(execPath, args, options);
}
function readConfig(main, dataDir) {
    try {
        const runningFile = getRunningPath(main, dataDir);
        const config = fs_extra2_1.default.readJsonSync(getRunningPath(main, dataDir));
        debug('Read config file1: %s, config: %o', runningFile, config);
        return config;
    }
    catch (e) { }
    const running = path_1.default.join(dataDir || getDataDir(), encodeURIComponent(main));
    try {
        const config = fs_extra2_1.default.readJsonSync(running);
        debug('Read config file2: %s, config: %o ', running, config);
        return config;
    }
    catch (e) { }
    return {};
}
exports.readConfig = readConfig;
function writeConfig(main, config) {
    const configFile = getRunningPath(main);
    debug(`Write config to file(${configFile}) with config: (%o)`, config);
    fs_extra2_1.default.outputJsonSync(getRunningPath(main), config || {});
}
function removeConfig(main, dataDir) {
    let running = getRunningPath(main, dataDir);
    fs_1.default.existsSync(running) && fs_extra2_1.default.removeSync(running);
    running = path_1.default.join(dataDir || getDataDir(), encodeURIComponent(main));
    fs_1.default.existsSync(running) && fs_extra2_1.default.removeSync(running);
}
exports.removeConfig = removeConfig;
function noop() {
    /** noop */
}
