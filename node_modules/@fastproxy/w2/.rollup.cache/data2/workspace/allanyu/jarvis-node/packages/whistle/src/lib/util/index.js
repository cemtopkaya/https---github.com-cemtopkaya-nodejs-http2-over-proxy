import http from 'http';
import path from 'path';
import os from 'os';
import fs from 'fs';
import vm from 'vm';
import net from 'net';
import tls from 'tls';
import crypto from 'crypto';
import qs from 'querystring';
import { PassThrough } from 'stream';
import zlib from 'zlib';
import dns from 'dns';
import { constants } from 'http2';
import fse from 'fs-extra2';
import extend from 'extend';
import LRU from 'lru-cache';
import json5 from 'json5';
import iconv from 'iconv-lite';
import PipeStream from 'pipestream';
import Q from 'q';
import { Buffer } from 'safe-buffer';
import { aliasProtocols, isBinProtocol, protocols, resProtocols } from '../rules/protocols';
import config from '../config';
import logger from './logger';
import isUtf8 from './is-utf8';
import * as fileMgr from './file-mgr';
import * as httpMgr from './http-mgr';
import ReplacePatternTransform from './replace-pattern-transform';
import parseQuery from './parse-query';
import * as common from './common';
import proc from './process';
import parseUrl from './parse-url';
export { default as SpeedTransform } from './speed-transform';
export { default as FileWriterTransform } from './file-writer-transform';
export { getServer } from 'hagent';
export { listenerCount } from './patch';
export const request = httpMgr.request;
export { indexOf as indexOfList } from './buf-util';
export { hasProtocol, removeProtocol, setProtocol, getProtocol, replaceProtocol, lowerCaseify, removeIPV6Prefix, hasBody, isHead, isEmptyObject, addTrailerNames, removeIllegalTrailers, getUpdateUrl, onResEnd, encodeHtml } from './common';
export const toBuffer = fileMgr.toBuffer;
const pendingFiles = {};
const localIpCache = new LRU({ max: 120 });
const CRLF_RE = /\r\n|\r|\n/g;
const SEARCH_RE = /[?#].*$/;
const UTF8_OPTIONS = { encoding: 'utf8' };
const LOCALHOST = '127.0.0.1';
let CONTEXT = vm.createContext();
const END_WIDTH_SEP_RE = /[/\\]$/;
const GEN_URL_RE = /^\s*(?:https?:)?\/\/\w[^\s]*\s*$/i;
const G_NON_LATIN1_RE = /\s|[^\x00-\xFF]/gu;
const NON_LATIN1_RE = /[^\x00-\xFF]/;
const SCRIPT_START = toBuffer('<script>');
const SCRIPT_END = toBuffer('</script>');
const STYLE_START = toBuffer('<style>');
const STYLE_END = toBuffer('</style>');
const RAW_CRLF_RE = /\\n|\\r/g;
const NUM_RE = /^\d+$/;
const DIG_RE = /^[+-]?[1-9]\d*$/;
const INDEX_RE = /^\[(\d+)\]$/;
const ARR_FILED_RE = /(.)?(?:\[(\d+)\])$/;
const PROXY_RE = /^x?(?:socks|https?-proxy|proxy|internal(?:-https)?-proxy)$/;
const DEFAULT_REGISTRY = 'https://registry.npmjs.org';
const HTTP_RE = /^https?:\/\/[^/?]/;
const SEP_RE = /[|&]/;
let ctxTimer;
const END_RE = /[/\\]$/;
const resetContext = function () {
    ctxTimer = undefined;
    CONTEXT = vm.createContext();
};
const SUB_MATCH_RE = /\$[&\d]/;
const HTTP_URL_RE = /^https?:\/\//;
const PROTO_NAME_RE = /^([\w.-]+):\/\//;
const replacePattern = ReplacePatternTransform.replacePattern;
const CIPHER_OPTIONS = [
    'NULL-SHA256',
    'AES128-SHA256',
    'AES256-SHA256',
    'AES128-GCM-SHA256',
    'AES256-GCM-SHA384',
    'DH-RSA-AES128-SHA256',
    'DH-RSA-AES256-SHA256',
    'DH-RSA-AES128-GCM-SHA256',
    'DH-RSA-AES256-GCM-SHA384',
    'DH-DSS-AES128-SHA256',
    'DH-DSS-AES256-SHA256',
    'DH-DSS-AES128-GCM-SHA256',
    'DH-DSS-AES256-GCM-SHA384',
    'DHE-RSA-AES128-SHA256',
    'DHE-RSA-AES256-SHA256',
    'DHE-RSA-AES128-GCM-SHA256',
    'DHE-RSA-AES256-GCM-SHA384',
    'DHE-DSS-AES128-SHA256',
    'DHE-DSS-AES256-SHA256',
    'DHE-DSS-AES128-GCM-SHA256',
    'DHE-DSS-AES256-GCM-SHA384',
    'ECDHE-RSA-AES128-SHA256',
    'ECDHE-RSA-AES256-SHA384',
    'ECDHE-RSA-AES128-GCM-SHA256',
    'ECDHE-RSA-AES256-GCM-SHA384',
    'ECDHE-ECDSA-AES128-SHA256',
    'ECDHE-ECDSA-AES256-SHA384',
    'ECDHE-ECDSA-AES128-GCM-SHA256',
    'ECDHE-ECDSA-AES256-GCM-SHA384',
    'ADH-AES128-SHA256',
    'ADH-AES256-SHA256',
    'ADH-AES128-GCM-SHA256',
    'ADH-AES256-GCM-SHA384',
    'AES128-CCM',
    'AES256-CCM',
    'DHE-RSA-AES128-CCM',
    'DHE-RSA-AES256-CCM',
    'AES128-CCM8',
    'AES256-CCM8',
    'DHE-RSA-AES128-CCM8',
    'DHE-RSA-AES256-CCM8',
    'ECDHE-ECDSA-AES128-CCM',
    'ECDHE-ECDSA-AES256-CCM',
    'ECDHE-ECDSA-AES128-CCM8',
    'ECDHE-ECDSA-AES256-CCM8'
];
const TLSV2_CIPHERS = 'ECDHE-ECDSA-AES256-GCM-SHA384';
export const EMPTY_BUFFER = toBuffer('');
const lowerCaseify = common.lowerCaseify;
const removeIPV6Prefix = common.removeIPV6Prefix;
const hasBody = common.hasBody;
const hasProtocol = common.hasProtocol;
const removeProtocol = common.removeProtocol;
const INTERNAL_ID = process.pid + '-' + Math.random();
let pluginMgr;
const _workerIndex = process.env && process.env.workerIndex;
export const workerIndex = _workerIndex && parseInt(_workerIndex, 10) >= 0 ? padReqId(config.workerIndex) : '';
export { default as ReplacePatternTransform } from './replace-pattern-transform';
export { default as ReplaceStringTransform } from './replace-string-transform';
export { default as WhistleTransform } from './whistle-transform';
export { proc, INTERNAL_ID, isUtf8, parseQuery, parseUrl, localIpCache, replacePattern };
// 避免属性被 stringify ，减少冗余数据传给前端
export const PLUGIN_VALUES = Symbol('_values');
export const PLUGIN_MENU_CONFIG = Symbol('_menuConfig');
export const PLUGIN_INSPECTOR_CONFIG = Symbol('_inspectorConfig');
export * from './drain';
export const isWin = process.platform === 'win32';
export function noop(_) {
    return _;
}
export function isUrl(str) {
    return HTTP_URL_RE.test(str);
}
export function isCiphersError(e) {
    return (e.code === 'EPROTO' || String(e.message).indexOf('disconnected before secure TLS connection was established') !== -1);
}
function wrapJs(js, charset, isUrl) {
    if (!js) {
        return '';
    }
    if (isUrl) {
        return toBuffer('<script src="' + js + '"></script>', charset);
    }
    return Buffer.concat([SCRIPT_START, toBuffer(js, charset), SCRIPT_END]);
}
function wrapCss(css, charset, isUrl) {
    if (!css) {
        return '';
    }
    if (isUrl) {
        return toBuffer('<link rel="stylesheet" href="' + css + '" />', charset);
    }
    return Buffer.concat([STYLE_START, toBuffer(css, charset), STYLE_END]);
}
function evalJson(str) {
    try {
        return json5.parse(str);
    }
    catch (e) { }
}
export const parseRawJson = function (str) {
    try {
        return JSON.parse(str);
    }
    catch (e) {
        return evalJson(str);
    }
};
export function getRegistry(pkg) {
    const registry = pkg.whistleConfig && pkg.whistleConfig.registry;
    if (!registry || !HTTP_RE.test(registry)) {
        return;
    }
    return registry === DEFAULT_REGISTRY ? undefined : registry;
}
const MAX_LEN = 1024 * 1024 * 5;
export function getLatestVersion(registry, cb) {
    if (registry && typeof registry !== 'string') {
        const name = registry.moduleName;
        registry = registry.registry;
        if (registry) {
            registry += '/' + name;
        }
    }
    if (!registry) {
        return cb();
    }
    httpMgr.request({
        url: registry,
        maxLength: MAX_LEN
    }, function (err, body, res) {
        if (err || res.statusCode !== 200) {
            body = null;
        }
        else if (body) {
            body = parseJSON(body);
        }
        body = body && body['dist-tags'];
        cb(body && body['latest']);
    });
}
const ESTABLISHED_CTN = 'HTTP/1.1 200 Connection Established\r\nProxy-Agent: ' + config.name + '\r\n\r\n';
export const setEstablished = function (socket) {
    socket.write(ESTABLISHED_CTN);
};
export function changePort(url, port) {
    const index = url.indexOf('/', url.indexOf('://') + 3);
    if (index != -1) {
        const host = url.substring(0, index).replace(/:\d*$/, '');
        url = host + ':' + port + url.substring(index);
    }
    return url;
}
export function handleStatusCode(statusCode, headers) {
    if (statusCode == 401) {
        headers['www-authenticate'] = 'Basic realm=User Login';
    }
    return headers;
}
export function getStatusCode(statusCode) {
    statusCode |= 0;
    return statusCode < 100 || statusCode > 999 ? 0 : statusCode;
}
export function compare(v1, v2) {
    return v1 == v2 ? 0 : v1 > v2 ? -1 : 1;
}
let scriptCache = {};
const VM_OPTIONS = {
    displayErrors: false,
    timeout: 60
};
const MAX_SCRIPT_SIZE = 1024 * 256;
const MAX_SCRIPT_CACHE_COUNT = 64;
const MIN_SCRIPT_CACHE_COUNT = 32;
function getScript(content) {
    content = content.trim();
    const len = content.length;
    if (!len || len > MAX_SCRIPT_SIZE) {
        return;
    }
    let script = scriptCache[content];
    delete scriptCache[content];
    let list = Object.keys(scriptCache);
    if (list.length > MAX_SCRIPT_CACHE_COUNT) {
        list = list
            .map(function (content) {
            const script = scriptCache[content];
            script.content = content;
            return script;
        })
            .sort(function (a, b) {
            return compare(a.time, b.time);
        })
            .splice(0, MIN_SCRIPT_CACHE_COUNT);
        scriptCache = {};
        list.forEach(function (script) {
            scriptCache[script.content] = {
                script: script.script,
                time: script.time
            };
        });
    }
    script = scriptCache[content] = script || {
        script: new vm.Script('(function(){\n' + content + '\n})()')
    };
    script.time = Date.now();
    return script.script;
}
function clearContext() {
    Object.keys(CONTEXT).forEach(function (key) {
        delete CONTEXT[key];
    });
    if (!ctxTimer) {
        ctxTimer = setTimeout(resetContext, 30000);
    }
}
export function execScriptSync(script, context) {
    try {
        if ((script = getScript(script))) {
            CONTEXT.console = {};
            ['fatal', 'error', 'warn', 'info', 'log', 'debug'].forEach(level => {
                CONTEXT.console[level] = logger[level];
            });
            Object.keys(context).forEach(function (key) {
                CONTEXT[key] = context[key];
            });
            script.runInContext(CONTEXT, VM_OPTIONS);
        }
        return true;
    }
    catch (e) {
        logger.error(e);
        return false;
    }
    finally {
        clearContext();
    }
}
function stat(file, callback, force) {
    if (force) {
        return callback(true);
    }
    fs.stat(file, function (err) {
        if (!err || err.code === 'ENOTDIR') {
            return callback();
        }
        if (err.code === 'ENOENT') {
            return callback(true);
        }
        fs.stat(file, callback);
    });
}
function getFileWriter(file, callback, force) {
    if (!file) {
        return callback();
    }
    if (END_RE.test(file)) {
        file = path.join(file, 'index.html');
    }
    if (!force && pendingFiles[file]) {
        return callback();
    }
    const execCb = function (writer) {
        delete pendingFiles[file];
        callback(writer);
    };
    pendingFiles[file] = 1;
    stat(file, function (notExists) {
        if (!notExists) {
            return execCb();
        }
        fse.ensureFile(file, function (err) {
            if (err) {
                logger.error(err);
                return execCb();
            }
            execCb(fs.createWriteStream(file).on('error', logger.error));
        });
    }, force);
}
export function getFileWriters(files, callback, force) {
    if (!Array.isArray(files)) {
        files = [files];
    }
    Q.all(files.map(function (file) {
        const defer = Q.defer();
        getFileWriter(file, function (writer) {
            defer.resolve(writer);
        }, force);
        return defer.promise;
    })).spread(callback);
}
export function getErrorStack(err) {
    if (!err) {
        return '';
    }
    let stack;
    try {
        stack = err.stack;
    }
    catch (e) { }
    stack = stack || err.message || err;
    const result = [
        'From: ' + config.name + '@' + config.version,
        'Node: ' + process.version,
        'Date: ' + formatDate(),
        stack
    ];
    return result.join('\r\n');
}
export function formatDate(now) {
    now = now || new Date();
    return now.toLocaleString();
}
const REG_EXP_RE = /^\/(.+)\/(i?u?|ui)$/;
export const isRegExp = function isRegExp(regExp) {
    return REG_EXP_RE.test(regExp);
};
const ORIG_REG_EXP = /^\/(.+)\/([igmu]{0,4})$/;
export function isOriginalRegExp(regExp) {
    if (!ORIG_REG_EXP.test(regExp) || /[igmu]{2}/.test(regExp.$2)) {
        return false;
    }
    return true;
}
export function toOriginalRegExp(regExp) {
    regExp = ORIG_REG_EXP.test(regExp);
    try {
        regExp = regExp && new RegExp(RegExp.$1, RegExp.$2);
    }
    catch (e) {
        regExp = null;
    }
    return regExp;
}
export const emitError = function (obj, err) {
    if (obj) {
        obj.once('error', noop);
        obj.emit('error', err || new Error('Unknown'));
    }
};
export const startWithList = function (buf, subBuf, start = 0) {
    const len = subBuf.length;
    if (!len) {
        return false;
    }
    for (let i = 0; i < len; i++) {
        if (buf[i + start] != subBuf[i]) {
            return false;
        }
    }
    return true;
};
export const endWithList = function (buf, subBuf, end) {
    const subLen = subBuf.length;
    if (!subLen) {
        return false;
    }
    if (!(end >= 0)) {
        end = buf.length - 1;
    }
    for (let i = 0; i < subLen; i++) {
        if (subBuf[subLen - i - 1] != buf[end - i]) {
            return false;
        }
    }
    return true;
};
export function isEnable(req, name) {
    return req.enable[name] && !req.disable[name];
}
export const getInternalHost = function (req, host) {
    if (isEnable(req, 'useLocalHost')) {
        return 'local.wproxy.org';
    }
    if (host && isEnable(req, 'useSafePort')) {
        const index = host.indexOf(':');
        if (index !== -1) {
            host = host.substring(0, index);
        }
        host += ':8899';
    }
    return host;
};
export function isAuthCapture(req) {
    const e = req.enable || '';
    const d = req.disable || '';
    return (e.authCapture || e.authIntercept) && !d.authCapture && !d.authIntercept;
}
export const toRegExp = function toRegExp(regExp, ignoreCase) {
    regExp = REG_EXP_RE.test(regExp);
    try {
        regExp = regExp && new RegExp(RegExp.$1, ignoreCase ? 'i' : RegExp.$2);
    }
    catch (e) {
        regExp = null;
    }
    return regExp;
};
const HTTP_PORT_RE = /:80$/;
const HTTPS_PORT_RE = /:443$/;
function removeDefaultPort(host, isHttps) {
    return host && host.replace(isHttps ? HTTPS_PORT_RE : HTTP_PORT_RE, '');
}
export function isString(str) {
    return str && typeof str === 'string';
}
export function getFullUrl(req) {
    const headers = req.headers;
    let host = headers[config.REAL_HOST_HEADER];
    if (hasProtocol(req.url)) {
        const options = parseUrl(req.url);
        if (options.protocol === 'https:' || (req.isWs && options.protocol === 'wss:')) {
            req.isHttps = true;
        }
        req.url = options.path;
        if (options.host) {
            headers.host = options.host;
        }
    }
    else {
        req.url = req.url || '/';
        if (req.url[0] !== '/') {
            req.url = '/' + req.url;
        }
    }
    if (host) {
        delete headers[config.REAL_HOST_HEADER];
    }
    if (!isString(host)) {
        host = headers.host;
        if (typeof host !== 'string') {
            host = headers.host = '';
        }
    }
    else if (headers.host !== host) {
        if (isString(headers.host)) {
            req._fwdHost = headers.host;
        }
        headers.host = host;
    }
    host = removeDefaultPort(host, req.isHttps);
    const fullUrl = host + req.url;
    if (req.isWs) {
        return (req.isHttps ? 'wss://' : 'ws://') + fullUrl;
    }
    return (req.isHttps ? 'https://' : 'http://') + fullUrl;
}
export function disableCSP(headers) {
    delete headers['content-security-policy'];
    delete headers['content-security-policy-report-only'];
    delete headers['x-content-security-policy'];
    delete headers['x-content-security-policy-report-only'];
    delete headers['x-webkit-csp'];
}
let interfaces = os.networkInterfaces();
let hostname = os.hostname();
let simpleHostname = '';
const cpus = os.cpus();
let addressList = [];
(function updateSystyemInfo() {
    interfaces = os.networkInterfaces();
    hostname = os.hostname();
    addressList = [];
    for (const i in interfaces) {
        const list = interfaces[i];
        if (Array.isArray(list)) {
            list.forEach(function (info) {
                addressList.push(info.address.toLowerCase());
            });
        }
    }
    setTimeout(updateSystyemInfo, 30000);
})();
if (isString(hostname)) {
    simpleHostname = hostname.replace(/[^\w.-]+/g, '').substring(0, 20);
    simpleHostname = simpleHostname ? simpleHostname + '.' : '';
}
let clientId = [
    hostname,
    os.platform(),
    os.release(),
    os.arch(),
    cpus.length,
    cpus[0] && cpus[0].model,
    config.clientId
];
clientId = config.clientId =
    simpleHostname + crypto.createHmac('sha256', config.CLIENT_ID_HEADER).update(clientId.join('\r\n')).digest('base64');
config.runtimeId =
    simpleHostname +
        crypto
            .createHmac('sha256', config.CLIENT_ID_HEADER)
            .update(clientId + '\r\n' + Math.random() + '\r\n' + Date.now())
            .digest('base64') +
        '/' +
        config.port;
config.runtimeHeaders = { 'x-whistle-runtime-id': config.runtimeId };
config.pluginHeaders = {
    'x-whistle-runtime-id': config.runtimeId,
    'x-whistle-internal-id': INTERNAL_ID,
    [config.PLUGIN_HOOK_NAME_HEADER]: config.PLUGIN_HOOKS.UI
};
export const setClientId = function (headers, enable, disable, clientIp, isInternalProxy) {
    if (disable && (disable.clientId || disable.clientID || disable.clientid)) {
        return;
    }
    enable = enable || '';
    if (enable.clientId || enable.clientID || enable.clientid || isInternalProxy) {
        let id = getClientId(headers);
        if ((enable.multiClient || isInternalProxy) && !enable.singleClient && !disable.multiClient) {
            if (headers[config.CLIENT_ID_HEADER]) {
                return;
            }
            if (!isLocalAddress(clientIp)) {
                id += '/' + clientIp;
            }
        }
        headers[config.CLIENT_ID_HEADER] = id;
    }
};
export function getClientId(headers) {
    const id = headers[config.CLIENT_ID_HEADER];
    const idKey = config.cidKey;
    if (!idKey || (id && !config.overCidKey)) {
        return id || clientId;
    }
    return headers[idKey] || id || clientId;
}
export const getTunnelKey = function (conf) {
    let tunnelKey = conf.tunnelKey || conf.tunnelKeys;
    if (tunnelKey && typeof tunnelKey === 'string') {
        tunnelKey = tunnelKey.toLowerCase().split(/[:,|]/);
        tunnelKey = tunnelKey.map(trim).filter(noop);
        return tunnelKey.slice(0, 10);
    }
};
export function getComposerClientId(headers) {
    const clientId = headers[config.COMPOSER_CLIENT_ID_HEADER];
    if (clientId) {
        delete headers[config.COMPOSER_CLIENT_ID_HEADER];
        return clientId;
    }
}
export const removeClientId = function (headers) {
    delete headers[config.CLIENT_ID_HEADER];
};
export function networkInterfaces() {
    return interfaces;
}
/**
 * FIXME: 之前是提供hostname别名的, 但会和块作用域里的变量冲突
 * export const hostname = getHostname;
 */
export function getHostname() {
    return hostname;
}
export function getProxyTunnelPath(req, isHttps) {
    const host = req._phost && req._proxyTunnel && req.headers.host;
    if (isString(host)) {
        return host.indexOf(':') !== -1 ? host : host + ':' + (isHttps ? 443 : 80);
    }
}
export function isLocalAddress(address) {
    if (isLocalIp(address)) {
        return true;
    }
    address = address.toLowerCase();
    if (address[0] === '[') {
        address = address.slice(1, -1);
    }
    if (address == '0:0:0:0:0:0:0:1') {
        return true;
    }
    return !!(localIpCache.get(address) || addressList.indexOf(address) !== -1);
}
export function isLocalHost(host) {
    return host === 'localhost' || isLocalAddress(host);
}
export function parseHost(host) {
    if (host[0] === '[') {
        const index = host.indexOf(']');
        host = [host.substring(1, index), host.substring(index + 2)];
    }
    else {
        host = host.split(':');
    }
    return host;
}
/**
 * 解析一些字符时，encodeURIComponent可能会抛异常，对这种字符不做任何处理
 * see: http://stackoverflow.com/questions/16868415/encodeuricomponent-throws-an-exception
 * @param ch
 * @returns
 */
function safeEncodeURIComponent(ch) {
    try {
        return encodeURIComponent(ch);
    }
    catch (e) { }
    return ch;
}
export const encodeNonLatin1Char = function (str) {
    if (!isString(str)) {
        return '';
    }
    return str.replace(G_NON_LATIN1_RE, safeEncodeURIComponent);
};
export const encodeURIComponent = safeEncodeURIComponent;
export function getPath(url, noProtocol) {
    if (url) {
        url = url.replace(SEARCH_RE, '');
        const index = noProtocol ? -1 : url.indexOf('://');
        url = index > -1 ? url.substring(index + 3) : url;
    }
    return url;
}
export function getFilename(url) {
    if (typeof url === 'string' && (url = getPath(url)?.trim())) {
        const index = url.lastIndexOf('/');
        if (index != -1) {
            url = url.substring(index + 1);
        }
        else {
            url = null;
        }
    }
    else {
        url = null;
    }
    return url || 'index.html';
}
export function disableReqCache(headers) {
    delete headers['if-modified-since'];
    delete headers['if-none-match'];
    delete headers['last-modified'];
    delete headers.etag;
    headers['pragma'] = 'no-cache';
    headers['cache-control'] = 'no-cache';
}
export function disableResStore(headers) {
    headers['cache-control'] = 'no-store';
    headers['expires'] = new Date(Date.now() - 60000000).toUTCString();
    headers['pragma'] = 'no-cache';
    delete headers.tag;
}
export function parsePathReplace(urlPath, params) {
    if (!params || !/^(?:ws|http)s?:/.test(urlPath)) {
        return;
    }
    let index = urlPath.indexOf('://');
    if (index == -1) {
        return;
    }
    index = urlPath.indexOf('/', index + 3) + 1;
    if (index <= 0) {
        return;
    }
    let root = urlPath.substring(0, index);
    urlPath = urlPath.substring(index);
    Object.keys(params).forEach(function (pattern) {
        let value = params[pattern];
        value = value == null ? '' : value + '';
        if (isOriginalRegExp(pattern) && (pattern = toOriginalRegExp(pattern))) {
            urlPath = urlPath.replace(pattern, value);
        }
        else if (pattern) {
            urlPath = urlPath.split(pattern).join(value);
        }
    });
    root += urlPath;
    return root !== urlPath ? root : null;
}
export function wrapResponse(res) {
    const passThrough = new PassThrough();
    passThrough.statusCode = res.statusCode;
    passThrough.rawHeaderNames = res.rawHeaderNames;
    passThrough.headers = lowerCaseify(res.headers);
    passThrough.headers['x-server'] = config.name;
    res.body != null && passThrough.push(Buffer.isBuffer(res.body) ? res.body : String(res.body));
    passThrough.push(null);
    passThrough.isCustomRes = true;
    return passThrough;
}
export function wrapGatewayError(body) {
    return wrapResponse({
        statusCode: 502,
        headers: {
            'content-type': 'text/html; charset=utf8'
        },
        body: body
            ? '<pre>\n' + body + '\n\n\n<a href="javascript:;" onclick="location.reload()"' + '>Reload this page</a>\n</pre>'
            : ''
    });
}
export function sendStatusCodeError(cltRes, svrRes) {
    delete svrRes.headers['content-length'];
    cltRes.writeHead(502, svrRes.headers);
    cltRes.src(wrapGatewayError('Invalid status code: ' + svrRes.statusCode));
}
export const getQueryValue = function (value) {
    if (value && typeof value === 'object') {
        try {
            return JSON.stringify(value);
        }
        catch (e) { }
    }
    return value || '';
};
const KV_RE = /^([^:=&]+):([^=&]*)$/;
function parseInlineJSON(text, isValue) {
    if (/\s/.test(text) || (!isValue && /\\|\//.test(text) && text[0] !== '&')) {
        return;
    }
    if (KV_RE.test(text)) {
        const data = {};
        data[RegExp.$1] = RegExp.$2;
        return data;
    }
    return parseQuery(text, null, null, true);
}
function replaceCrLf(char) {
    return char === '\\r' ? '\r' : '\n';
}
function parseLinesJSON(text) {
    if (!isString(text) || !(text = text.trim())) {
        return null;
    }
    let first = text[0];
    let last = text[text.length - 1];
    if ((first === '[' && last === ']') || (first === '{' && last === '}')) {
        return null;
    }
    let result;
    text.split(/\r\n|\n|\r/g).forEach(function (line) {
        if (!(line = line.trim())) {
            return;
        }
        let index = line.indexOf(': ');
        if (index === -1) {
            index = line.indexOf(':');
            if (index === -1) {
                index = line.indexOf('=');
            }
        }
        let name;
        let value;
        let arrIndex;
        if (index != -1) {
            name = line.substring(0, index).trim();
            value = line.substring(index + 1).trim();
            if (value) {
                const fv = value[0];
                const lv = value[value.length - 1];
                if (fv === lv) {
                    if (fv === '"' || fv === "'" || fv === '`') {
                        value = value.slice(1, -1);
                    }
                    if (value && fv === '`' && (value.indexOf('\\n') !== -1 || value.indexOf('\\r') !== -1)) {
                        value = value.replace(RAW_CRLF_RE, replaceCrLf);
                    }
                }
                else if (value === '0') {
                    value = 0;
                }
                else if (value.length < 16 && DIG_RE.test(value)) {
                    try {
                        value = parseInt(value, 10);
                    }
                    catch (e) { }
                }
            }
        }
        else {
            name = line.trim();
            value = '';
        }
        first = name[0];
        last = name[name.length - 1];
        if (first === last && last === '"') {
            name = name.slice(1, -1);
        }
        else if (first === '[' && last === ']') {
            name = name.slice(1, -1).trim();
            if (NUM_RE.test(name) || INDEX_RE.test(name)) {
                name = RegExp.$1 || RegExp['$&'];
                result = result || [];
            }
            else {
                const keys = name.split(/\s*\.\s*/);
                name = keys.shift().trim();
                if (ARR_FILED_RE.test(name)) {
                    const idx = RegExp.$2;
                    if (RegExp.$1) {
                        name = name.slice(0, -idx.length - 2);
                        arrIndex = parseInt(idx, 10);
                    }
                    else {
                        name = idx;
                        result = result || [];
                    }
                }
                if (keys.length) {
                    keys.reverse().forEach(function (key) {
                        let obj;
                        if (ARR_FILED_RE.test(key)) {
                            const idx2 = RegExp.$2;
                            const arr = [];
                            if (RegExp.$1) {
                                obj = {};
                                obj[key.slice(0, -idx2.length - 2)] = arr;
                                arr[idx2] = value;
                                value = obj;
                            }
                            else {
                                arr[idx2] = value;
                                value = arr;
                            }
                        }
                        else {
                            obj = {};
                            obj[key] = value;
                            value = obj;
                        }
                    });
                }
            }
        }
        result = result || {};
        const list = result[name];
        if (list == null) {
            if (arrIndex) {
                const arr = [];
                arr[arrIndex] = value;
                result[name] = arr;
            }
            else {
                result[name] = value;
            }
        }
        else if (typeof list === 'object') {
            if (arrIndex) {
                list[arrIndex] = value;
            }
            else if (typeof value === 'object') {
                extend(true, list, value);
            }
        }
    });
    return result || {};
}
export function parseJSON(data) {
    if (typeof data === 'object') {
        return data;
    }
    return parsePureJSON(data, true) || parseLinesJSON(data);
}
function parsePureJSON(data, isValue) {
    if (typeof data !== 'string' || !(data = data.trim())) {
        return null;
    }
    try {
        return JSON.parse(data);
    }
    catch (e) {
        const result = evalJson(data);
        if (result) {
            return result;
        }
    }
    return parseInlineJSON(data, isValue);
}
export function readFileSync(file) {
    try {
        return fs.readFileSync(file, UTF8_OPTIONS);
    }
    catch (e) {
        return undefined;
    }
}
export function trim(text) {
    return text && text.trim();
}
export function readInjectFiles(data, callback) {
    if (!data) {
        return callback();
    }
    fileMgr.readFilesText([data.prepend, data.replace, data.append], function (result) {
        if (result[0]) {
            data.top = result[0];
        }
        if (result[1]) {
            data.body = result[1];
        }
        if (result[2]) {
            data.bottom = result[2];
        }
        callback(data);
    });
}
export function parseHeaders(headers, rawNames) {
    if (typeof headers === 'string') {
        headers = headers.split(CRLF_RE);
    }
    const _headers = {};
    headers.forEach(function (line) {
        const index = line.indexOf(':');
        let value;
        if (index != -1) {
            value = line.substring(index + 1).trim();
            const rawName = line.substring(0, index).trim();
            const name = rawName.toLowerCase();
            let list = _headers[name];
            if (rawNames) {
                rawNames[name] = rawName;
            }
            if (list) {
                if (!Array.isArray(list)) {
                    _headers[name] = list = [list];
                }
                list.push(value);
            }
            else {
                _headers[name] = value;
            }
        }
    });
    return lowerCaseify(_headers);
}
const QUERY_PARAM_RE = /^[^\/&=]+=/;
export const parseRuleJson = function (rules, callback, req) {
    if (!Array.isArray(rules)) {
        rules = [rules];
    }
    Q.all(rules.map(function (rule) {
        const defer = Q.defer();
        readRuleList(rule, function (data) {
            defer.resolve(data);
        }, true, null, null, req);
        return defer.promise;
    })).spread(callback);
};
function readRuleValue(rule, callback, checkUrl, needRawData, req, isJson) {
    if (!rule) {
        return callback();
    }
    if (rule.value) {
        return callback(removeProtocol(rule.value, true));
    }
    let filePath = getMatcherValue(rule);
    if (checkUrl && GEN_URL_RE.test(filePath)) {
        return callback(filePath);
    }
    const opts = pluginMgr.resolveKey(filePath, rule, req);
    let readFile;
    if (opts) {
        readFile = pluginMgr[needRawData ? 'requestBin' : 'requestText'];
        filePath = opts;
        isJson = false;
    }
    else {
        readFile = fileMgr[needRawData ? 'readFile' : 'readFileText'];
        filePath = decodePath(filePath);
        if (rule.root) {
            filePath = join(rule.root, filePath);
        }
    }
    if (isJson && filePath.indexOf('=') !== -1) {
        try {
            const handleStat = function (err, stat) {
                if (err || !stat || !stat.isFile()) {
                    callback(filePath);
                }
                else {
                    readFile(filePath, callback);
                }
            };
            return fs.stat(filePath, function (err, stat) {
                if (err && err.code !== 'ENOENT') {
                    return fs.stat(filePath, handleStat);
                }
                else {
                    handleStat(err, stat);
                }
            });
        }
        catch (e) { }
    }
    readFile(filePath, callback);
}
function wrapTag(result, isBin, charset, wrap) {
    const list = [];
    let temp;
    result.forEach(function (data) {
        if (!data) {
            return;
        }
        if (typeof data !== 'string' || !GEN_URL_RE.test(data)) {
            temp = temp || [];
            temp.push(data);
            return;
        }
        temp && list.push(wrap(fileMgr.joinData(temp, !isBin, charset), charset));
        list.push(wrap(data.trim(), charset, true));
        temp = null;
    });
    temp && list.push(wrap(fileMgr.joinData(temp, !isBin, charset), charset));
    return list;
}
const CORS_RE = /^re[qs]Cors:\/\//;
function isDeep(result) {
    for (let i = 0, len = result.length; i < len; i++) {
        if (result[i] === true) {
            return true;
        }
    }
    return false;
}
function readRuleList(rule, callback, isJson, charset, isHtml, req) {
    if (!rule) {
        return callback();
    }
    let len = rule.list && rule.list.length;
    const isBin = isBinProtocol(rule.name);
    const needRawData = isBin && !isJson;
    if (!len) {
        return readRuleValue(rule, isJson
            ? function (value) {
                callback(parseJSON(value));
            }
            : callback, false, needRawData, req, isJson);
    }
    let result = [];
    const isJsHtml = isHtml && isBin === 2;
    const isCssHtml = isHtml && isBin === 3;
    const execCallback = function () {
        if (--len > 0) {
            return;
        }
        if (isJson) {
            const deepMerge = isDeep(result);
            result = result.map(parseJSON).filter(noop);
            if (result.length > 1) {
                result.reverse();
                if (typeof result[0] !== 'object') {
                    result[0] = {};
                }
                deepMerge && result.unshift(true);
                callback(extend.apply(null, result));
            }
            else {
                callback(result[0]);
            }
        }
        else {
            if (isJsHtml) {
                result = wrapTag(result, isBin, charset, wrapJs);
            }
            else if (isCssHtml) {
                result = wrapTag(result, isBin, charset, wrapCss);
            }
            if (rule.isRawList) {
                callback(result);
            }
            else {
                callback(fileMgr.joinData(result, !isBin, charset));
            }
        }
    };
    const isCors = CORS_RE.test(rule.matcher);
    const checkUrl = isJsHtml || isCssHtml;
    rule.list.forEach(function (r, i) {
        if (isJson) {
            const value = removeProtocol(getMatcher(r), true);
            if (value) {
                const json = isCors && GEN_URL_RE.test(value) ? { origin: value.trim() } : parsePureJSON(value, QUERY_PARAM_RE.test(value));
                if (json) {
                    result[i] = json;
                    return execCallback();
                }
            }
        }
        readRuleValue(r, function (value) {
            result[i] = value;
            execCallback();
        }, checkUrl, needRawData, req, isJson);
    });
}
export const getRuleValue = function (rules, callback, noBody, charset, isHtml, req) {
    if (noBody || !rules) {
        return callback();
    }
    if (!Array.isArray(rules)) {
        rules = [rules];
    }
    Q.all(rules.map(function (rule) {
        const defer = Q.defer();
        readRuleList(rule, function (data) {
            defer.resolve(data);
        }, false, charset, isHtml, req);
        return defer.promise;
    })).spread(callback);
};
function decodePath(path) {
    path = getPath(path, true);
    try {
        return decodeURIComponent(path);
    }
    catch (e) {
        logger.error(e);
    }
    try {
        return qs.unescape(path);
    }
    catch (e) {
        logger.error(e);
    }
    return path;
}
export const getRuleFiles = function (rule, req) {
    const files = rule.files || [getPath(getUrl(rule))];
    const root = rule.root;
    const rawFiles = rule.rawFiles || files;
    const result = [];
    files.map(function (file, i) {
        const opts = pluginMgr.resolveKey(rawFiles[i], rule, req);
        if (opts) {
            result.push(opts);
        }
        else {
            file = decodePath(file);
            file = fileMgr.convertSlash(root ? join(root, file) : file);
            if (END_WIDTH_SEP_RE.test(file)) {
                result.push(file.slice(0, -1));
                result.push(join(file, 'index.html'));
            }
            else {
                result.push(file);
            }
        }
    });
    return result;
};
export const getRuleFile = function (rule) {
    const filePath = getPath(getUrl(rule));
    if (!filePath) {
        return filePath;
    }
    return rule.root ? join(rule.root, decodePath(filePath)) : decodePath(filePath);
};
function getValue(rule) {
    return rule.value || rule.path;
}
function getMatcher(rule, raw) {
    let _rule = rule && (getValue(rule) || rule.matcher);
    if (_rule && raw !== true) {
        _rule = _rule.trim();
    }
    return _rule;
}
function getUrl(rule) {
    return rule && (getValue(rule) || rule.url);
}
export const rule = {
    getMatcher: getMatcher,
    getUrl: getUrl
};
export function getMatcherValue(rule) {
    rule = getMatcher(rule);
    return rule && removeProtocol(rule, true);
}
export function getUrlValue(rule, raw) {
    rule = getUrl(rule);
    if (rule && raw !== true) {
        rule = rule.trim();
    }
    return rule && removeProtocol(rule, true);
}
function _getRawType(type) {
    return typeof type === 'string' ? type.split(';')[0].toLowerCase() : '';
}
export function getRawType(data) {
    return _getRawType(data.headers && data.headers['content-type']);
}
export function getContentType(contentType) {
    if (contentType && typeof contentType !== 'string') {
        contentType = contentType['content-type'] || contentType.contentType;
    }
    contentType = _getRawType(contentType);
    if (!contentType) {
        return undefined;
    }
    if (contentType.indexOf('javascript') != -1) {
        return 'JS';
    }
    if (contentType.indexOf('css') != -1) {
        return 'CSS';
    }
    if (contentType.indexOf('html') != -1) {
        return 'HTML';
    }
    if (contentType.indexOf('json') != -1) {
        return 'JSON';
    }
    if (contentType.indexOf('xml') != -1) {
        return 'XML';
    }
    if (contentType.indexOf('text/') != -1) {
        return 'TEXT';
    }
    if (contentType.indexOf('image/') != -1) {
        return 'IMG';
    }
    return undefined;
}
export function supportHtmlTransform(res, req) {
    const headers = res.headers;
    if (getContentType(headers) != 'HTML' || !hasBody(res, req)) {
        return false;
    }
    const contentEncoding = getContentEncoding(headers);
    //chrome新增了sdch压缩算法，对此类响应无法解码，deflate无法区分deflate还是deflateRaw
    return !contentEncoding || contentEncoding == 'gzip';
}
export function removeUnsupportsHeaders(headers, supportsDeflate) {
    //只保留支持的zip格式：gzip、deflate
    if (!headers || !headers['accept-encoding']) {
        return;
    }
    if (config.noGzip) {
        delete headers['accept-encoding'];
        return;
    }
    const list = headers['accept-encoding'].split(/\s*,\s*/g);
    const acceptEncoding = [];
    for (let i = 0, len = list.length; i < len; i++) {
        const ae = list[i].toLowerCase();
        if (ae && ((supportsDeflate && ae == 'deflate') || ae == 'gzip')) {
            acceptEncoding.push(ae);
        }
    }
    if (acceptEncoding.length > 0) {
        headers['accept-encoding'] = acceptEncoding.join(', ');
    }
    else {
        delete headers['accept-encoding'];
    }
}
export function hasRequestBody(req) {
    req = typeof req === 'string' ? req : req.method;
    if (typeof req !== 'string') {
        return false;
    }
    req = req.toUpperCase();
    return !(req === 'GET' || req === 'HEAD' || req === 'OPTIONS' || req === 'CONNECT');
}
export function getContentEncoding(headers) {
    const encoding = toLowerCase((headers && headers['content-encoding']) || headers);
    return encoding === 'gzip' || encoding === 'deflate' ? encoding : null;
}
export function getZipStream(headers) {
    const encoding = getContentEncoding(headers);
    switch (encoding) {
        case 'gzip':
            return zlib.createGzip();
        case 'deflate':
            return zlib.createDeflate();
        default:
            return null;
    }
}
export function getUnzipStream(headers) {
    switch (getContentEncoding(headers)) {
        case 'gzip':
            return zlib.createGunzip();
        case 'deflate':
            return zlib.createInflate();
        default:
            return null;
    }
}
export const isWhistleTransformData = function (obj) {
    if (!obj) {
        return false;
    }
    if (obj.speed > 0 || obj.delay > 0) {
        return true;
    }
    return !!(obj.top || obj.body || obj.bottom);
};
export function getPipeIconvStream(headers) {
    const pipeStream = new PipeStream();
    let charset = getCharset(headers['content-type']);
    if (charset) {
        pipeStream.addHead(iconv.decodeStream(charset));
        pipeStream.addTail(iconv.encodeStream(charset));
    }
    else {
        pipeStream.addHead(function (res, next) {
            let buffer, iconvDecoder;
            res.on('data', function (chunk) {
                buffer = buffer ? Buffer.concat([buffer, chunk]) : chunk;
                resolveCharset(buffer);
            });
            res.on('end', resolveCharset);
            function resolveCharset(chunk) {
                if (!charset) {
                    if (chunk && buffer.length < 25600) {
                        return;
                    }
                    charset = !buffer || isUtf8(buffer) ? 'utf8' : 'GB18030';
                }
                if (!iconvDecoder) {
                    iconvDecoder = iconv.decodeStream(charset);
                    next(iconvDecoder);
                }
                if (buffer) {
                    iconvDecoder.write(buffer);
                    buffer = null;
                }
                !chunk && iconvDecoder.end();
            }
        });
        pipeStream.addTail(function (src, next) {
            next(src.pipe(iconv.encodeStream(charset || '')));
        });
    }
    return pipeStream;
}
export function toLowerCase(str) {
    return typeof str === 'string' ? str.trim().toLowerCase() : str;
}
export function toUpperCase(str) {
    return typeof str === 'string' ? str.trim().toUpperCase() : str;
}
const CHARSET_RE = /charset=([\w-]+)/i;
export function getCharset(str) {
    let charset;
    if (CHARSET_RE.test(str)) {
        charset = RegExp.$1;
        if (!iconv.encodingExists(charset)) {
            return;
        }
    }
    return charset;
}
function getClientIpFH(headers, name) {
    let val = headers[name];
    if (!isString(val)) {
        return '';
    }
    const index = val.indexOf(',');
    if (index !== -1) {
        val = val.substring(0, index);
    }
    val = removeIPV6Prefix(val.trim());
    return net.isIP(val) && !isLocalAddress(val) ? val : '';
}
export function getForwardedFor(headers) {
    let ip = getClientIpFH(headers, config.CLIENT_IP_HEAD);
    const cipKey = config.cipKey;
    if (cipKey && (!ip || config.overCipKey)) {
        ip = getClientIpFH(headers, cipKey) || ip;
    }
    return ip;
}
function isLocalIp(ip) {
    if (!isString(ip)) {
        return true;
    }
    return ip.length < 7 || ip === LOCALHOST;
}
export function getRemoteAddr(req) {
    try {
        const socket = req.socket || req;
        if (!socket._remoteAddr) {
            const ip = req.headers && req.headers[config.REMOTE_ADDR_HEAD];
            if (ip) {
                socket._remoteAddr = ip;
                delete req.headers[config.REMOTE_ADDR_HEAD];
            }
            else {
                socket._remoteAddr = removeIPV6Prefix(socket.remoteAddress) || LOCALHOST;
            }
        }
        return socket._remoteAddr;
    }
    catch (e) { }
    return LOCALHOST;
}
export function getClientIp(req) {
    const ip = getForwardedFor(req.headers || {}) || getRemoteAddr(req);
    return isLocalIp(ip) ? LOCALHOST : ip;
}
export function getRemotePort(req) {
    try {
        const socket = req.socket || req;
        if (socket._remotePort == null) {
            let port = req.headers && req.headers[config.REMOTE_PORT_HEAD];
            if (port) {
                delete req.headers[config.REMOTE_PORT_HEAD];
            }
            else {
                port = socket.remotePort;
            }
            socket._remotePort = port > 0 ? port : '0';
        }
        return socket._remotePort;
    }
    catch (e) { }
    return 0;
}
export const getClientPort = function (req) {
    const headers = req.headers || {};
    const port = headers[config.CLIENT_PORT_HEAD];
    if (port > 0) {
        return port;
    }
    return getRemotePort(req);
};
export function isUrlEncoded(req) {
    return /^post$/i.test(req.method) && /urlencoded/i.test(req.headers && req.headers['content-type']);
}
export function isJSONContent(req) {
    if (!hasRequestBody(req)) {
        return false;
    }
    return getContentType(req.headers) === 'JSON';
}
export function isProxyPort(proxyPort) {
    return (proxyPort == config.port ||
        proxyPort == config.httpsPort ||
        proxyPort == config.httpPort ||
        proxyPort == config.socksPort ||
        proxyPort == config.realPort);
}
export const isLocalPHost = function (req, isHttps) {
    const phost = req._phost;
    const hostname = phost && phost.hostname;
    if (!hostname || !isProxyPort(phost.port || (isHttps ? 443 : 80))) {
        return false;
    }
    return isLocalHost(hostname);
};
export function isMultipart(req) {
    return /multipart/i.test(req.headers['content-type']);
}
export function getQueryString(url) {
    const index = url.indexOf('?');
    return index == -1 ? '' : url.substring(index + 1);
}
export function replaceQueryString(query, replaceQuery) {
    if (replaceQuery && typeof replaceQuery !== 'string') {
        replaceQuery = qs.stringify(replaceQuery);
    }
    if (!query || !replaceQuery) {
        return query || replaceQuery;
    }
    const queryList = [];
    const params = {};
    const filterName = function (param) {
        const index = param.indexOf('=');
        let name, value;
        if (index == -1) {
            name = param;
            value = null;
        }
        else {
            name = param.substring(0, index);
            value = param.substring(index + 1);
        }
        const exists = name in params;
        params[name] = value;
        return exists ? null : name;
    };
    query = query.split('&').map(filterName);
    replaceQuery = replaceQuery.split('&').map(filterName);
    query.concat(replaceQuery).forEach(function (name) {
        const value = name ? params[name] : null;
        if (value != null) {
            queryList.push(name + '=' + value);
        }
    });
    return queryList.join('&');
}
export function replaceUrlQueryString(url, queryString) {
    if (!queryString) {
        return url;
    }
    url = url || '';
    const hashIndex = url.indexOf('#');
    let hashString = '';
    if (hashIndex != -1) {
        hashString = url.substring(hashIndex);
        url = url.substring(0, hashIndex);
    }
    queryString = replaceQueryString(getQueryString(url), queryString);
    return url.replace(/\?.*$/, '') + (queryString ? '?' + queryString : '') + hashString;
}
export const decodeBuffer = fileMgr.decode;
export function setHeaders(data, obj) {
    data.headers = data.headers || {};
    for (const i in obj) {
        data.headers[i] = obj[i];
    }
    return data;
}
export function setHeader(data, name, value) {
    data.headers = data.headers || {};
    data.headers[name] = value;
    return data;
}
export function join(root, dir) {
    return root ? path.resolve(root, dir) : dir;
}
export function resolveProperties(list, result) {
    result = result || {};
    if (list) {
        list
            .map(getMatcherValue)
            .join('|')
            .split(SEP_RE)
            .forEach(function (action) {
            if (action) {
                result[action] = true;
            }
        });
    }
    return result;
}
export const parseLineProps = function (str) {
    str = str && removeProtocol(str, true);
    if (!str) {
        return;
    }
    const result = {};
    str.split(SEP_RE).forEach(function (action) {
        if (action) {
            result[action] = true;
        }
    });
    return result;
};
function resolveIgnore(ignore) {
    const exclude = {};
    let keys = Object.keys(ignore);
    let ignoreAll, disableIgnoreAll;
    ignore = {};
    keys.forEach(name => {
        if (name.indexOf('ignore.') === 0 || name.indexOf('ignore:') === 0) {
            exclude[name.substring(7)] = 1;
            return;
        }
        if (name.indexOf('-') === 0 || name.indexOf('!') === 0) {
            name = name.substring(1);
            if (name === '*') {
                disableIgnoreAll = true;
            }
            else {
                exclude[name] = 1;
            }
            return;
        }
        name = name.replace('ignore|', '');
        if (name === 'filter' || name === 'ignore') {
            return;
        }
        if (name === 'allRules' || name === 'allProtocols' || name === 'All' || name === '*') {
            ignoreAll = true;
            return;
        }
        ignore[aliasProtocols[name] || name] = 1;
    });
    if (ignoreAll && !disableIgnoreAll) {
        protocols.forEach(function (name) {
            ignore[name] = 1;
        });
        keys = protocols;
    }
    else {
        keys = Object.keys(ignore);
    }
    keys.forEach(function (name) {
        if (exclude[name]) {
            delete ignore[name];
        }
    });
    return {
        ignoreAll: ignoreAll,
        exclude: exclude,
        ignore: ignore
    };
}
export function resolveFilter(ignore, filter) {
    filter = filter || {};
    const result = resolveIgnore(ignore);
    ignore = result.ignore;
    Object.keys(ignore).forEach(function (name) {
        if (protocols.indexOf(name) === -1) {
            filter['ignore|' + name] = true;
        }
        else {
            filter[name] = true;
        }
    });
    Object.keys(result.exclude).forEach(function (name) {
        filter['ignore:' + name] = 1;
    });
    if (result.ignoreAll) {
        filter.allRules = 1;
    }
    return filter;
}
export const isIgnored = function (filter, name) {
    return !filter['ignore:' + name] && (filter[name] || filter['ignore|' + name]);
};
export function exactIgnore(filter, rule) {
    if (filter['ignore|' + 'pattern=' + rule.rawPattern]) {
        return true;
    }
    if (filter['ignore|' + 'matcher=' + rule.matcher]) {
        return true;
    }
    return rule.rawMatcher && filter['ignore|' + 'matcher=' + rule.rawMatcher];
}
function notSkip(props, name) {
    return props['-' + name] || props['!' + name];
}
export const checkSkip = function (skip, rule, curUrl) {
    if (skip['*'] && !notSkip(skip, '*')) {
        return true;
    }
    const proto = getProtocolName(rule.url || rule.matcher) || getProtocolName(curUrl);
    const name = rule.name;
    if ((skip[name] || skip[proto]) && !notSkip(skip, name) && !notSkip(skip, proto)) {
        return true;
    }
    return false;
};
function resolveRuleProps(rule, result) {
    result = result || {};
    if (rule) {
        rule.list.forEach(function (rule) {
            getMatcherValue(rule)
                .split(SEP_RE)
                .forEach(function (action) {
                result[action] = true;
            });
        });
    }
    return result;
}
const PLUGIN_RE = /^(?:plugin|whistle)\.[a-z\d_\-]+$/;
const enableRules = ['https', 'intercept', 'capture', 'hide'];
function ignorePlugins(rules, name, exclude) {
    const isPlugin = name === 'plugin';
    if (!isPlugin && !PLUGIN_RE.test(name)) {
        return;
    }
    if (rules.plugin) {
        const list = rules.plugin.list;
        for (let i = list.length - 1; i >= 0; i--) {
            const pName = getProtocolName(list[i].matcher);
            if ((isPlugin || name === pName) && !exclude[pName]) {
                list.splice(i, 1);
            }
        }
        if (!list.length) {
            delete rules.plugin;
        }
    }
    return true;
}
function getProtocolName(url) {
    return PROTO_NAME_RE.test(url) ? RegExp.$1 : '';
}
function ignoreForwardRule(rules, name, exclude) {
    const isRule = name === 'rule';
    if (!isRule && rules[name]) {
        return;
    }
    if (rules.rule) {
        const pName = getProtocolName(rules.rule.url);
        if ((isRule || name === pName) && !exclude[pName]) {
            delete rules.rule;
        }
    }
    return true;
}
function ignoreProxy(rules, name, exclude) {
    if (!rules.proxy) {
        return;
    }
    if (name === 'proxy') {
        delete rules.proxy;
        return true;
    }
    if (!PROXY_RE.test(name)) {
        return;
    }
    const pName = getProtocolName(rules.proxy.url);
    const realName = aliasProtocols[name] || name;
    const realPName = aliasProtocols[pName] || pName;
    if (realName === realPName && !exclude[pName] && !exclude[realPName]) {
        delete rules.proxy;
    }
    return true;
}
const EXACT_IGNORE_RE = /^(?:pattern|matcher)=./;
export function ignoreRules(rules, ignore, isResRules) {
    const result = resolveIgnore(ignore);
    const ignoreAll = result.ignoreAll;
    const exclude = result.exclude;
    ignore = result.ignore;
    const keys = Object.keys(ignoreAll ? rules : ignore);
    let filter;
    keys.forEach(function (name) {
        if (EXACT_IGNORE_RE.test(name)) {
            filter = filter || {};
            filter['ignore|' + name] = true;
        }
        if (name === 'filter' || name === 'ignore' || exclude[name]) {
            return;
        }
        if (!isResRules || resProtocols.indexOf(name) !== -1) {
            if (ignorePlugins(rules, name, exclude) ||
                ignoreProxy(rules, name, exclude) ||
                ignoreForwardRule(rules, name, exclude)) {
                return;
            }
            delete rules[name];
        }
    });
    if (filter) {
        Object.keys(rules).forEach(function (name) {
            let rule = rules[name];
            let list = rule.list;
            const matched = exactIgnore(filter, rule);
            if (list) {
                list = list.filter(function (r) {
                    return !exactIgnore(filter, r);
                });
                if (!list.length) {
                    delete rules[name];
                }
                else {
                    if (matched) {
                        rule = extend({}, list[0]);
                        rules[name] = rule;
                    }
                    rule.list = list;
                }
            }
            else if (matched) {
                delete rules[name];
            }
        });
    }
}
export function filterRepeatPlugin(rule) {
    if (rule.name !== 'plugin') {
        return;
    }
    const exists = {};
    rule.list = rule.list.filter(function (p) {
        const protocol = p.matcher.substring(p.matcher.indexOf('.'), p.matcher.indexOf(':'));
        if (!exists[protocol]) {
            exists[protocol] = 1;
            return true;
        }
        return false;
    });
}
function mergeRule(curRule, newRule) {
    if (!curRule || !newRule || !newRule.list) {
        return newRule;
    }
    curRule.list = curRule.list.concat(newRule.list);
    filterRepeatPlugin(curRule);
    return curRule;
}
export function mergeRules(req, add, isResRules) {
    const origin = req.rules;
    const origAdd = add;
    add = add || {};
    const merge = function (protocol) {
        const rule = mergeRule(origin[protocol], add[protocol]);
        if (rule) {
            origin[protocol] = rule;
        }
    };
    if (isResRules && origAdd) {
        resProtocols.forEach(merge);
    }
    else if (origAdd) {
        Object.keys(origAdd).forEach(merge);
    }
    req['delete'] = resolveRuleProps(origin['delete'], req['delete']);
    req._filters = resolveRuleProps(origin.filter, req._filters);
    req.disable = resolveRuleProps(origin.disable, req.disable);
    req.ignore = resolveRuleProps(origin.ignore, req.ignore);
    req.enable = resolveRuleProps(origin.enable, req.enable);
    enableRules.forEach(function (rule) {
        if (req.enable[rule]) {
            req._filters[rule] = true;
        }
    });
    ignoreRules(origin, extend(req.ignore, req._filters), isResRules);
    return add;
}
export function parseHeaderReplace(rule) {
    const list = rule && rule.list;
    if (!list) {
        return '';
    }
    let result = '';
    list.forEach(function (item) {
        const obj = parseJSON(getMatcherValue(item));
        let prop, name;
        obj &&
            Object.keys(obj).forEach(function (key) {
                const value = obj[key];
                if (!key.indexOf('req.')) {
                    prop = 'req';
                    name = null;
                }
                else if (!key.indexOf('res.')) {
                    prop = 'res';
                    name = null;
                }
                else if (!key.indexOf('trailer.')) {
                    prop = 'trailer';
                    name = null;
                }
                else if (!prop) {
                    return;
                }
                result = result || {};
                const index = key.indexOf(':');
                name = name || key.substring(prop.length + 1, index).trim();
                if (!name) {
                    return;
                }
                key = key.substring(index + 1);
                const pattern = toOriginalRegExp(key);
                let opList = result[prop];
                const op = {
                    regExp: pattern,
                    name: name.toLowerCase(),
                    key: key,
                    value: value
                };
                if (opList) {
                    opList.push(op);
                }
                else {
                    result[prop] = opList = [op];
                }
            });
    });
    return result;
}
function replaceHeader(str, regExp, key, value) {
    if (str == null || str === '') {
        return str;
    }
    str = String(str);
    if (!regExp || !SUB_MATCH_RE.test(value)) {
        return str.replace(regExp || key, value);
    }
    return str.replace(regExp, function () {
        return replacePattern(value, arguments);
    });
}
export function handleHeaderReplace(headers, opList) {
    opList &&
        opList.forEach(function (item) {
            const header = headers[item.name];
            if (header == null || header === '') {
                return;
            }
            const regExp = item.regExp;
            const key = item.key;
            const value = item.value;
            if (Array.isArray(header)) {
                headers[item.name] = header.map(function (str) {
                    return replaceHeader(str, regExp, key, value);
                });
            }
            else {
                headers[item.name] = replaceHeader(header, regExp, key, value);
            }
        });
}
export function transformReq(req, res, port, host) {
    const options = parseUrl(getFullUrl(req));
    const headers = req.headers;
    options.headers = headers;
    options.method = req.method;
    options.agent = false;
    options.protocol = null;
    options.host = host || LOCALHOST;
    if (port > 0) {
        options.port = port;
    }
    if (req.clientIp || !net.isIP(headers[config.CLIENT_IP_HEAD])) {
        const clientIp = req.clientIp || getClientIp(req);
        if (isLocalAddress(clientIp)) {
            delete headers[config.CLIENT_IP_HEAD];
        }
        else {
            headers[config.CLIENT_IP_HEAD] = clientIp;
        }
    }
    options.hostname = null;
    const client = http.request(options, function (_res) {
        const origin = !_res.headers['access-control-allow-origin'] && req.headers.origin;
        if (origin) {
            _res.headers['access-control-allow-origin'] = origin;
            _res.headers['access-control-allow-credentials'] = true;
        }
        if (getStatusCode(_res.statusCode)) {
            res.writeHead(_res.statusCode, _res.headers);
            _res.pipe(res);
        }
        else {
            sendStatusCodeError(res, _res);
        }
    });
    let destroyed;
    const abort = function () {
        if (!destroyed) {
            destroyed = true;
            client.destroy();
        }
    };
    req.on('error', abort);
    res.on('error', abort);
    res.once('close', abort);
    client.on('error', function (err) {
        abort();
        res.emit('error', err);
    });
    req.pipe(client);
    return client;
}
export function trimStr(str) {
    if (typeof str !== 'string') {
        return '';
    }
    return str.trim();
}
function hasHeaderRules(headers) {
    return headers['x-whistle-rule-key'] || headers['x-whistle-rule-value'] || headers['x-whistle-rule-host'];
}
export function checkIfAddInterceptPolicy(proxyHeaders, headers) {
    if (hasHeaderRules(headers)) {
        proxyHeaders['x-whistle-policy'] = 'intercept';
        return true;
    }
    return false;
}
export function getCgiUrl(url) {
    if (!isString(url) || !(url = url.trim())) {
        return;
    }
    return url[0] === '/' ? url.substring(1) : url;
}
export const getCustomTab = function (tab, pluginName) {
    if (!tab || !isString(tab.name)) {
        return;
    }
    const name = tab.name.trim();
    const page = getPage(tab.page || tab.action);
    if (!name || !page || page.indexOf('#') !== -1) {
        return;
    }
    return {
        action: 'plugin.' + pluginName + '/' + page,
        name: name.substring(0, 32)
    };
};
export function getString(str) {
    if (!isString(str)) {
        return;
    }
    return str.trim();
}
function getPage(page) {
    page = getCgiUrl(page);
    return !page || page.length > 128 || !/\.html?$/i.test(page) ? null : page;
}
export const getPluginMenu = function (menus, pluginName) {
    if (!Array.isArray(menus)) {
        return;
    }
    const len = menus.length;
    const map = {};
    let count = 3;
    let result = [];
    let menu, name, page;
    for (let i = 0; i < len; i++) {
        if ((menu = menus[i]) &&
            (name = getString(menu.name)) &&
            !map[name] &&
            (page = getPage(menu.page || menu.action)) &&
            page.indexOf('#') === -1) {
            result = result || [];
            map[name] = 1;
            result.push({
                name: name.substring(0, 20),
                action: 'plugin.' + pluginName + '/' + page,
                required: menu.required ? true : undefined
            });
            if (--count === 0) {
                return result;
            }
        }
    }
    return result;
};
const MAX_HINT_LEN = 512;
const MAX_VAR_LEN = 100;
export function getHintList(conf, isVar) {
    const hintList = conf.hintList;
    if (!Array.isArray(hintList) || !hintList.length) {
        return;
    }
    let result;
    const maxLen = isVar ? MAX_VAR_LEN : MAX_HINT_LEN;
    hintList.forEach(function (hint) {
        if (typeof hint === 'string') {
            if (hint.length <= maxLen) {
                result = result || [];
                result.push(hint);
            }
        }
        else if (hint) {
            let text = hint.text || hint.value;
            text = typeof text === 'string' ? text.trim() : '';
            if (!text) {
                return;
            }
            let help = hint.help;
            const isKey = hint.isKey ? 1 : undefined;
            let displayText = hint.display || hint.displayText || hint.label;
            if (typeof help !== 'string') {
                help = '';
            }
            if (typeof displayText !== 'string') {
                displayText = '';
            }
            result = result || [];
            if (!isKey && !help && !displayText) {
                result.push(text);
            }
            else {
                result.push({
                    isKey: isKey,
                    text: text,
                    help: help.trim(),
                    displayText: displayText
                });
            }
        }
    });
    return result;
}
export const getPluginVarsConf = function (conf) {
    const pluginVars = conf.pluginVars;
    if (!pluginVars) {
        return;
    }
    const varHintList = getHintList(pluginVars, true);
    const varHintUrl = varHintList ? undefined : getCgiUrl(pluginVars.hintUrl);
    if (varHintList || varHintUrl) {
        return {
            hintUrl: varHintUrl,
            hintList: varHintList
        };
    }
    return true;
};
export const getStaticDir = function (conf) {
    const staticDir = conf.staticDir;
    if (!staticDir || typeof staticDir !== 'string' || !/^[\w./-]+$/.test(staticDir) || staticDir.length > 100) {
        return;
    }
    return staticDir.replace(/^\/+/, '');
};
export function toString(str) {
    if (str != null) {
        if (typeof str === 'string') {
            return str;
        }
        try {
            return JSON.stringify(str);
        }
        catch (e) { }
    }
    return '';
}
let index = 0;
function padReqId(num) {
    if (num > 99) {
        return num;
    }
    if (num > 9) {
        return '0' + num;
    }
    return '00' + num;
}
export const getReqId = function () {
    if (index > 999) {
        index = 0;
    }
    return Date.now() + '-' + padReqId(index++) + workerIndex;
};
export function onSocketEnd(socket, callback) {
    const execCallback = function (err) {
        socket._hasError = true;
        if (callback) {
            callback(err);
            callback = null;
        }
    };
    if (socket.aborted || socket.destroyed || socket._hasError) {
        return execCallback();
    }
    socket.on('error', execCallback);
    socket.once('close', execCallback);
    socket.once('end', execCallback);
    socket.once('timeout', execCallback);
}
export const getEmptyRes = function getRes() {
    const res = new PassThrough();
    res._transform = noop;
    res.on('data', noop);
    res.destroy = noop;
    return res;
};
const REQ_HEADER_RE = /^req\.?H(?:eaders?)?\.(.+)$/i;
const RES_HEADER_RE = /^res\.?H(?:eaders?)?\.(.+)$/i;
const TRAILER_RE = /trailer\.(.+)$/;
const HEADER_RE = /^headers\.(.+)$/;
export function parseDeleteProperties(req) {
    const deleteRule = req['delete'];
    const reqHeaders = {};
    const resHeaders = {};
    const trailers = {};
    if (deleteRule) {
        Object.keys(deleteRule).forEach(function (prop) {
            if (REQ_HEADER_RE.test(prop)) {
                reqHeaders[RegExp.$1.toLowerCase()] = 1;
            }
            else if (RES_HEADER_RE.test(prop)) {
                resHeaders[RegExp.$1.toLowerCase()] = 1;
            }
            else if (HEADER_RE.test(prop)) {
                prop = RegExp.$1.toLowerCase();
                reqHeaders[prop] = 1;
                resHeaders[prop] = 1;
            }
            else if (TRAILER_RE.test(prop)) {
                trailers[RegExp.$1.toLowerCase()] = 1;
            }
        });
    }
    return {
        reqHeaders: reqHeaders,
        resHeaders: resHeaders,
        trailers: trailers
    };
}
export const deleteReqHeaders = function (req) {
    const delReqHeaders = parseDeleteProperties(req).reqHeaders;
    const headers = req.headers;
    Object.keys(delReqHeaders).forEach(function (name) {
        delete headers[name];
    });
};
const URL_RE = /^https?:\/\/./;
function parseOrigin(origin) {
    if (!isString(origin)) {
        return;
    }
    let index = origin.indexOf('//');
    if (index !== -1) {
        index = origin.indexOf('/', index + 2);
        if (index != -1) {
            origin = origin.substring(0, index);
        }
    }
    return origin;
}
export const setReqCors = function (data, cors) {
    if (!cors) {
        return;
    }
    cors = lowerCaseify(cors);
    let origin;
    if (cors.origin === '*') {
        origin = cors.origin;
    }
    else if (URL_RE.test(cors.origin)) {
        origin = parseOrigin(cors.origin);
    }
    if (origin !== undefined) {
        setHeader(data, 'origin', origin);
    }
    else if (cors['*'] === '') {
        setHeader(data, 'origin', '*');
    }
    if (cors.method !== undefined) {
        setHeader(data, 'access-control-request-method', cors.method);
    }
    if (cors.headers !== undefined) {
        setHeader(data, 'access-control-request-headers', cors.headers);
    }
};
function isEnableCors(cors) {
    return cors.enable === '' || cors['use-credentials'] === '' || cors['credentials'] === '';
}
export const setResCors = function (data, cors, req) {
    if (!cors) {
        return;
    }
    cors = lowerCaseify(cors);
    let cusOrigin;
    if (cors.origin === '*') {
        cusOrigin = cors.origin;
    }
    else if (URL_RE.test(cors.origin)) {
        cusOrigin = parseOrigin(cors.origin);
    }
    const isEnable = isEnableCors(cors);
    const isOptions = req.method === 'OPTIONS';
    const isStar = cors['*'] === '';
    if (cusOrigin || isEnable) {
        const origin = cusOrigin || req.headers.origin;
        if (origin) {
            setHeaders(data, {
                'access-control-allow-credentials': true,
                'access-control-allow-origin': origin
            });
        }
    }
    else if (isStar) {
        setHeader(data, 'access-control-allow-origin', '*');
    }
    if (cors.methods !== undefined) {
        setHeader(data, 'access-control-allow-methods', cors.methods);
    }
    const autoComp = isOptions && (isStar || isEnable);
    if (cors.headers !== undefined) {
        const operate = isOptions ? 'allow' : 'expose';
        setHeader(data, 'access-control-' + operate + '-headers', cors.headers);
    }
    else if (autoComp) {
        const headers = req.headers['access-control-request-headers'];
        if (headers) {
            setHeader(data, 'access-control-allow-headers', headers);
        }
    }
    if (cors.credentials !== undefined) {
        setHeader(data, 'access-control-allow-credentials', cors.credentials);
    }
    else if (autoComp) {
        const method = req.headers['access-control-request-method'];
        if (method) {
            setHeader(data, 'access-control-allow-method', method);
        }
    }
    if (cors.maxage !== undefined) {
        setHeader(data, 'access-control-max-age', cors.maxage);
    }
};
export const disableReqProps = function (req) {
    const disable = req.disable;
    const headers = req.headers;
    if (disable.ua) {
        delete headers['user-agent'];
    }
    if (disable.gzip) {
        delete headers['accept-encoding'];
    }
    if (disable.cookie || disable.cookies || disable.reqCookie || disable.reqCookies) {
        delete headers.cookie;
    }
    if (disable.referer || disable.referrer) {
        delete headers.referer;
    }
    if (disable.ajax) {
        delete headers['x-requested-with'];
    }
    if (disable.cache) {
        disableReqCache(headers);
    }
};
export const disableResProps = function (req, headers) {
    const disable = req.disable;
    if (disable.cookie || disable.cookies || disable.resCookie || disable.resCookies) {
        delete headers['set-cookie'];
    }
    if (disable.cache) {
        headers['cache-control'] = 'no-cache';
        headers.expires = new Date(Date.now() - 60000000).toUTCString();
        headers.pragma = 'no-cache';
    }
    disable.csp && disableCSP(headers);
};
const G_INVALID_NAME_CHAR_RE = /[^\x00-\xFF]|[\r\n;=%]/gu;
const INVALID_NAME_CHAR_RE = /[\r\n;=]/;
function escapeName(name) {
    if (!name || (!NON_LATIN1_RE.test(name) && !INVALID_NAME_CHAR_RE.test(name))) {
        return name;
    }
    return name.replace(G_INVALID_NAME_CHAR_RE, safeEncodeURIComponent);
}
const G_INVALID_VALUE_CHAR_RE = /[^\x00-\xFF]|[\r\n;%]/gu;
const INVALID_VALUE_CHAR_RE = /[\r\n;]/;
function escapeValue(value) {
    if (!isString(value)) {
        return (value = value == null ? '' : String(value));
    }
    if (!NON_LATIN1_RE.test(value) && !INVALID_VALUE_CHAR_RE.test(value)) {
        return value;
    }
    return value.replace(G_INVALID_VALUE_CHAR_RE, safeEncodeURIComponent);
}
export const setReqCookies = function (data, cookies, curCookies) {
    const list = cookies && Object.keys(cookies);
    if (!list || !list.length) {
        return;
    }
    const result = {};
    if (isString(curCookies)) {
        curCookies.split(/;\s*/g).forEach(function (cookie) {
            const index = cookie.indexOf('=');
            if (index == -1) {
                result[cookie] = null;
            }
            else {
                result[cookie.substring(0, index)] = cookie.substring(index + 1);
            }
        });
    }
    list.forEach(function (name) {
        let value = cookies[name];
        value = value && typeof value === 'object' ? value.value : value;
        result[escapeName(name)] = value ? escapeValue(value) : value;
    });
    const cookiesStr = Object.keys(result)
        .map(function (name) {
        const value = result[name];
        return name + (value == null ? '' : '=' + value);
    })
        .join('; ');
    setHeader(data, 'cookie', cookiesStr);
};
export const setResCookies = function (data, cookies) {
    const list = cookies && Object.keys(cookies);
    if (!list || !list.length) {
        return;
    }
    let curCookies = data.headers && data.headers['set-cookie'];
    if (!Array.isArray(curCookies)) {
        curCookies = curCookies ? [curCookies + ''] : [];
    }
    const result = {};
    curCookies.forEach(function (cookie) {
        const index = cookie.indexOf('=');
        if (index == -1) {
            result[cookie] = null;
        }
        else {
            result[cookie.substring(0, index)] = cookie.substring(index + 1);
        }
    });
    list.forEach(function (name) {
        const cookie = cookies?.[name];
        name = escapeName(name);
        if (!cookie || typeof cookie !== 'object') {
            result[name] = cookie ? escapeValue(cookie) : cookie;
        }
        else {
            const attrs = [];
            const value = cookie.value;
            attrs.push(escapeValue(value));
            let maxAge = cookie.maxAge || cookie.maxage || cookie['Max-Age'] || cookie['max-age'];
            maxAge = parseInt(cookie.maxAge, 10);
            if (!Number.isNaN(maxAge)) {
                attrs.push('Expires=' + new Date(Date.now() + maxAge * 1000).toUTCString());
                attrs.push('Max-Age=' + maxAge);
            }
            cookie.secure && attrs.push('Secure');
            cookie.path && attrs.push('Path=' + cookie.path);
            cookie.domain && attrs.push('Domain=' + cookie.domain);
            (cookie.httpOnly || cookie.httponly) && attrs.push('HttpOnly');
            const sameSite = cookie.sameSite || cookie.samesite || cookie.SameSite;
            sameSite && attrs.push('SameSite=' + sameSite);
            result[name] = attrs.join('; ');
        }
    });
    const cookiesStr = Object.keys(result).map(function (name) {
        const value = result[name];
        return name + (value == null ? '' : '=' + value);
    });
    setHeader(data, 'set-cookie', cookiesStr);
};
export const escapeRegExp = function (str) {
    if (!str) {
        return '';
    }
    return str.replace(/[|\\{}()[\]^$+?.]/g, '\\$&');
};
export const checkTlsError = function (err) {
    if (!err) {
        return false;
    }
    if (err.code === 'EPROTO') {
        return true;
    }
    const stack = err.stack || err.message;
    if (!isString(stack)) {
        return false;
    }
    if (stack.indexOf('TLSSocket.onHangUp') !== -1 || stack.indexOf('statusCode=502') !== -1) {
        return true;
    }
    return stack.toLowerCase().indexOf('openssl') !== -1;
};
export const checkAuto2Http = function (req, ip, proxyUrl) {
    return (!req.disable.auto2http && (req.enable.auto2http || req.rules.host || (proxyUrl ? req._phost : isLocalAddress(ip))));
};
export const setProxyHost = function (req, options, reserve) {
    const phost = req._phost || options;
    const opts = reserve ? options : extend({}, options);
    opts.host = phost.hostname;
    if (phost.port > 0) {
        opts.port = phost.port;
    }
    opts.headers = opts.headers || {};
    config.setHeader(opts.headers, 'host', opts.host + ':' + opts.port);
    return opts;
};
export const getHostIp = function (ip, port) {
    if (!port) {
        return ip;
    }
    if (net.isIP(ip) === 6) {
        ip = '[' + ip + ']';
    }
    return ip + ':' + port;
};
export function getMethod(method) {
    if (typeof method !== 'string') {
        return 'GET';
    }
    return method.trim().toUpperCase() || 'GET';
}
const COMMENT_RE = /^\s*#/;
const SCRIPT_RE = /\b(?:rules|values)\b/;
export function isRulesContent(ctn) {
    return COMMENT_RE.test(ctn) || !SCRIPT_RE.test(ctn);
}
const RESPONSE_FOR_NAME = /^name=(.+)$/;
export const setResponseFor = function (rules, headers, req, serverIp) {
    let responseFor = getMatcherValue(rules.responseFor);
    if (!responseFor) {
        if (req.isPluginReq && !isLocalAddress(serverIp)) {
            responseFor = trimStr(headers['x-whistle-response-for']);
            responseFor = responseFor ? responseFor.split(',').map(trim).filter(noop) : [];
            if (responseFor.indexOf(serverIp) === -1) {
                responseFor.push(serverIp);
            }
            headers['x-whistle-response-for'] = responseFor.join(', ');
        }
        return;
    }
    const reqHeaders = req.headers;
    if (RESPONSE_FOR_NAME.test(responseFor)) {
        let result = RegExp.$1.toLowerCase().split(',');
        const reqResult = [];
        result = result
            .map(function (name) {
            if (name.indexOf('req.') === 0) {
                name = reqHeaders[name.substring(4)];
                name && reqResult.push(name);
                return;
            }
            return headers[name];
        })
            .filter(noop);
        result.push(serverIp || '127.0.0.1');
        responseFor = result.concat(reqResult).join(', ');
    }
    headers['x-whistle-response-for'] = responseFor;
};
export const getNoPluginServerMsg = function (rule) {
    let msg = 'No implement plugin.server';
    if (rule) {
        msg +=
            '\n       try to set the following rules:\n       <strong>' +
                rule.pattern +
                ' whistle.' +
                rule.matcher +
                '</strong>';
    }
    return msg;
};
const CONFIG_VAR_RE = /\${(port|version)}/gi;
const PLUGIN_RULES_URL_RE = /^whistle\.([a-z\d_-]+)(?:$|\/)/i;
const PLUGIN_KEY_RE = /^\$(?:whistle\.)?([a-z\d_-]+)[/:]([\S\s]+)$/;
function setConfigVarFn(_, name) {
    return config[name.toLowerCase()];
}
export const getRemoteRules = function (apo, rulesUrl) {
    let headers = config.runtimeHeaders;
    let pluginName;
    if (PLUGIN_RULES_URL_RE.test(rulesUrl)) {
        pluginName = RegExp.$1;
        rulesUrl = pluginName + '/' + rulesUrl.substring(RegExp['$&'].length);
        headers = config.pluginHeaders;
    }
    else if (PLUGIN_KEY_RE.test(rulesUrl)) {
        pluginName = RegExp.$1;
        rulesUrl = pluginName + '/api/key/value?key=' + safeEncodeURIComponent(RegExp.$2);
        headers = config.pluginHeaders;
    }
    if (apo) {
        rulesUrl = rulesUrl.replace(CONFIG_VAR_RE, setConfigVarFn);
    }
    return httpMgr.add(rulesUrl, headers, pluginName);
};
export function isCustomParser(req) {
    const enable = req.enable;
    return enable && (enable.customParser || enable.customFrames);
}
export const getParserStatus = function (req) {
    if (!isCustomParser(req)) {
        return;
    }
    const enable = req.enable;
    const customParser = ['custom'];
    if (enable.pauseSend) {
        customParser.push('pauseSend');
    }
    else if (enable.ignoreSend) {
        customParser.push('ignoreSend');
    }
    if (enable.pauseReceive) {
        customParser.push('pauseReceive');
    }
    else if (enable.ignoreReceive) {
        customParser.push('ignoreReceive');
    }
    return customParser.join();
};
export const isInspect = function (enable) {
    return enable.inspect || enable.pauseReceive || enable.pauseSend || enable.ignoreReceive || enable.ignoreSend;
};
const BYTES_RANGE_RE = /^\s*bytes=/i;
export const parseRange = function (req, size) {
    let range = size && req.headers.range;
    if (!range || !BYTES_RANGE_RE.test(range)) {
        return;
    }
    range = range.substring(range.indexOf('=') + 1).trim();
    if (!range) {
        return;
    }
    let start = size;
    let end = -1;
    range = range.split(',').forEach(function (item) {
        item = item.split('-');
        let s = parseInt(item[0], 10);
        let e = parseInt(item[1], 10);
        if (isNaN(s)) {
            if (isNaN(e)) {
                return;
            }
            s = size - e;
        }
        else if (isNaN(e)) {
            e = size - 1;
        }
        start = Math.min(s, start);
        end = Math.max(end, e);
    });
    if (start < 0 || end < 0 || start > end || end >= size) {
        return;
    }
    return {
        start: start,
        end: end
    };
};
export const parseClientInfo = function (req) {
    let clientInfo = req.headers[config.CLIENT_INFO_HEAD] || '';
    if (req.headers[config.REQ_FROM_HEADER] === 'W2COMPOSER') {
        req.fromComposer = true;
        delete req.headers[config.REQ_FROM_HEADER];
    }
    const socket = req.socket || '';
    if (socket.fromTunnel) {
        req.fromTunnel = true;
    }
    if (clientInfo) {
        delete req.headers[config.CLIENT_INFO_HEAD];
        clientInfo = String(clientInfo).split(',');
        if (!net.isIP(clientInfo[0]) || !(clientInfo[1] > 0)) {
            return '';
        }
        req.fromTunnel = true;
        socket.fromTunnel = true;
    }
    return clientInfo;
};
export function getCipher(rules) {
    let cipher = rules && getMatcherValue(rules.cipher);
    if (!cipher) {
        return TLSV2_CIPHERS;
    }
    cipher = cipher.toUpperCase();
    return CIPHER_OPTIONS.indexOf(cipher) === -1 ? TLSV2_CIPHERS : cipher;
}
export const connect = function (options, callback) {
    let socket;
    let timer;
    let done;
    let retry;
    const sockMgr = options.ALPNProtocols ? tls : net;
    const execCallback = function (err) {
        clearTimeout(timer);
        timer = null;
        if (!done) {
            done = true;
            err ? callback(err) : callback(null, socket);
        }
    };
    const handleConnect = function () {
        execCallback();
    };
    const handleError = function (err) {
        if (done) {
            return;
        }
        socket.removeAllListeners();
        socket.on('error', noop);
        socket.destroy(err);
        clearTimeout(timer);
        if (retry) {
            return execCallback(err);
        }
        retry = true;
        timer = setTimeout(handleTimeout, 12000);
        try {
            if (options.ALPNProtocols && err && isCiphersError(err)) {
                options.ciphers = getCipher(options._rules);
            }
            socket = sockMgr.connect(options, handleConnect);
        }
        catch (e) {
            return execCallback(e);
        }
        socket.on('error', handleError);
        socket.on('close', function (err) {
            !done && execCallback(err || new Error('closed'));
        });
    };
    const handleTimeout = function () {
        handleError(new Error('Timeout'));
    };
    timer = setTimeout(handleTimeout, 6000);
    try {
        socket = sockMgr.connect(options, handleConnect);
    }
    catch (e) {
        return execCallback(e);
    }
    socket.on('error', handleError);
};
export const checkPluginReqOnce = function (req, raw) {
    const isPluginReq = req.headers[config.PROXY_ID_HEADER];
    if (raw ? isPluginReq : isPluginReq == 1) {
        delete req.headers[config.PROXY_ID_HEADER];
    }
    return isPluginReq;
};
export const showPluginReq = function (req) {
    return !req.isPluginReq || config.showPluginReq;
};
export const checkPort = function (port, host, cb) {
    if (typeof host !== 'string') {
        cb = host;
        host = '127.0.0.1';
    }
    if (!port) {
        return cb?.();
    }
    const server = http.createServer();
    server.listen(port, host, function () {
        server.close(cb);
    });
};
const boundIpDeferMap = {};
export const getBoundIp = function (host, cb) {
    if (typeof host === 'function') {
        cb = host;
        host = null;
    }
    host = host || config.defaultHost;
    if (!host || net.isIP(host)) {
        return cb(host);
    }
    let boundIpDefer = boundIpDeferMap[host];
    if (boundIpDefer) {
        return boundIpDefer.done(cb);
    }
    const defer = Q.defer();
    boundIpDefer = defer.promise;
    boundIpDeferMap[host] = boundIpDefer;
    boundIpDefer.done(cb);
    dns.lookup(host, function (err, ip) {
        if (err) {
            throw err;
        }
        defer.resolve(ip);
    });
};
function getPluginConfig(conf, name) {
    let result;
    if (conf != null) {
        try {
            result = JSON.stringify(conf);
        }
        catch (e) { }
    }
    return '<script>window.' + (name || 'whistleMenuConfig') + ' = ' + (result || '{}') + ';</script>';
}
export const getPluginMenuConfig = function (conf) {
    return getPluginConfig(conf.menuConfig);
};
export const getPluginInspectorConfig = function (conf) {
    return getPluginConfig(conf.inspectorConfig, 'whistleInspectorConfig');
};
export const isEnableH2 = function (req) {
    const enable = req.enable || '';
    const disable = req.disable || '';
    return enable.h2 && !disable.h2;
};
export const isDisableH2 = function (req, strict) {
    const enable = req.enable || '';
    const disable = req.disable || '';
    return strict ? disable.http2 && !enable.http2 : disable.h2 && !enable.h2;
};
function isIllegalcHeader(name, value) {
    switch (name) {
        case constants.HTTP2_HEADER_CONNECTION:
        case constants.HTTP2_HEADER_UPGRADE:
        case constants.HTTP2_HEADER_HOST:
        case constants.HTTP2_HEADER_HTTP2_SETTINGS:
        case constants.HTTP2_HEADER_KEEP_ALIVE:
        case constants.HTTP2_HEADER_PROXY_CONNECTION:
        case constants.HTTP2_HEADER_TRANSFER_ENCODING:
            return true;
        case constants.HTTP2_HEADER_TE:
            return value !== 'trailers';
        default:
            return false;
    }
}
export const formatH2Headers = function (headers) {
    const newHeaders = {};
    Object.keys(headers).forEach(function (name) {
        const value = headers[name];
        if (!isIllegalcHeader(name, value)) {
            newHeaders[name] = value;
        }
    });
    return newHeaders;
};
function getProp(obj, key, def) {
    key = key.split('.');
    for (let i = 0; i < key.length; i++) {
        obj = obj ? obj[key[i]] : undefined;
    }
    return obj == null ? def : obj;
}
const PLUGIN_VAR_RE = /\{\{(?:whistlePluginName|whistlePluginPackage\.([^}\s]+))\}\}/g;
export const renderPluginRules = function (rules, pkg, simpleName) {
    return (rules &&
        rules.replace(PLUGIN_VAR_RE, function (_, key) {
            return key ? getProp(pkg, key, '') : simpleName;
        }));
};
export const setClientCert = function (options, key, cert, isPfx, cacheKey) {
    if (!cert) {
        return;
    }
    options.cacheKey = cacheKey;
    if (isPfx) {
        options.pfx = cert;
        if (key) {
            options.passphrase = key;
        }
    }
    else {
        options.key = key;
        options.cert = cert;
    }
};
export const getStatusCodeFromRule = function (rules) {
    let rule = rules.rule;
    const isSpec = rule && rule.isSpec;
    if (!isSpec) {
        return;
    }
    rule = getMatcherValue(rule);
    if (!rule) {
        return;
    }
    const result = {
        statusCode: rule,
        headers: {
            location: undefined
        }
    };
    if (isSpec === 2) {
        result.statusCode = 302;
        result.headers.location = rule;
    }
    else {
        handleStatusCode(rule, result.headers);
    }
    return result;
};
const GZIP_RE = /\bgzip\b/i;
export const canGzip = function (req) {
    return GZIP_RE.test(req.headers['accept-encoding']);
};
function removeBody(req, data, isRes) {
    const rule = req['delete'] || '';
    if (rule.body || rule[isRes ? 'res.body' : 'req.body']) {
        delete data.top;
        delete data.bottom;
        data.body = EMPTY_BUFFER;
    }
}
export const removeReqBody = function (req, data) {
    removeBody(req, data);
};
export const removeResBody = function (req, data) {
    removeBody(req, data, true);
};
export function readOneChunk(stream, callback, timeout) {
    if (!stream) {
        return callback();
    }
    let timer;
    const handler = function (chunk) {
        timer && clearTimeout(timer);
        stream.pause();
        stream.removeListener('data', handler);
        stream.removeListener('end', handler);
        callback(chunk);
    };
    if (timeout !== undefined && timeout > 0) {
        timer = setTimeout(handler, timeout);
    }
    stream.on('data', handler);
    stream.on('end', handler);
}
export const getAuthByRules = function (rules) {
    if (!rules.auth) {
        return;
    }
    const auth = getMatcherValue(rules.auth);
    if (/[\\\/]/.test(auth)) {
        return;
    }
    const index = auth.indexOf(':');
    return {
        username: index == -1 ? auth : auth.substring(0, index),
        password: index == -1 ? null : auth.substring(index + 1)
    };
};
export const getAuthBasic = function (auth) {
    if (!auth) {
        return;
    }
    let basic;
    if (auth.username == null) {
        if (auth.password == null) {
            return;
        }
        basic = [''];
    }
    else {
        basic = [auth.username];
    }
    if (auth.password != null) {
        basic[1] = auth.password;
    }
    return basic && 'Basic ' + toBuffer(basic.join(':')).toString('base64');
};
export const delay = function (time, callback) {
    if (time > 0) {
        setTimeout(callback, time);
    }
    else {
        callback();
    }
};
const F_HOST_RE = /\bhost\b/i;
const F_PROTO_RE = /\bproto\b/i;
const F_IP_RE = /\b(?:clientIp|ip|for)\b/i;
export const handleForwardedProps = function (req) {
    const headers = req.headers;
    const props = headers['x-whistle-forwarded-props'];
    let enableFwdHost = config.enableFwdHost;
    let enableFwdProto = config.enableFwdProto;
    let enableFwdFor = config.keepXFF;
    if (props != null) {
        enableFwdHost = enableFwdHost || F_HOST_RE.test(props);
        enableFwdProto = enableFwdProto || F_PROTO_RE.test(props);
        enableFwdFor = enableFwdFor || F_IP_RE.test(props);
        if (config.master && enableFwdFor) {
            headers['x-whistle-forwarded-props'] = 'ip';
        }
        else {
            delete headers['x-whistle-forwarded-props'];
        }
    }
    req.enableXFF = enableFwdFor;
    if (enableFwdHost) {
        const host = headers[config.FWD_HOST_HEADER];
        if (host) {
            delete headers[config.FWD_HOST_HEADER];
            headers[config.REAL_HOST_HEADER] = headers[config.REAL_HOST_HEADER] || host;
        }
    }
    if (enableFwdProto) {
        const proto = headers[config.HTTPS_PROTO_HEADER];
        if (proto) {
            delete headers[config.HTTPS_PROTO_HEADER];
            req.isHttps = proto === 'https';
        }
    }
};
export const filterWeakRule = function (req) {
    const rule = req.rules && req.rules.rule;
    if (!rule) {
        return;
    }
    const proxy = req.rules.proxy;
    if ((!proxy || proxy.lineProps.proxyHostOnly) && !req.rules.host) {
        return;
    }
    if (rule.lineProps.weakRule || isEnable(req, 'weakRule')) {
        delete req.rules.rule;
    }
};
export const setPluginMgr = function (p) {
    pluginMgr = p;
};
export function setTunnelHeaders(headers, remoteData) {
    const tunnelFirst = remoteData.tunnelFirst;
    if (remoteData.clientId) {
        headers[config.CLIENT_ID_HEADER] = remoteData.clientId;
    }
    if (remoteData.proxyAuth && (tunnelFirst || !headers['proxy-authorization'])) {
        headers['proxy-authorization'] = remoteData.proxyAuth;
    }
    if (remoteData.tunnelData) {
        headers[config.TUNNEL_DATA_HEADER] = remoteData.tunnelData;
    }
    if (remoteData.sniPlugin) {
        headers[config.SNI_PLUGIN_HEADER] = remoteData.sniPlugin;
    }
    const tunnelHeaders = remoteData.headers;
    if (tunnelHeaders) {
        Object.keys(tunnelHeaders).forEach(function (key) {
            if (tunnelFirst || !headers[key]) {
                headers[key] = tunnelHeaders[key];
            }
        });
    }
}
const tunnelDataKey = config.TUNNEL_DATA_HEADER;
const tmplDataKey = config.TEMP_TUNNEL_DATA_HEADER;
export const addTunnelData = function (socket, headers) {
    let data = socket[tunnelDataKey];
    if (!data) {
        data = headers[tmplDataKey];
        if (data) {
            delete headers[tmplDataKey];
            try {
                data = decodeURIComponent(data);
                data = JSON.parse(data);
                socket[tunnelDataKey] = data;
            }
            catch (e) {
                return;
            }
        }
    }
    data && setTunnelHeaders(headers, data);
};
function _isInternalProxy(rule) {
    return rule && rule.lineProps.internalProxy;
}
export const isInternalProxy = function (req) {
    if (isEnable(req, 'internalProxy')) {
        return true;
    }
    const rules = req.rules || '';
    return _isInternalProxy(rules.proxy) || _isInternalProxy(rules.host);
};
const IP_RE = /^(\d{1,3}(?:\.\d{1,3}){3}|localhost|\[[^\]]+\])(?::\d+)$/;
function checkProxyHostFn(host, filter) {
    let result;
    if (filter.hostPattern) {
        result = filter.hostPattern.test(host);
    }
    else if (filter.host === '<local>') {
        if (IP_RE.test(host)) {
            host = RegExp.$1;
        }
        result = host === 'localhost' || isLocalAddress(host);
    }
    else if (filter.host) {
        if (filter.host.slice(-1) === ':') {
            result = !host.indexOf(filter.host);
        }
        else {
            result = host === filter.host;
        }
    }
    return filter.not ? !result : result;
}
export const checkProxyHost = function (proxy, host) {
    const filters = proxy && proxy.hostFilter;
    if (filters) {
        if (!host) {
            return false;
        }
        let hasIncludeFilter;
        let include, exclude;
        for (let i = 0, len = filters.length; i < len; i++) {
            const filter = filters[i];
            hasIncludeFilter = hasIncludeFilter || filter.isInclude;
            if ((filter.isInclude ? !include : !exclude) && checkProxyHostFn(host, filter)) {
                if (filter.isInclude) {
                    include = true;
                }
                else {
                    exclude = true;
                }
            }
        }
        return hasIncludeFilter ? include && !exclude : !exclude;
    }
    return true;
};
