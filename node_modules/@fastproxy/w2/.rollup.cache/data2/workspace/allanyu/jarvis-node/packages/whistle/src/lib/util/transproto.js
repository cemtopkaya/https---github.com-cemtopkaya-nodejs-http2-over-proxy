import { Transform } from 'stream';
import { Buffer } from 'safe-buffer';
import { indexOf } from './buf-util';
const OPTIONS = { highWaterMark: 0 };
const LF = Buffer.from('\n');
function getBuffer(data) {
    return !data || Buffer.isBuffer(data) ? data : Buffer.from(String(data));
}
function packFn(data) {
    if (!data) {
        return Buffer.from('\n0\n');
    }
    return Buffer.concat([Buffer.from('\n' + data.length + '\n'), data]);
}
export const pack = function (data) {
    return packFn(getBuffer(data));
};
export const getEncodeTransform = function () {
    const trans = new Transform(OPTIONS);
    trans._transform = function (chunk, _, cb) {
        cb(null, packFn(chunk));
    };
    const push_ = trans.push;
    trans.push = function (chunk, encoding) {
        if (chunk) {
            return push_.call(trans, chunk, encoding);
        }
        return false;
    };
    const end_ = trans.end;
    trans.end = function (chunk, encoding, callback) {
        chunk && trans.write(chunk, encoding, callback);
        return end_.call(trans, function () {
            push_.call(trans, packFn());
        });
    };
    return trans;
};
class Parser {
    constructor(trans, data, transCb) {
        this.len = 0;
        this.setTransCb = (cb) => {
            this.transCb = cb;
        };
        this.parseChunk = () => {
            if (this.len <= 0) {
                const index = indexOf(this.buf, LF, 1);
                if (index === -1) {
                    return;
                }
                this.len = parseInt(String(this.buf?.slice(1, index)), 10);
                if (!this.len) {
                    return false;
                }
                this.buf = this.buf?.slice(index + 1);
                if (!this.buf?.length) {
                    return;
                }
            }
            const curLen = this.len;
            const chunk = this.buf?.slice(0, curLen);
            this.len -= chunk?.length || 0;
            this.buf =
                this.buf && this.buf.length > curLen ? this.buf.slice(curLen) : undefined;
            return chunk;
        };
        this.write = (chunk) => {
            if (chunk) {
                this.buf = this.buf ? Buffer.concat([this.buf, chunk]) : chunk;
            }
            else if (!this.buf) {
                return;
            }
            const data = this.parseChunk();
            if (data === false) {
                return this.onEnd?.();
            }
            if (!data) {
                if (chunk === false) {
                    return;
                }
                return this.onContinue?.();
            }
            this.onData?.(data);
            this.write(false);
        };
        this.onEnd = () => {
            this.data && this.trans.push(this.data);
            this.trans.push(null);
        };
        this.onContinue = () => {
            if (this.transCb) {
                this.transCb();
                this.transCb = undefined;
            }
        };
        this.onData = (chunk) => {
            this.data = this.data ? Buffer.concat([this.data, chunk]) : chunk;
            if (this.transCb) {
                this.transCb(null, this.data);
                this.transCb = this.data = undefined;
            }
        };
        this.trans = trans;
        this.data = data;
        this.transCb = transCb;
    }
}
export const getDecodeTransform = function () {
    const trans = new Transform(OPTIONS);
    const parser = new Parser(trans);
    trans._transform = function (chunk, _, cb) {
        parser.setTransCb(cb);
        parser.write(chunk);
    };
    return trans;
};
