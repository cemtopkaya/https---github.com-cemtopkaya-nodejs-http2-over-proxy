import { extend, net, url } from '../import-pkg';
import * as util from '../util';
import config from '../config';
import * as rulesUtil from './util';
import lookup from './dns';
import * as protoMgr from './protocols';
const rules = rulesUtil.rules;
const values = rulesUtil.values;
let allowDnsCache = true;
const SUB_MATCH_RE = /\$[&\d]/;
const SPACE_RE = /\s+/g;
const MULTI_TO_ONE_RE = /^\s*line`\s*[\r\n]([\s\S]*?)[\r\n]\s*`\s*?$/gm;
const MULTI_LINE_VALUE_RE = /^[^\n\r\S]*(```+)[^\n\r\S]*(\S+)[^\n\r\S]*[\r\n]([\s\S]*?)[\r\n][^\n\r\S]*\1\s*$/gm;
const WEB_PROTOCOL_RE = /^(?:https?|wss?|tunnel):\/\//;
const PORT_RE = /^(x?hosts?:\/\/)(?:([\w.-]*)|\[([:\da-f.]+)\])(?::(\d+))?$/i;
const PLUGIN_RE = /^(?:plugin|whistle)\.([a-z\d_\-]+:\/\/[\s\S]*)/;
const protocols = protoMgr.protocols;
const reqProtocols = protoMgr.reqProtocols;
const pureResProtocols = protoMgr.pureResProtocols;
const multiMatchs = protoMgr.multiMatchs;
const aliasProtocols = protoMgr.aliasProtocols;
const FILE_RE = /^(?:[a-z]:(?:\\|\/[^/])|\/[^/])/i;
const PROXY_RE = /^x?(socks|proxy|https?-proxy|internal-proxy|internal-https?-proxy|https2http-proxy|http2https-proxy):\/\//;
const VAR_RE = /\${([^{}]+)}/g;
const NO_SCHEMA_RE = /^\/\/[^/]/;
const WILDCARD_RE = /^(\$?((?:https?|wss?|tunnel):\/\/)?([^/?]+))/;
const RULE_KEY_RE = /^\$\{(\S+)\}$/;
const VALUE_KEY_RE = /^\{(\S+)\}$/;
const LINE_END_RE = /\n|\r\n|\r/;
const LOCAL_RULE_RE = /^https?:\/\/local\.(?:whistlejs\.com|wproxy\.org)(:realPort)?(?:\/|\?|$)/;
const PATH_RE = /^<.*>$/;
const VALUE_RE = /^\(.*\)$/;
const REG_URL_RE = /^((?:[\w.*-]+:|\*+)?\/\/)?([^/?]*)/;
const LIKE_REG_URL_RE = /^(?:(?:https?|wss?|tunnel):\/\/)?\*+\/[^?*]*\*/;
const LIKE_REG_URL_RE2 = /^(?:(?:https?|wss?|tunnel):\/\/)?\.[^./?]+\.[^/?]+\/[^?*]*\*/;
const DOT_DOMAIN_RE = /^\.[^./?]+\.[^/?]/;
const REG_URL_SYMBOL_RE = /^(\^+)/;
const PATTERN_FILTER_RE = /^(?:filter|ignore):\/\/(.+)\/(i)?$/;
const LINE_PROPS_RE = /^lineProps:\/\/(.*)$/;
const FILTER_RE = /^(?:excludeFilter|includeFilter):\/\/(.*)$/;
const PROPS_FILTER_RE = /^(?:filter|excludeFilter|includeFilter|ignore):\/\/(m(?:ethod)?|i(?:p)?|h(?:eader)?|s(?:tatusCode)?|from|b(?:ody)?|clientIp|clientIP|clientPort|remoteAddress|remotePort|serverIp|serverIP|serverPort|re[qs](?:H(?:eaders?)?)?):(.+)$/;
const PURE_FILTER_RE = /^(?:excludeFilter|includeFilter):\/\/(statusCode|from|clientIp|clientIP|clientPort|remoteAddress|remotePort|serverIp|serverIP|serverPort|host|re[qs](?:H(?:eaders?)?)?)[.=](.+)$/;
const PATTERN_WILD_FILTER_RE = /^(?:filter|ignore):\/\/(!)?(\*+\/)/;
const WILD_FILTER_RE = /^(\*+\/)/;
let regUrlCache = {};
let hostCache = {};
const NON_STAR_RE = /[^*]/;
const DOMAIN_STAR_RE = /([*~]+)(\\.)?/g;
const STAR_RE = /\*+/g;
const PORT_PATTERN_RE = /^!?:\d{1,5}$/;
const QUERY_RE = /[?#].*$/;
const COMMENT_RE = /#.*$/;
const TPL_RE = /^((?:[\w.-]+:)?\/\/)?(`.*`)$/;
// url:  protocol, host, port, hostname, search, query, pathname, path, href, query.key
// req|res: ip, method, statusCode, headers?.key, cookies?.key
const PLUGIN_NAME_RE = /^[a-z\d_\-]+(?:\.g?(?:all)?var(?:\$|\d*))?(?:\.replace\(.+\))?$/i;
const VAR_INDEX_RE = /^([a-z\d_\-]+)\.(g)?(all)?var(\$|\d*)/i;
const TPL_VAR_RE = /(\$)?\$\{(\{)?(id|reqId|whistle|now|host|port|realPort|realHost|version|url|hostname|query|search|queryString|searchString|path|pathname|clientId|localClientId|ip|clientIp|clientPort|remoteAddress|remotePort|serverIp|serverPort|method|status(?:Code)|reqCookies?|resCookies?|re[qs]H(?:eaders?)?)(?:\.([^{}]+))?\}(\})?/gi;
const REPLACE_PATTERN_RE = /(^|\.)replace\((.+)\)$/i;
const SEP_RE = /^[?/]/;
const COMMA1_RE = /\\,/g;
const COMMA2_RE = /\\\\,/g;
const G_CR_RE = /\r/g;
const G_LF_RE = /\n/g;
const SUFFIX_RE = /^\\\.[\w-]+$/;
const DOT_PATTERN_RE = /^\.[\w-]+(?:[?$]|$)/;
let inlineValues;
const CONTROL_RE = /[\u001e\u001f\u200e\u200f\u200d\u200c\u202a\u202d\u202e\u202c\u206e\u206f\u206b\u206a\u206d\u206c]+/g;
const ENABLE_PROXY_RE = /\bproxy(?:Host|First|Tunnel)|clientId|multiClient|singleClient\b/i;
const PLUGIN_VAR_RE = /^%([a-z\d_\-]+)([=.])([^\s]*)/;
const EXACT_IGNORE_RE = /^ignore:\/\/(pattern|matcher|operator)[=:](.+)$/;
const EXACT_SKIP_RE = /^(pattern|matcher|operator)[=:](.+)$/;
const NO_PROTO_RE = /[^\w!*|.-]/;
const SKIP_RE = /^skip:\/\//;
const SUB_VAR_RE = /\$\{RegExp\.\$([&\d])\}/g;
function domainToRegExp(_all, star, dot) {
    const len = star.length;
    let result = len > 1 ? '([^/?]*)' : '([^/?.]*)';
    if (dot) {
        result += '\\.';
        if (len > 2) {
            result = '(?:' + result + ')?';
        }
    }
    return result;
}
function pathToRegExp(all) {
    const len = all.length;
    if (len > 2) {
        return '(.*)';
    }
    return len > 1 ? '([^?]*)' : '([^?/]*)';
}
function queryToRegExp(all) {
    return all.length > 1 ? '(.*)' : '([^&]*)';
}
function isRegUrl(url, isCheck) {
    let result = regUrlCache[url];
    if (result) {
        return isCheck ? result : extend({}, result);
    }
    const oriUrl = url;
    const not = isNegativePattern(url);
    if (not) {
        url = url.substring(1);
    }
    if (DOT_PATTERN_RE.test(url)) {
        url = '^' + url;
    }
    let hasStartSymbol = REG_URL_SYMBOL_RE.test(url);
    let hasEndSymbol;
    let ignoreCase;
    let startWithDot;
    if (hasStartSymbol) {
        ignoreCase = RegExp.$1.length;
        url = url.substring(ignoreCase);
        hasEndSymbol = /\$$/.test(url);
        if (hasEndSymbol) {
            url = url.slice(0, -1);
        }
        ignoreCase = ignoreCase === 1;
    }
    else {
        startWithDot = LIKE_REG_URL_RE2.test(url);
        if (startWithDot || LIKE_REG_URL_RE.test(url)) {
            ignoreCase = hasStartSymbol = true;
        }
    }
    if (!hasStartSymbol || !REG_URL_RE.test(url)) {
        return false;
    }
    let protocol = RegExp.$1 || '';
    let domain = RegExp.$2;
    let pathname = url.substring(protocol.length + domain.length);
    let query = '';
    const index = pathname.indexOf('?');
    if (index !== -1) {
        query = pathname.substring(index);
        pathname = pathname.substring(0, index);
    }
    if (!protocol || protocol === '//') {
        protocol = '[a-z]+://';
    }
    else {
        protocol = util.escapeRegExp(protocol).replace(/\*+/, '([a-z:]+)');
    }
    if (startWithDot) {
        domain = domain.substring(1);
    }
    domain = util.escapeRegExp(domain);
    if (domain.length > 2 && !NON_STAR_RE.test(domain)) {
        domain = '([^?]*)';
    }
    else if (domain) {
        domain = domain.replace(DOMAIN_STAR_RE, domainToRegExp);
    }
    else {
        domain = '[^/?]*';
    }
    if (startWithDot) {
        domain = '(?:[^/?.]*.)?' + domain;
    }
    if (pathname) {
        pathname = util.escapeRegExp(pathname).replace(STAR_RE, pathToRegExp);
    }
    else if (hasStartSymbol && SUFFIX_RE.test(domain)) {
        pathname = '/[^?]+' + domain + (hasEndSymbol || query ? '' : '(?:\\??.*)$');
        domain = '[^/?]+';
    }
    else if (query || hasEndSymbol) {
        pathname = '/';
    }
    query =
        pathname +
            (query ? util.escapeRegExp(query).replace(STAR_RE, queryToRegExp) : '');
    const pattern = '^' + protocol + domain + query + (hasEndSymbol ? '$' : '');
    try {
        result = regUrlCache[oriUrl] = {
            not: not,
            pattern: new RegExp(pattern, ignoreCase ? 'i' : '')
        };
    }
    catch (e) { }
    return result;
}
function formatShorthand(url) {
    if (NO_SCHEMA_RE.test(url)) {
        return url;
    }
    if (url === '{}' ||
        VALUE_KEY_RE.test(url) ||
        PATH_RE.test(url) ||
        VALUE_RE.test(url)) {
        return 'file://' + url;
    }
    if (url === '/' || (FILE_RE.test(url) && !util.isRegExp(url))) {
        return 'file://' + url;
    }
    // compact Chrome
    if (/^file:\/\/\/[A-Z]:\//.test(url)) {
        return 'file://' + url.substring(8);
    }
    if (/^@/.test(url)) {
        if (url.indexOf('@://') === -1) {
            url = '@://' + url.substring(1);
        }
        return url.replace('@', 'G');
    }
    if (PLUGIN_VAR_RE.test(url)) {
        if (RegExp.$2 === '.') {
            url = url.replace('.', '=');
        }
        return url.replace('%', 'P://');
    }
    return url;
}
function formatUrl(pattern) {
    let queryString = '';
    const queryIndex = pattern.indexOf('?');
    if (queryIndex != -1) {
        queryString = pattern.substring(queryIndex);
        pattern = pattern.substring(0, queryIndex);
    }
    let index = pattern.indexOf('://');
    index = pattern.indexOf('/', index == -1 ? 0 : index + 3);
    return (index == -1 ? pattern + '/' : pattern) + queryString;
}
function getKey(url) {
    if (url.indexOf('{') == 0) {
        const index = url.lastIndexOf('}');
        return index > 1 && url.substring(1, index);
    }
    return false;
}
function getValue(url) {
    if (url.indexOf('(') == 0) {
        const index = url.lastIndexOf(')');
        return index != -1 ? url.substring(1, index) : url;
    }
    return false;
}
function getPath(url) {
    if (url.indexOf('<') == 0) {
        const index = url.lastIndexOf('>');
        return index != -1 ? url.substring(1, index) : url;
    }
    return false;
}
function getFiles(path) {
    return /^x?((raw)?file|tpl|jsonp|dust):\/\//.test(path)
        ? util.removeProtocol(path, true).split('|')
        : [];
}
function setProtocol(target, source) {
    if (util.hasProtocol(target)) {
        return target;
    }
    const protocol = util.getProtocol(source);
    if (protocol == null) {
        return target;
    }
    return protocol + (NO_SCHEMA_RE.test(target) ? '' : '//') + target;
}
function isPathSeparator(ch) {
    return ch == '/' || ch == '\\' || ch == '?';
}
/**
 * first: xxxx, xxxx?, xxx?xxxx
 * second: ?xxx, xxx?xxxx
 * @param first
 * @param second
 * @returns
 */
function joinQuery(firstQuery, secondQuery) {
    if (!firstQuery || !secondQuery) {
        return firstQuery || secondQuery;
    }
    secondQuery = secondQuery.substring(1);
    const firstLen = firstQuery.length;
    const secondLen = secondQuery.length;
    const sep = firstLen < 2 ||
        !secondLen ||
        firstQuery[firstLen - 1] === '&' ||
        secondQuery[0] === '&'
        ? ''
        : '&';
    return firstQuery + sep + secondQuery;
}
function join(first, second) {
    if (!first || !second) {
        return first + second;
    }
    const firstIndex = first.indexOf('?');
    const secondIndex = second.indexOf('?');
    let firstQuery = '';
    let secondQuery = '';
    if (firstIndex != -1) {
        firstQuery = first.substring(firstIndex);
        first = first.substring(0, firstIndex);
    }
    if (secondIndex != -1) {
        secondQuery = second.substring(secondIndex);
        second = second.substring(0, secondIndex);
    }
    if (second) {
        const lastIndex = first.length - 1;
        const startWithSep = isPathSeparator(second[0]);
        if (isPathSeparator(first[lastIndex])) {
            first = startWithSep
                ? first.substring(0, lastIndex) + second
                : first + second;
        }
        else {
            first = first + (startWithSep ? '' : '/') + second;
        }
    }
    const query = joinQuery(firstQuery, secondQuery);
    return WEB_PROTOCOL_RE.test(first) ? formatUrl(first + query) : first + query;
}
function toLine(_, line) {
    return line.replace(SPACE_RE, ' ');
}
function getLines(text, root) {
    if (!text || !(text = text.trim())) {
        return [];
    }
    text = text.replace(MULTI_TO_ONE_RE, toLine);
    const ruleKeys = {};
    const valueKeys = {};
    const lines = text.split(LINE_END_RE);
    const result = [];
    lines.forEach((line) => {
        line = line.trim();
        if (!line) {
            return;
        }
        const isRuleKey = RULE_KEY_RE.test(line);
        if (isRuleKey || VALUE_KEY_RE.test(line)) {
            if (root) {
                const key = RegExp.$1;
                line = '';
                if (isRuleKey) {
                    if (!ruleKeys[key]) {
                        ruleKeys[key] = 1;
                        line = rules.get(key);
                    }
                }
                else if (!valueKeys[key]) {
                    valueKeys[key] = 1;
                    line = values.get(key);
                }
                if (line) {
                    result.push.apply(result, line.split(LINE_END_RE));
                }
            }
        }
        else {
            result.push(line);
        }
    });
    return result;
}
function resolvePropValue(obj, key) {
    return (key && obj && obj[key.toLowerCase()]) || '';
}
function resolveUrlVar(req, key, escape) {
    const url = req.fullUrl || req.curUrl;
    if (!key) {
        return url;
    }
    let options = req.__options || req.options;
    if (!options || options.href !== url) {
        options = req.__options = util.parseUrl(url);
        req.__query = req.__query$ = '';
    }
    if (key.indexOf('query.') !== 0 || !options.query) {
        if (key === 'actualPort' || key === 'realPort') {
            return (options['port'] ||
                (options.protocol === 'https:' || options.protocol === 'wss:'
                    ? '443'
                    : '80'));
        }
        return options[key] || '';
    }
    const queryKey = '__query' + (escape ? '$' : '');
    let query = req[queryKey];
    if (!query) {
        query = req[queryKey] = util.parseQuery(options.query, null, null, escape);
    }
    return util.getQueryValue(query[key.substring(6)]);
}
function resolveReqCookiesVar(req, key, escape) {
    const cookie = req.headers.cookie || '';
    if (!cookie || !key) {
        return cookie;
    }
    let cookies = req.__cookies;
    if (!cookies || req.__rawCookies !== cookie) {
        req.__rawCookies = cookie;
        cookies = req.__cookies = util.parseQuery(cookie, '; ', null, escape);
    }
    return util.getQueryValue(cookies[key]);
}
function resolveResCookiesVar(req, key) {
    const resHeaders = req.resHeaders;
    let cookie = resHeaders && resHeaders['set-cookie'];
    let isArray = Array.isArray(cookie);
    if (!isArray && cookie) {
        isArray = true;
        cookie = [String(cookie)];
    }
    if (!isArray) {
        return cookie || '';
    }
    const rawCookie = cookie.join(', ');
    if (!key || !rawCookie) {
        return rawCookie;
    }
    let cookies = req.__resCookies;
    if (!cookies || req.__rawResCookies !== rawCookie) {
        req.__rawResCookies = cookie.join();
        cookies = req.__resCookies = {};
        cookie.forEach((c) => {
            c = util.parseQuery(c, '; ', null, escape);
            Object.keys(c).forEach(key => {
                const item = {};
                switch (key.toLowerCase()) {
                    case 'domain':
                        item.domain = c[key];
                        break;
                    case 'path':
                        item.path = c[key];
                        break;
                    case 'expires':
                        item.expires = c[key];
                        break;
                    case 'max-age':
                        item.maxAge = item['max-age'] = item['Max-Age'] = c[key];
                        break;
                    case 'httponly':
                        item.httpOnly = true;
                        break;
                    case 'secure':
                        item.secure = true;
                        break;
                    case 'samesite':
                        item.samesite = item.sameSite = item.SameSite = c[key];
                        break;
                    default:
                        if (!cookies[key]) {
                            item.value = c[key];
                            cookies[key] = item;
                        }
                }
            });
        });
    }
    const index = key.indexOf('.');
    let name;
    if (index !== -1) {
        name = key.substring(index + 1);
        key = key.substring(0, index);
    }
    cookie = cookies[key];
    if (!cookie) {
        return '';
    }
    return (name ? cookie[name] : cookie.value) || '';
}
function resolveClientIpVar(req) {
    return req.clientIp;
}
function resolveServerIpVar(req) {
    if (!req.resHeaders) {
        return '';
    }
    return req.hostIp || '127.0.0.1';
}
function resolveMethodVar(req) {
    return req.method;
}
function resolveStatusCodeVar(req) {
    return req.statusCode || '';
}
function resolveResHeadersVar(req, key) {
    return resolvePropValue(req.resHeaders, key);
}
function getPluginVar(vars, index) {
    if (!vars) {
        return '';
    }
    if (vars && index === '$') {
        index = vars.length - 1;
    }
    return (vars && vars[index || 0]) || '';
}
function resolveRuleValue(req, key) {
    const curRules = key && req.rules;
    if (curRules) {
        if (VAR_INDEX_RE.test(key)) {
            const shortName = RegExp.$1;
            const isGlobal = RegExp.$2;
            const isAll = RegExp.$3;
            const index = RegExp.$4 || 0;
            const gVars = req._globalPluginVars && req._globalPluginVars[shortName];
            let vars = req._pluginVars && req._pluginVars[shortName];
            if (isAll) {
                if (vars && gVars) {
                    vars = isGlobal ? gVars.concat(vars) : vars.concat(gVars);
                }
                return getPluginVar(vars || gVars, index);
            }
            return getPluginVar(isGlobal ? gVars : vars, index);
        }
        const plugin = curRules.plugin;
        let matcher;
        key = key + '://';
        if (plugin) {
            const list = Array.isArray(plugin.list) ? plugin.list : [plugin];
            const name = 'whistle.' + key;
            for (let i = 0, len = list.length; i < len; i++) {
                matcher = list[i].matcher;
                if (!matcher.indexOf(name)) {
                    return matcher.substring(name.length);
                }
            }
        }
        matcher = curRules.rule && curRules.rule.matcher;
        if (matcher && !matcher.indexOf(key)) {
            return matcher.substring(key.length);
        }
    }
    return '';
}
function resolveVarValue(req, escape, name, key) {
    const lname = name.toLowerCase();
    switch (lname) {
        case 'now':
            return Date.now();
        case 'id':
        case 'reqid':
            return req.reqId || '';
        case 'whistle':
            return resolveRuleValue(req, key);
        case 'path':
        case 'pathname':
        case 'search':
            return key ? '' : resolveUrlVar(req, lname, escape);
        case 'querystring':
        case 'searchstring':
            return key ? '' : resolveUrlVar(req, 'search', escape) || '?';
        case 'query':
            key = key ? 'query.' + key : 'query';
            return resolveUrlVar(req, key, escape);
        case 'url':
            return resolveUrlVar(req, key, escape);
        case 'port':
            return config.port;
        case 'host':
            return config.host || '';
        case 'realport':
            return config.realPort || config.port;
        case 'realhost':
            return config.realHost || config.host || '';
        case 'version':
            return config.version;
        case 'reqcookie':
        case 'reqcookies':
            return resolveReqCookiesVar(req, key, escape);
        case 'rescookie':
        case 'rescookies':
            return resolveResCookiesVar(req, key);
        case 'method':
            return resolveMethodVar(req);
        case 'ip':
        case 'clientip':
            return resolveClientIpVar(req);
        case 'clientid':
            return req._origClientId || util.getClientId(req.headers);
        case 'clientport':
            return req.clientPort || '';
        case 'localclientid':
            return config.clientId;
        case 'statuscode':
        case 'status':
            return resolveStatusCodeVar(req);
        case 'serverip':
            return resolveServerIpVar(req);
        case 'serverport':
            return req.serverPort || '';
        case 'reqh':
        case 'reqheader':
        case 'reqheaders':
            return resolvePropValue(req.headers, key);
        case 'hostname':
            return util.getHostname();
        case 'remoteaddress':
            return req._remoteAddr || '';
        case 'remoteport':
            return req._remotePort || '0';
        default:
            return resolveResHeadersVar(req, key);
    }
}
function resetComma(str) {
    return str && str.replace(G_CR_RE, ',').replace(G_LF_RE, '\\,');
}
function resolveTplVar(value, req) {
    return value.replace(TPL_VAR_RE, (all, escape, lb, name, key, rb) => {
        if ((lb && !rb) ||
            (name === 'whistle' && (!key || !PLUGIN_NAME_RE.test(key)))) {
            return all;
        }
        let pattern;
        let regPattern;
        let replacement = '';
        if (REPLACE_PATTERN_RE.test(key)) {
            pattern = RegExp.$2;
            const dot = RegExp.$1 || '';
            key = key.substring(0, key.length - 9 - dot.length - pattern.length);
            if (pattern.indexOf(',') !== -1) {
                pattern = pattern.replace(COMMA2_RE, '\n').replace(COMMA1_RE, '\r');
                const index = pattern.indexOf(',');
                if (index !== -1) {
                    replacement = resetComma(pattern.substring(index + 1));
                    pattern = pattern.substring(0, index);
                }
                pattern = resetComma(pattern);
            }
            regPattern = util.toOriginalRegExp(pattern);
        }
        let val = resolveVarValue(req, escape, name, key);
        if (typeof val !== 'string') {
            val = val == null ? '' : val + '';
        }
        if (!val || !pattern) {
            val = pattern ? val : val || replacement;
        }
        else if (!regPattern || !SUB_MATCH_RE.test(replacement)) {
            val = val.replace(regPattern || pattern, replacement);
        }
        else {
            val = val.replace(regPattern, () => {
                return util.replacePattern(replacement, arguments);
            });
        }
        if (val && lb) {
            val = util.encodeURIComponent(val);
        }
        return val + (!lb && rb ? '}' : '');
    });
}
function renderTpl(rule, req) {
    let matcher = rule.matcher;
    if (rule.isTpl === false) {
        return matcher;
    }
    rule.isTpl = false;
    matcher = matcher.replace(TPL_RE, (_, proto, value) => {
        rule.isTpl = true;
        return (proto || '') + resolveTplVar(value.slice(1, -1), req);
    });
    return matcher;
}
function resolveVar(rule, vals, req) {
    const matcher = renderTpl(rule, req);
    return matcher.replace(VAR_RE, (all, key) => {
        key = getValueFor(key, vals);
        if (typeof key === 'string') {
            return rule.isTpl && key ? resolveTplVar(key, req) : key;
        }
        return all;
    });
}
function getValueFor(key, vals) {
    if (!key) {
        return;
    }
    if (vals && key in vals) {
        let val = vals[key];
        val = vals[key] = val && typeof val === 'object' ? JSON.stringify(val) : val;
        return val;
    }
    return values.get(key);
}
function getRule(req, list, vals, index, isFilter, host) {
    const rule = resolveRuleList(req, list, vals, index || 0, isFilter, undefined, host);
    resolveValue(rule, vals, req);
    return rule;
}
function getRuleList(req, list, vals, isEnableProxy) {
    return resolveRuleList(req, list, vals, isEnableProxy).map((rule) => {
        return resolveValue(rule, vals, req);
    });
}
function resolveValue(rule, vals, req) {
    if (!rule) {
        return;
    }
    let matcher = rule.matcher;
    const index = matcher.indexOf('://') + 3;
    const protocol = matcher.substring(0, index);
    let regExp = rule.regExp;
    delete rule.regExp;
    matcher = matcher.substring(index);
    const key = getKey(matcher);
    if (key) {
        rule.key = key;
    }
    let value = getValueFor(key, vals);
    if (value == null) {
        value = false;
        regExp = null;
    }
    if (value !== false || (value = getValue(matcher)) !== false) {
        rule.value = protocol + value;
        if (rule.isTpl && regExp) {
            rule.value = rule.value.replace(SUB_VAR_RE, (_, index) => {
                index = index === '&' ? 0 : index;
                return regExp[index] || '';
            });
        }
        if (rule.isTpl) {
            rule.value = resolveTplVar(rule.value, req);
        }
    }
    else if ((value = getPath(matcher)) !== false) {
        rule.path = protocol + value;
        rule.files = getFiles(rule.path);
    }
    return rule;
}
function getRelativePath(pattern, url, matcher) {
    const index = url.indexOf('?');
    if (index === -1 || pattern.indexOf('?') !== -1) {
        return '';
    }
    if (matcher.indexOf('?') === -1) {
        return url.substring(index);
    }
    url = url.substring(index + 1);
    return (url && '&') + url;
}
function removeFilters(rule) {
    const filters = rule.filters;
    if (filters) {
        if (filters.curFilter) {
            rule.filter = filters.curFilter;
        }
        delete rule.filters;
    }
}
function replaceSubMatcher(url, regExp) {
    if (!regExp || !SUB_MATCH_RE.test(url)) {
        return url;
    }
    return util.replacePattern(url, regExp);
}
function resolveRuleList(req, list, vals, index, isFilter, isEnableProxy, host) {
    const curUrl = formatUrl(req.curUrl);
    const notHttp = list.isRuleProto && curUrl[0] !== 'h';
    //支持域名匹配
    const domainUrl = curUrl.replace(/^((?:https?|wss?|tunnel):\/\/[^\/]+):\d*(\/.*)/i, '$1$2');
    const isIndex = typeof index === 'number';
    index = isIndex ? index : -1;
    const results = [];
    const url = curUrl.replace(QUERY_RE, '');
    const _domainUrl = domainUrl.replace(QUERY_RE, '');
    let rule;
    let matchedUrl;
    let files;
    let matcher;
    let result;
    let origMatcher;
    let filePath;
    const getPathRule = () => {
        result = extend({
            files: files,
            url: join(matcher, filePath)
        }, rule);
        if (files && filePath) {
            result.files = files.map((file) => {
                return join(file, filePath);
            });
            result.rawFiles = files;
        }
        result.matcher = origMatcher;
        removeFilters(result);
        if (isIndex) {
            return result;
        }
        results.push(result);
    };
    const getExactRule = (relPath, regObj) => {
        origMatcher = resolveVar(rule, vals, req);
        origMatcher = replaceSubMatcher(origMatcher, regObj);
        matcher = setProtocol(origMatcher, curUrl);
        result = extend({
            files: getFiles(matcher),
            url: matcher + relPath
        }, rule);
        result.matcher = origMatcher;
        removeFilters(result);
        if (isIndex) {
            return result;
        }
        results.push(result);
    };
    const checkFilter = () => {
        if (notHttp && protoMgr.isFileProxy(rule.matcher)) {
            return false;
        }
        return ((isFilter || !matchExcludeFilters(curUrl, rule, req)) &&
            (host == null || util.checkProxyHost(rule, host)));
    };
    for (let i = 0; (rule = list[i]); i++) {
        if ((isEnableProxy && !ENABLE_PROXY_RE.test(rule.matcher)) ||
            (req._skipProps &&
                (util.exactIgnore(req._skipProps, rule) ||
                    util.checkSkip(req._skipProps, rule, curUrl)))) {
            continue;
        }
        const pattern = rule.isRegExp
            ? rule.pattern
            : setProtocol(rule.pattern, curUrl);
        const not = rule.not;
        let matchedRes;
        if (rule.isRegExp) {
            matchedRes = pattern.test(curUrl);
            matchedRes = not ? !matchedRes : matchedRes;
            let regExp;
            if (matchedRes) {
                regExp = {};
                if (!not) {
                    for (let j = 1; j < 10; j++) {
                        regExp[j] = RegExp['$' + j];
                    }
                }
            }
            if (matchedRes && checkFilter() && --index < 0) {
                regExp && (regExp['0'] = curUrl);
                matcher = resolveVar(rule, vals, req);
                // 支持 $x 包含 `|` 的情形
                matcher = setProtocol(replaceSubMatcher(matcher, regExp), curUrl);
                files = getFiles(matcher);
                result = extend({ url: matcher, files: files }, rule);
                result.matcher = matcher;
                result.regExp = regExp;
                removeFilters(result);
                if (isIndex) {
                    return result;
                }
                results.push(result);
            }
        }
        else if (rule.wildcard) {
            const wildcard = rule.wildcard;
            let hostname = null; // 不能去掉
            let regObj;
            if (wildcard.preMatch.test(curUrl)) {
                hostname = RegExp.$1;
                regObj = { 0: hostname };
                for (let k = 1; k < 9; k++) {
                    regObj[k] = RegExp['$' + (k + 1)];
                }
            }
            if (hostname != null && checkFilter()) {
                filePath = curUrl.substring(hostname.length);
                const wPath = wildcard.path;
                if (wildcard.isExact) {
                    if ((filePath === wPath || filePath.replace(QUERY_RE, '') === wPath) &&
                        --index < 0) {
                        if ((result = getExactRule(getRelativePath(wPath, filePath, rule.matcher), regObj))) {
                            return result;
                        }
                    }
                }
                else if (filePath.indexOf(wPath) === 0) {
                    const wpLen = wPath.length;
                    filePath = filePath.substring(wpLen);
                    if ((wildcard.hasQuery ||
                        !filePath ||
                        wPath[wpLen - 1] === '/' ||
                        SEP_RE.test(filePath)) &&
                        --index < 0) {
                        origMatcher = resolveVar(rule, vals, req);
                        origMatcher = replaceSubMatcher(origMatcher, regObj);
                        matcher = setProtocol(origMatcher, curUrl);
                        files = getFiles(matcher);
                        if (wildcard.hasQuery && filePath) {
                            filePath = '?' + filePath;
                        }
                        if ((result = getPathRule())) {
                            return result;
                        }
                    }
                }
            }
        }
        else if (rule.isExact) {
            matchedRes = pattern === url || pattern === curUrl;
            if ((not ? !matchedRes : matchedRes) && checkFilter() && --index < 0) {
                if ((result = getExactRule(getRelativePath(pattern, curUrl, rule.matcher)))) {
                    return result;
                }
            }
        }
        else if (((matchedUrl = curUrl.indexOf(pattern) === 0) ||
            (rule.isDomain && domainUrl.indexOf(pattern) === 0)) &&
            checkFilter()) {
            const len = pattern.length;
            origMatcher = resolveVar(rule, vals, req);
            matcher = setProtocol(origMatcher, curUrl);
            files = getFiles(matcher);
            const hasQuery = pattern.indexOf('?') !== -1;
            if ((hasQuery ||
                (matchedUrl
                    ? pattern == url || isPathSeparator(url[len])
                    : pattern == _domainUrl || isPathSeparator(_domainUrl[len])) ||
                isPathSeparator(pattern[len - 1])) &&
                --index < 0) {
                filePath = (matchedUrl ? curUrl : domainUrl).substring(len);
                if (hasQuery && filePath) {
                    filePath = '?' + filePath;
                }
                if ((result = getPathRule())) {
                    return result;
                }
            }
        }
    }
    return isIndex ? null : results;
}
function resolveProps(req, rules, vals, isIgnore) {
    let list = getRuleList(req, rules, vals);
    const result = {};
    if (isIgnore) {
        list = list.filter((rule) => {
            let matcher = rule.matcher;
            if (SKIP_RE.test(matcher)) {
                matcher = matcher.slice(7);
                if (!matcher) {
                    return false;
                }
                if (EXACT_SKIP_RE.test(matcher) || NO_PROTO_RE.test(matcher)) {
                    const prop = 'ignore|' +
                        (RegExp.$1 === 'pattern' ? 'pattern' : 'matcher') +
                        '=' +
                        (RegExp.$2 || matcher);
                    req._skipProps = req._skipProps || {};
                    result[prop] = true;
                    req._skipProps[prop] = true;
                    return false;
                }
                matcher.split('|').forEach((name) => {
                    if (name) {
                        req._skipProps = req._skipProps || {};
                        req._skipProps[name] = true;
                    }
                });
            }
            else if (EXACT_IGNORE_RE.test(matcher)) {
                result['ignore|' +
                    (RegExp.$1 === 'pattern' ? 'pattern' : 'matcher') +
                    '=' +
                    RegExp.$2] = true;
                return false;
            }
            return true;
        });
        if (!list.length) {
            return result;
        }
    }
    return util.resolveProperties(list, result);
}
function parseWildcard(pattern, not) {
    if (!WILDCARD_RE.test(pattern)) {
        return;
    }
    let preMatch = RegExp.$1;
    const protocol = RegExp.$2;
    const domain = RegExp.$3;
    const startWithDot = DOT_DOMAIN_RE.test(domain);
    if (!startWithDot &&
        domain.indexOf('*') === -1 &&
        domain.indexOf('~') === -1) {
        return;
    }
    if (not) {
        return false;
    }
    let path = pattern.substring(preMatch.length) || '/';
    const isExact = preMatch.indexOf('$') === 0;
    if (isExact) {
        preMatch = preMatch.substring(1);
    }
    const index = path.indexOf('?');
    const hasQuery = index !== -1;
    if (hasQuery && index === 0) {
        path = '/' + path;
    }
    const allowMatchPath = domain.length > 2 && !NON_STAR_RE.test(domain);
    if (allowMatchPath) {
        preMatch = '[^?]*';
    }
    else {
        if (!startWithDot &&
            (domain === '*' || domain === '~') &&
            path.charAt(0) === '/') {
            preMatch += '*';
        }
        const dLen = domain.length;
        preMatch = util
            .escapeRegExp(preMatch)
            .replace(DOMAIN_STAR_RE, domainToRegExp);
        if (domain[dLen - 1] !== '*' && domain.indexOf(':') === -1) {
            preMatch += '(?::\\d+)?';
        }
        if (startWithDot) {
            preMatch = preMatch.replace('\\.', '(?:[^/?.]*\\.)?');
        }
    }
    if (!protocol) {
        preMatch = '[a-z]+://' + preMatch;
    }
    else if (protocol === '//') {
        preMatch = '[a-z]+:' + preMatch;
    }
    preMatch =
        '^(' + preMatch + ')' + (allowMatchPath ? util.escapeRegExp(path) : '');
    return {
        preMatch: new RegExp(preMatch),
        path: path,
        hasQuery: hasQuery,
        isExact: isExact
    };
}
function parseRule(rulesMgr, pattern, matcher, raw, root, options) {
    if (isNegativePattern(matcher)) {
        return;
    }
    const regUrl = regUrlCache[pattern];
    const rawPattern = pattern;
    const rawMatcher = matcher;
    let noSchema;
    let isRegExp;
    let not;
    let port;
    let protocol = '';
    let isExact;
    let wildcard;
    if (regUrl) {
        not = regUrl.not;
        isRegExp = true;
        pattern = regUrl.pattern;
    }
    else {
        not = isNegativePattern(pattern);
        // 位置不能变
        const isPortPattern = PORT_PATTERN_RE.test(pattern);
        if (not) {
            pattern = pattern.substring(1);
        }
        if (NO_SCHEMA_RE.test(pattern)) {
            noSchema = true;
            pattern = pattern.substring(2);
        }
        if (!pattern) {
            return;
        }
        if (isPortPattern) {
            isRegExp = true;
            pattern = new RegExp('^[\\w]+://[^/?]+' + pattern + '/');
        }
        if (!isRegExp &&
            (isRegExp = util.isRegExp(pattern)) &&
            !(pattern = util.toRegExp(pattern))) {
            return;
        }
        if (!isRegExp) {
            wildcard = parseWildcard(pattern, not);
            if (wildcard === false) {
                return;
            }
            if (!wildcard && isExactPattern(pattern)) {
                isExact = true;
                pattern = pattern.slice(1);
            }
            else if (not) {
                return;
            }
        }
    }
    let proxyName;
    let isRules;
    let isSpec;
    if (isHost(matcher)) {
        matcher = 'host://' + matcher;
        protocol = 'host';
    }
    else if (matcher[0] === '/') {
        if (matcher[1] === '/') {
            protocol = 'rule';
        }
        else {
            matcher = 'file://' + matcher;
            protocol = 'file';
        }
    }
    else if (PLUGIN_RE.test(matcher)) {
        protocol = 'plugin';
    }
    else if (PROXY_RE.test(matcher)) {
        proxyName = RegExp.$1;
        protocol = 'proxy';
    }
    else {
        const index = matcher.indexOf('://');
        let origProto;
        if (index !== -1) {
            origProto = matcher.substring(0, index);
            protocol = aliasProtocols[origProto];
        }
        if (!protocol) {
            protocol = origProto || '';
            if (matcher === 'host://') {
                matcher = 'host://127.0.0.1';
            }
        }
        else if (protocol &&
            (origProto === 'reqRules' || origProto === 'resRules')) {
            isRules = true;
        }
        const isStatus = protocol === 'statusCode';
        if (isStatus || protocol === 'redirect') {
            isSpec = isStatus ? 1 : 2;
        }
    }
    const rules = rulesMgr._rules;
    let list = protocol === 'sniCallback' ? rulesMgr._sniCallback : rules[protocol];
    let useRealPort;
    if (!list) {
        protocol = 'rule';
        list = LOCAL_RULE_RE.test(matcher) ? rules._localRule : rules.rule;
        useRealPort = RegExp.$1;
    }
    else if (!matcher.indexOf('G://clientCert://')) {
        list = rules._clientCerts;
    }
    else if (protocol == 'host') {
        const protoIndex = matcher.indexOf(':') + 3;
        const realProto = matcher.substring(0, protoIndex);
        const opts = isHost(matcher.substring(protoIndex));
        if (opts) {
            matcher = realProto + opts.host;
            port = opts.port;
        }
    }
    const rule = {
        not: not,
        isRules: isRules,
        isSpec: isSpec,
        name: protocol,
        root: root,
        wildcard: wildcard,
        isRegExp: isRegExp,
        isExact: isExact,
        protocol: isRegExp ? null : util.getProtocol(pattern),
        pattern: isRegExp ? pattern : formatUrl(pattern),
        matcher: matcher,
        port: port,
        raw: raw,
        isDomain: !isRegExp &&
            !not &&
            (noSchema ? pattern : util.removeProtocol(rawPattern, true)).indexOf('/') == -1,
        rawPattern: rawPattern,
        rawMatcher: matcher === rawMatcher ? undefined : rawMatcher,
        filters: options.filters,
        lineProps: options.lineProps,
        hostFilter: options.hostFilter
    };
    if (protocol === 'proxy' || protocol === 'host') {
        rule.rawProps = options.rawProps;
    }
    else if (protocol === 'log' || protocol === 'weinre') {
        rule.isTpl = false;
    }
    if (useRealPort) {
        rule.realPort = config.realPort;
        rule.matcher = rule.matcher.replace('realPort', config.realPort || config.port);
    }
    if (proxyName) {
        switch (proxyName) {
            case 'socks':
                rule.isSocks = true;
                break;
            case 'https-proxy':
                rule.isHttps = true;
                break;
            case 'internal-http-proxy':
            case 'https2http-proxy':
            case 'internal-proxy':
                rule.isInternal = true;
                break;
            case 'internal-https-proxy':
                rule.isInternal = true;
                rule.isHttps = true;
                break;
            case 'http2https-proxy':
                rule.isHttp2https = true;
                break;
        }
    }
    if (options.hasBodyFilter) {
        rules._bodyFilters.push(rule);
    }
    list.push(rule);
}
function parse(rulesMgr, text, root, append) {
    if (!append) {
        protoMgr.resetRules(rulesMgr._rules);
        rulesMgr._globalPluginVars = {};
        rulesMgr._sniCallback = [];
    }
    if (Array.isArray(text)) {
        text.forEach(item => {
            item && parseText(rulesMgr, item.text, item.root);
        });
    }
    else {
        parseText(rulesMgr, text, root);
    }
}
function isPattern(item) {
    return (PORT_PATTERN_RE.test(item) ||
        NO_SCHEMA_RE.test(item) ||
        isExactPattern(item) ||
        isRegUrl(item, true) ||
        isNegativePattern(item) ||
        WEB_PROTOCOL_RE.test(item) ||
        util.isRegExp(item));
}
const IP_WITH_PORT_RE = /^\[([:\da-f.]+)\](?::(\d+))?$/i;
const IPV4_RE = /^(?:::(?:ffff:)?)?([\d.]+)(?:\:(\d+))?$/;
function parseHost(item) {
    let port;
    if (IP_WITH_PORT_RE.test(item)) {
        item = RegExp.$1;
        port = RegExp.$2;
    }
    if (IPV4_RE.test(item)) {
        port = port || RegExp.$2;
        item = RegExp.$1;
        if (!net.isIP(item)) {
            return false;
        }
    }
    else if (!net.isIP(item)) {
        return false;
    }
    return {
        host: item,
        port: port
    };
}
function isHost(item) {
    let result = hostCache[item];
    if (result == null) {
        result = parseHost(item);
    }
    hostCache[item] = result;
    return result;
}
function indexOfPattern(list) {
    let ipIndex = -1;
    for (let i = 0, len = list.length; i < len; i++) {
        const item = list[i];
        if (isPattern(item)) {
            return i;
        }
        if (!util.hasProtocol(item)) {
            if (!isHost(item)) {
                return i;
            }
            else if (ipIndex === -1) {
                ipIndex = i;
            }
        }
    }
    return ipIndex;
}
function resolveFilterPattern(matcher) {
    let not;
    let isInclude;
    let filter;
    let caseIns;
    let wildcard;
    if (PATTERN_FILTER_RE.test(matcher)) {
        filter = RegExp.$1;
        caseIns = RegExp.$2;
        not = filter[0] === '!';
        if (not) {
            filter = filter.substring(1);
        }
        if (filter[0] === '/') {
            filter = filter.substring(1);
        }
        return filter
            ? {
                not: not,
                filter: filter,
                caseIns: caseIns
            }
            : false;
    }
    else if (FILTER_RE.test(matcher)) {
        filter = RegExp.$1;
        if (!filter || filter === '!') {
            return false;
        }
        isInclude = matcher[0] === 'i';
        if (filter[0] === '!') {
            not = !not;
            filter = filter.substring(1);
        }
        if (util.isRegExp(filter)) {
            filter = RegExp.$1;
            caseIns = RegExp.$2;
            return {
                not: not,
                isInclude: isInclude,
                filter: filter,
                caseIns: caseIns
            };
        }
        if (filter[0] === '/' && filter[1] !== '/') {
            wildcard = '/';
        }
        else if (WILD_FILTER_RE.test(filter)) {
            wildcard = RegExp.$1;
        }
    }
    else if (PATTERN_WILD_FILTER_RE.test(matcher)) {
        not = RegExp.$1 || '';
        wildcard = RegExp.$2;
    }
    else {
        return;
    }
    if (wildcard) {
        matcher =
            filter || matcher.substring(matcher.indexOf('://') + 3 + not.length);
        let path = util.escapeRegExp(matcher.substring(wildcard.length));
        if (path.indexOf('*') !== -1) {
            path = path.replace(STAR_RE, pathToRegExp);
        }
        else if (path && path[path.length - 1] !== '/') {
            path += '(?:[/?]|$)';
        }
        return {
            not: not,
            isInclude: isInclude,
            filter: '^[a-z]+://' + (wildcard.length > 3 ? '[^?]' : '[^/?]') + '+/' + path
        };
    }
    const result = isRegUrl('^' + filter);
    if (result) {
        result.not = not;
        result.isInclude = isInclude;
        return result;
    }
}
function resolveMatchFilter(list) {
    const matchers = [];
    const lineProps = {};
    const rawProps = [];
    let filters;
    let hasBodyFilter;
    let hostFilter;
    list.forEach((matcher) => {
        if (LINE_PROPS_RE.test(matcher)) {
            rawProps.push(matcher);
            extend(lineProps, util.parseLineProps(matcher));
            return;
        }
        let filter;
        let not;
        let isInclude;
        let orgVal;
        if (PROPS_FILTER_RE.test(matcher) || PURE_FILTER_RE.test(matcher)) {
            const raw = RegExp['$&'];
            let propName = RegExp.$1;
            let value = RegExp.$2;
            const isHostFilter = propName === 'host';
            isInclude = matcher[1] === 'n';
            if (value[0] === '!') {
                not = !not;
                value = value.substring(1);
            }
            let pattern;
            const isIp = propName === 'i' || propName === 'ip';
            let isClientPort;
            let isServerPort;
            let isClientIp;
            let isServerIp;
            if (!isIp) {
                isClientPort = propName === 'clientPort';
                if (!isClientPort) {
                    isServerPort = propName === 'serverPort';
                    if (!isServerPort) {
                        isClientIp = propName[0] === 'c';
                        isServerIp =
                            !isClientIp &&
                                (propName === 'serverIp' || propName === 'serverIP');
                    }
                }
            }
            if (isClientPort || isServerPort) {
                pattern = util.toRegExp(value);
                if (isClientPort) {
                    propName = pattern ? 'cpPattern' : 'clientPort';
                }
                else {
                    propName = pattern ? 'spPattern' : 'serverPort';
                }
                value = pattern || value.toLowerCase();
            }
            else if (isIp || isClientIp || isServerIp) {
                pattern = util.toRegExp(value);
                if (!pattern && !net.isIP(value)) {
                    return;
                }
                if (isIp) {
                    propName = pattern ? 'iPattern' : 'ip';
                }
                else if (isClientIp) {
                    propName = pattern ? 'clientPattern' : 'clientIp';
                }
                else if (isServerIp) {
                    propName = pattern ? 'serverPattern' : 'serverIp';
                }
                value = pattern || value;
            }
            else if (propName[0] === 'm') {
                pattern = util.toRegExp(value, true);
                propName = pattern ? 'mPattern' : 'method';
                value = pattern || value.toUpperCase();
            }
            else if (propName === 'from') {
                pattern = null;
                propName = 'from';
                value = value.toLowerCase();
            }
            else if (propName === 's' || propName === 'statusCode') {
                pattern = util.toRegExp(value);
                propName = pattern ? 'sPattern' : 'statusCode';
                value = pattern || value.toLowerCase();
            }
            else if (propName === 'b' || propName === 'body') {
                hasBodyFilter = true;
                pattern = util.toRegExp(value);
                if (pattern) {
                    propName = 'bodyPattern';
                    value = pattern;
                }
                else {
                    propName = 'body';
                    value = {
                        orgVal: util.encodeURIComponent(value).toLowerCase(),
                        value: value.toLowerCase()
                    };
                }
            }
            else if (propName === 'remoteAddress') {
                pattern = util.toRegExp(value);
                if (pattern) {
                    propName = 'addrPattern';
                }
                value = pattern || value.toLowerCase();
            }
            else if (propName === 'remotePort') {
                pattern = util.toRegExp(value);
                if (pattern) {
                    propName = 'portPattern';
                }
                value = pattern || value.toLowerCase();
            }
            else if (isHostFilter) {
                pattern = util.toRegExp(value);
                if (pattern) {
                    propName = 'hostPattern';
                }
                value = pattern || value.toLowerCase();
            }
            else {
                const index = value.indexOf('=');
                let key = (index === -1 ? value : value.substring(0, index)).toLowerCase();
                const lastIndex = key.length - 1;
                if (key[lastIndex] === '!') {
                    key = key.substring(0, lastIndex);
                    if (!key) {
                        return;
                    }
                    not = !not;
                }
                orgVal = index === -1 ? '' : value.substring(index + 1);
                value = { key: key };
                if ((pattern = util.toRegExp(orgVal))) {
                    value.hPattern = pattern;
                }
                else {
                    orgVal = value.orgVal = orgVal.toLowerCase();
                    value.value = util.encodeURIComponent(orgVal);
                }
                switch (propName[2]) {
                    case 'q':
                        propName = 'reqHeader';
                        break;
                    case 's':
                        propName = 'resHeader';
                        break;
                    default:
                        propName = 'header';
                }
            }
            filter = { not: not, isInclude: isInclude };
            filter[propName] = value;
            filter.raw = raw;
            if (isHostFilter) {
                hostFilter = hostFilter || [];
                hostFilter.push(filter);
            }
            else {
                filters = filters || [];
                filters.push(filter);
            }
            return;
        }
        const result = resolveFilterPattern(matcher);
        if (result === false) {
            return;
        }
        else if (!result) {
            matchers.push(matcher);
            return;
        }
        if (result.pattern) {
            filters = filters || [];
            result.raw = matcher;
            return filters.push(result);
        }
        filter = '/' + result.filter + '/' + (result.caseIns ? 'i' : '');
        if ((filter = util.toRegExp(filter))) {
            filters = filters || [];
            filters.push({
                raw: matcher,
                pattern: filter,
                not: result.not,
                isInclude: result.isInclude
            });
        }
    });
    return {
        rawProps: rawProps,
        hasBodyFilter: hasBodyFilter,
        matchers: matchers,
        hostFilter: hostFilter,
        filters: filters,
        lineProps: lineProps
    };
}
function parseText(rulesMgr, text, root) {
    const pluginVars = rulesMgr._globalPluginVars;
    getLines(text, root).forEach(_line => {
        const raw = _line;
        _line = _line.replace(COMMENT_RE, '').trim();
        let line = (_line && _line.split(/\s+/)) || [];
        const len = line && line.length;
        if (len === 1 && PLUGIN_VAR_RE.test(line[0])) {
            const name = RegExp.$1;
            const value = RegExp.$3;
            if (value) {
                let vars = pluginVars[name];
                if (!vars) {
                    vars = [value];
                    pluginVars[name] = vars;
                }
                else if (vars.indexOf(value) === -1) {
                    vars.push(value);
                }
            }
            return;
        }
        if (!len || len < 2) {
            return;
        }
        line = line.map(formatShorthand);
        const patternIndex = indexOfPattern(line);
        if (patternIndex === -1) {
            return;
        }
        const pattern = line[0];
        const result = resolveMatchFilter(line.slice(1));
        const matchers = result.matchers;
        if (patternIndex > 0) {
            //supports: operator-uri1 operator-uriX pattern1 pattern2 ... patternN
            const opList = [pattern];
            const patternList = matchers.filter(p => {
                if (isPattern(p) || isHost(p) || !util.hasProtocol(p)) {
                    return true;
                }
                opList.push(p);
                return false;
            });
            opList.forEach(matcher => {
                patternList.forEach(pattern => {
                    parseRule(rulesMgr, pattern, matcher, raw, root, result);
                });
            });
        }
        else {
            //supports: pattern operator-uri1 operator-uri2 ... operator-uriN
            matchers.forEach(matcher => {
                parseRule(rulesMgr, pattern, matcher, raw, root, result);
            });
        }
    });
    regUrlCache = {};
    hostCache = {};
}
function isExactPattern(pattern) {
    return /^\$/.test(pattern);
}
function isNegativePattern(pattern) {
    return /^!/.test(pattern);
}
function getFilterResult(result, filter) {
    return result == null ? false : filter.not ? !result : result;
}
function matchFilter(url, filter, req) {
    let result;
    if (filter.pattern) {
        result = filter.pattern.test(url);
        return getFilterResult(result, filter);
    }
    if (!req) {
        return false;
    }
    const filterProp = (value, expectVal, pattern) => {
        if (value == null) {
            return expectVal || pattern;
        }
        if (expectVal) {
            result = value == expectVal;
            return true;
        }
        if (pattern) {
            result = pattern.test(value);
            return true;
        }
    };
    if (filter.from) {
        if (filter.from === 'tunnel') {
            return filter.not ? !req.fromTunnel : req.fromTunnel;
        }
        if (filter.from === 'composer') {
            return filter.not ? !req.fromComposer : req.fromComposer;
        }
        if (filter.from === 'sni') {
            return filter.not ? !req.useSNI : req.useSNI;
        }
        if (filter.from === 'httpserver') {
            return filter.not ? !req.fromHttpServer : req.fromHttpServer;
        }
        if (filter.from === 'httpsserver') {
            return filter.not ? !req.fromHttpsServer : req.fromHttpsServer;
        }
        if (filter.from === 'httpsport') {
            return filter.not ? !req.isHttpsServer : req.isHttpsServer;
        }
        return false;
    }
    if (filterProp(req.method, filter.method, filter.mPattern)) {
        return getFilterResult(result, filter);
    }
    if (filterProp(req.statusCode, filter.statusCode, filter.sPattern)) {
        return getFilterResult(result, filter);
    }
    if (filterProp(req.clientIp, filter.ip, filter.iPattern)) {
        return getFilterResult(result, filter);
    }
    if (filterProp(req.hostIp, filter.ip, filter.iPattern)) {
        return getFilterResult(result, filter);
    }
    if (filterProp(req.clientIp, filter.clientIp, filter.clientPattern)) {
        return getFilterResult(result, filter);
    }
    if (filterProp(req.hostIp, filter.serverIp, filter.serverPattern)) {
        return getFilterResult(result, filter);
    }
    if (filterProp(req.clientPort, filter.clientPort, filter.cpPattern)) {
        return getFilterResult(result, filter);
    }
    if (filterProp(req.serverPort, filter.serverPort, filter.spPattern)) {
        return getFilterResult(result, filter);
    }
    if (filterProp(req._remoteAddr, filter.remoteAddress, filter.addrPattern)) {
        return getFilterResult(result, filter);
    }
    if (filterProp(req._remotePort, filter.remotePort, filter.portPattern)) {
        return getFilterResult(result, filter);
    }
    let reqBody = req._reqBody;
    if (filter.bodyPattern || filter.body) {
        if (typeof reqBody !== 'string') {
            return false;
        }
        if (filter.bodyPattern) {
            result = filter.bodyPattern.test(reqBody);
        }
        else {
            reqBody = reqBody.toLowerCase();
            result =
                reqBody.indexOf(filter.body.value) !== -1 ||
                    reqBody.indexOf(filter.body.orgVal) !== -1;
        }
        return filter.not ? !result : result;
    }
    const filterHeader = (headers, filterVal, resHeaders) => {
        if (!filterVal || !headers) {
            return;
        }
        let value = headers[filterVal.key];
        if (value == null) {
            value = resHeaders && resHeaders[filterVal.key];
            if (value == null) {
                result = false;
                return true;
            }
        }
        if (!value) {
            result = !filterVal.hPattern && !filterVal.value;
            return true;
        }
        value = String(value);
        if (filterVal.hPattern) {
            result = filterVal.hPattern.test(value);
        }
        else {
            value = value.toLowerCase();
            result =
                value.indexOf(filterVal.value) !== -1 ||
                    value.indexOf(filterVal.orgVal) !== -1;
        }
        return true;
    };
    if (filterHeader(req.headers, filter.header, req.resHeaders)) {
        return getFilterResult(result, filter);
    }
    if (filterHeader(req.headers, filter.reqHeader)) {
        return getFilterResult(result, filter);
    }
    if (filterHeader(req.resHeaders, filter.resHeader)) {
        return getFilterResult(result, filter);
    }
    return false;
}
function matchExcludeFilters(url, rule, options) {
    const filters = rule.filters;
    if (!filters) {
        return;
    }
    filters.curFilter = null;
    let hasIncludeFilter;
    let include;
    let exclude;
    for (let i = 0, len = filters.length; i < len; i++) {
        const filter = filters[i];
        hasIncludeFilter = hasIncludeFilter || filter.isInclude;
        if ((filter.isInclude ? !include : !exclude) &&
            matchFilter(url, filter, options)) {
            if (filter.isInclude) {
                include = true;
                filters.curFilter = filter.raw;
            }
            else {
                exclude = true;
            }
        }
    }
    return hasIncludeFilter ? !include || exclude : exclude;
}
function resolveInlineValues(str) {
    str = str && str.replace(CONTROL_RE, '').trim();
    if (!str || str.indexOf('```') === -1) {
        return str;
    }
    return str.replace(MULTI_LINE_VALUE_RE, (_, __, key, value) => {
        inlineValues = inlineValues || {};
        if (!inlineValues[key]) {
            inlineValues[key] = value;
        }
        return '';
    });
}
function resolveInlineValuesFn(item) {
    item.text = resolveInlineValues(item.text);
    return item;
}
function trimInlineValues(text) {
    return Array.isArray(text)
        ? text.map(resolveInlineValuesFn)
        : resolveInlineValues(text);
}
const ignoreHost = (req, rulesMgr, filter) => {
    if (!rulesMgr) {
        return false;
    }
    const ignore = rulesMgr.resolveFilter(req);
    extend(filter, ignore);
    return (ignore.host ||
        ignore.hosts ||
        ignore['ignore|host'] ||
        ignore['ignore|hosts']);
};
const pluginProtocols = [
    'enable',
    'disable',
    'plugin',
    'rule',
    'reqHeaders',
    'auth',
    'referer',
    'forwardedFor'
];
const proxyProtocols = [
    'enable',
    'disable',
    'plugin',
    'reqHeaders',
    'auth',
    'referer',
    'forwardedFor'
];
function resolveRules(req, isReq, isRes) {
    if (req.isInternalUrl) {
        return {};
    }
    let rule;
    const rules = this._rules;
    const _rules = {};
    const vals = this._values;
    const filter = this.resolveFilter(req);
    let protos;
    if (req.isPluginReq) {
        protos = req._isProxyReq ? proxyProtocols : pluginProtocols;
    }
    else {
        protos = isRes ? pureResProtocols : isReq ? reqProtocols : protocols;
    }
    req._inlineValues = vals;
    protos.forEach((name) => {
        if (name !== 'pipe' &&
            (name === 'proxy' ||
                name === 'rule' ||
                name === 'plugin' ||
                !filter[name]) &&
            (rule = getRule(req, rules[name], vals))) {
            _rules[name] = rule;
        }
    });
    multiMatchs.forEach((name) => {
        rule = _rules[name];
        if (rule) {
            rule.list = getRuleList(req, rules[name], vals);
            util.filterRepeatPlugin(rule);
            if (name === 'rulesFile' || name === 'resScript') {
                let hasScript;
                let scriptIndex = -1;
                rule.list = rule.list.filter((item, i) => {
                    if (item.isRules) {
                        return true;
                    }
                    if (hasScript) {
                        return false;
                    }
                    scriptIndex = i;
                    hasScript = true;
                    return true;
                });
                rule.scriptIndex = scriptIndex;
                rule.isRawList = true;
            }
        }
    });
    util.ignoreRules(_rules, filter);
    return _rules;
}
function mergeRule(rules, list, name) {
    if (list.length) {
        if (rules[name]) {
            const curList = rules[name].list;
            const flags = curList.map((item) => {
                return item.raw;
            });
            list.forEach((item) => {
                if (flags.indexOf(item.raw) === -1) {
                    curList.push(item);
                }
            });
        }
        else {
            rules[name] = extend({ list: list }, list[0]);
        }
    }
}
function resolveSingleRule(req, protocol, multi) {
    req.curUrl = req.curUrl || req.fullUrl;
    const filter = this.resolveFilter(req);
    if (util.isIgnored(filter, protocol)) {
        return;
    }
    let list = protocol === 'sniCallback' ? this._sniCallback : this._rules[protocol];
    if (multi) {
        list = getRuleList(req, list, this._values).filter((rule) => {
            return !util.exactIgnore(filter, rule);
        });
        return list.length ? list : null;
    }
    const rule = getRule(req, list, this._values);
    return rule && !util.exactIgnore(filter, rule) ? rule : null;
}
const WHISTLE_INTERNAL_HOST = /^reqHeaders:\/\/whistleInternalHost=([a-z\d.-]+(?::\d{1,5})?)$/;
export default class Rules {
    constructor(values) {
        this.parse = (...args) => {
            const [text, root, _inlineValues] = args;
            let item = {
                first: true,
                text: text,
                root: root
            };
            this._inlineValues = _inlineValues;
            this.disabled = !args.length;
            if (this._rawText) {
                if (this._rawText[0].first) {
                    this._rawText.shift();
                }
                this._rawText.unshift(item);
            }
            else {
                this._rawText = [item];
            }
            inlineValues = _inlineValues ? extend({}, _inlineValues) : null;
            parse(this, trimInlineValues(text), root);
            if (!this.disabled) {
                for (let i = 1, len = this._rawText.length; i < len; i++) {
                    item = this._rawText[i];
                    parse(this, trimInlineValues(item.text), item.root, true);
                }
            }
            if (inlineValues) {
                this._values = extend({}, this._orgValues, inlineValues);
                inlineValues = null;
            }
            else {
                this._values = this._orgValues;
            }
        };
        this.clearAppend = () => {
            if (this._rawText && this._rawText[0].first) {
                const item = this._rawText[0];
                inlineValues = this._inlineValues ? extend({}, this._inlineValues) : null;
                !this.disabled && parse(this, trimInlineValues(item.text), item.root);
                this._rawText = [item];
                if (inlineValues) {
                    this._values = extend({}, this._orgValues, inlineValues);
                    inlineValues = null;
                }
            }
            else {
                this._rawText = null;
            }
        };
        this.append = (text, root) => {
            const item = {
                text: text,
                root: root
            };
            if (this._rawText) {
                this._rawText.push(item);
                !this.disabled && parse(this, trimInlineValues(text), root, true);
                if (inlineValues) {
                    extend(this._values, inlineValues);
                    inlineValues = null;
                }
            }
            else {
                this._rawText = [item];
            }
        };
        this.resolveHost = (req, callback, pluginRulesMgr, rulesFileMgr, headerRulesMgr) => {
            if (!req.curUrl) {
                return callback();
            }
            const host = this.getHost(req, pluginRulesMgr, rulesFileMgr, headerRulesMgr);
            if (host) {
                return callback(null, util.removeProtocol(host.matcher, true), host.port, host);
            }
            if (!req._enableProxyHost && req.rules) {
                delete req.rules.host;
            }
            this.lookupHost(req, callback);
        };
        this.lookupHost = (req, callback) => {
            req.curUrl = formatUrl(util.setProtocol(req.curUrl));
            const options = url.parse(req.curUrl);
            lookup(options.hostname, callback, allowDnsCache && !this.resolveDisable(req).dnsCache);
        };
        this.getHost = (req, pluginRulesMgr, rulesFileMgr, headerRulesMgr) => {
            const curUrl = formatUrl(util.setProtocol(req.curUrl));
            req.curUrl = curUrl;
            const filter = {};
            const filterHost = ignoreHost(req, this, filter) ||
                ignoreHost(req, pluginRulesMgr, filter) ||
                ignoreHost(req, rulesFileMgr, filter) ||
                ignoreHost(req, headerRulesMgr, filter);
            const vals = this._values;
            if (filterHost) {
                return;
            }
            let host;
            if (config.multiEnv) {
                host =
                    (pluginRulesMgr &&
                        getRule(req, pluginRulesMgr._rules.host, pluginRulesMgr._values)) ||
                        (headerRulesMgr && getRule(req, headerRulesMgr._rules.host, vals)) ||
                        getRule(req, this._rules.host, vals) ||
                        (rulesFileMgr &&
                            getRule(req, rulesFileMgr._rules.host, req._scriptValues));
            }
            else {
                host =
                    (pluginRulesMgr &&
                        getRule(req, pluginRulesMgr._rules.host, pluginRulesMgr._values)) ||
                        getRule(req, this._rules.host, vals) ||
                        (rulesFileMgr &&
                            getRule(req, rulesFileMgr._rules.host, req._scriptValues)) ||
                        (headerRulesMgr && getRule(req, headerRulesMgr._rules.host, vals));
            }
            if (!host || util.exactIgnore(filter, host)) {
                return;
            }
            const matcher = util.rule.getMatcher(host);
            if (matcher && PORT_RE.test(matcher)) {
                host.matcher = RegExp.$1 + (RegExp.$2 || RegExp.$3);
                host.port = host.port || RegExp.$4;
            }
            return host;
        };
        this.resolveFilter = (req) => {
            const filter = resolveProps(req, this._rules.filter, this._values);
            const ignore = resolveProps(req, this._rules.ignore, this._values, true);
            util.resolveFilter(ignore, filter);
            delete filter.filter;
            delete filter.ignore;
            delete filter['ignore|filter'];
            delete filter['ignore|ignore'];
            return filter;
        };
        this.resolveDisable = (req) => {
            return resolveProps(req, this._rules.disable, this._values);
        };
        this.resolveRules = (req) => {
            return resolveRules.call(this, req);
        };
        this.resolveReqRules = (req) => {
            return resolveRules.call(this, req, true);
        };
        this.resolveResRules = (req) => {
            return resolveRules.call(this, req, false, true);
        };
        this.resolveEnable = (req) => {
            return resolveProps(req, this._rules.enable, this._values);
        };
        this.resolveProxyProps = (req) => {
            if (req.curUrl === req.fullUrl) {
                return;
            }
            let enable = getRuleList(req, this._rules.enable, this._values, true);
            let disable = getRuleList(req, this._rules.disable, this._values, true);
            if (!enable.length && !disable.length) {
                return;
            }
            mergeRule(req.rules, enable, 'enable');
            mergeRule(req.rules, disable, 'disable');
            enable = util.resolveProperties(enable);
            disable = util.resolveProperties(disable);
            if (disable.clientId || disable.clientID || disable.clientid) {
                req.disable.clientId = true;
            }
            if (enable.clientId || enable.clientID || enable.clientid) {
                req.enable.clientId = true;
            }
            if (enable.multiClient) {
                req.enable.multiClient = true;
            }
            if (enable.singleClient) {
                req.enable.singleClient = true;
            }
            if (disable.multiClient) {
                req.disable.multiClient = true;
            }
            return {
                enable: enable,
                disable: disable
            };
        };
        this.resolvePipe = (req) => {
            return req.isPluginReq ? null : resolveSingleRule.call(this, req, 'pipe');
        };
        this.resolvePac = (req) => {
            return resolveSingleRule.call(this, req, 'pac');
        };
        this.resolveRule = (req) => {
            return resolveSingleRule.call(this, req, 'rule');
        };
        this.resolveInternalHost = (req) => {
            const list = resolveSingleRule.call(this, req, 'reqHeaders', true);
            if (list) {
                for (let i = 0, len = list.length; i < len; i++) {
                    const item = list[i];
                    if (WHISTLE_INTERNAL_HOST.test(item.matcher)) {
                        return RegExp.$1;
                    }
                }
            }
            return undefined;
        };
        this.hasReqScript = (req) => {
            return req.isPluginReq
                ? null
                : getRule(req, this._rules.rulesFile, this._values);
        };
        this.resolveProxy = (req, host) => {
            const proxy = getRule(req, this._rules.proxy, this._values, undefined, undefined, host);
            const matcher = proxy && proxy.matcher;
            const name = matcher && matcher.substring(0, matcher.indexOf(':'));
            const filter = this.resolveFilter(req);
            if (!proxy) {
                return proxy;
            }
            if (util.exactIgnore(filter, proxy)) {
                return;
            }
            if (filter['ignore:' + name]) {
                return proxy;
            }
            if (util.isIgnored(filter, 'proxy')) {
                return;
            }
            if (matcher[0] === 'x' && util.isIgnored(filter, 'xproxy')) {
                return;
            }
            if (matcher.indexOf(name + '://') === 0 && util.isIgnored(filter, name)) {
                return;
            }
            return proxy;
        };
        this.resolveSNICallback = (req) => {
            return resolveSingleRule.call(this, req, 'sniCallback');
        };
        this.resolveLocalRule = (req) => {
            return getRule(req, this._rules._localRule);
        };
        this.resolveClientCert = (req) => {
            return getRule(req, this._rules._clientCerts);
        };
        this.resolveBodyFilter = (req) => {
            return req.isPluginReq
                ? null
                : getRule(req, req._bodyFilters || this._rules._bodyFilters, null, undefined, true);
        };
        this._rules = protoMgr.getRules();
        this._globalPluginVars = {};
        this._sniCallback = [];
        this._orgValues = this._values = values || {};
    }
}
Rules.disableDnsCache = () => {
    allowDnsCache = false;
};
