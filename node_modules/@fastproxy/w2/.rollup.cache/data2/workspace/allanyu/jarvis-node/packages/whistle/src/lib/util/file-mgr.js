import fs from 'fs';
import iconv from 'iconv-lite';
import { Buffer } from 'safe-buffer';
import config from '../config';
import isUtf8 from './is-utf8';
const UTF8_RE = /^utf-?8$/i;
const isWin32 = process.platform === 'win32';
const MAX_SIZE = 1024 * 1024 * 64;
const LOCAL_FILE_PATH_RE = /^(\/*\$(?:whistle|w2)\/)/i;
const CRLF = Buffer.from('\r\n');
const RSLASH_RE = /\\/g;
const noop = function (_) {
    return _;
};
export function toBuffer(buf, charset) {
    if (buf == null || Buffer.isBuffer(buf)) {
        return buf;
    }
    buf += '';
    if (charset && typeof charset === 'string' && !UTF8_RE.test(charset)) {
        try {
            charset = charset.toLowerCase();
            if (charset === 'base64') {
                return Buffer.from(buf, 'base64');
            }
            return iconv.encode(buf, charset);
        }
        catch (e) { }
    }
    return Buffer.from(buf);
}
export function convertSlash(filePath) {
    if (LOCAL_FILE_PATH_RE.test(filePath)) {
        filePath = config.LOCAL_FILES + '/' + filePath.substring(RegExp.$1.length);
    }
    else {
        filePath = config.getHomePath(filePath);
    }
    return isWin32 ? filePath : filePath.replace(RSLASH_RE, '/');
}
export function decode(buf) {
    if (!Buffer.isBuffer(buf)) {
        return buf ? String(buf) : '';
    }
    if (!isUtf8(buf)) {
        try {
            return iconv.decode(buf, 'GB18030');
        }
        catch (e) { }
    }
    return String(buf);
}
function isString(path) {
    return path && typeof path === 'string';
}
function readSingleFile(path, callback) {
    if (!isString(path)) {
        return callback();
    }
    const stream = fs.createReadStream(convertSlash(path));
    let done;
    let buf;
    const execCallback = function (err) {
        if (done) {
            return;
        }
        done = true;
        stream.close();
        callback(err ? null : buf);
    };
    stream.on('data', function (data) {
        if (done) {
            return;
        }
        buf = buf ? Buffer.concat([buf, data]) : data;
        if (buf.length > MAX_SIZE) {
            execCallback();
        }
    });
    stream.on('error', execCallback);
    stream.on('end', execCallback);
}
function getFileMap(list) {
    if (Array.isArray(list)) {
        list = list.join('|');
    }
    if (!isString(list)) {
        return undefined;
    }
    const fileMap = {};
    list = list.split('|');
    list.forEach(function (file) {
        fileMap[file || ''] = 1;
    });
    return fileMap;
}
function readFileMap(list, callback, isText) {
    const fileMap = getFileMap(list);
    if (fileMap === undefined) {
        return callback('');
    }
    const files = Object.keys(fileMap);
    let len = files.length;
    files.forEach(function (file) {
        readSingleFile(file, function (data) {
            fileMap[file || ''] = isText ? decode(data) : data;
            if (--len <= 0) {
                callback(fileMap);
            }
        });
    });
}
export function joinData(list, isText, charset) {
    if (!list || !list.length) {
        return '';
    }
    if (isText) {
        return list.filter(noop).join('\r\n');
    }
    const result = [];
    list.forEach(function (buf) {
        if (buf) {
            buf = toBuffer(buf, charset);
            result.push(buf, CRLF);
        }
    });
    result.pop();
    return result.length ? Buffer.concat(result) : '';
}
function readFileFromMap(path, fileMap, isText) {
    if (!isString(path)) {
        return '';
    }
    path = path.split('|');
    return joinData(path.map(function (file) {
        return fileMap[file || ''];
    }), isText);
}
export function readFileList(list, callback, isText) {
    readFileMap(list, function (fileMap) {
        if (!fileMap) {
            return callback('');
        }
        const result = [];
        list.forEach(function (file) {
            result.push(readFileFromMap(file, fileMap, isText));
        });
        callback(result);
    }, isText);
}
export function readFile(path, callback) {
    if (!isString(path)) {
        return callback();
    }
    readFileList(path.split('|'), function (result) {
        callback(joinData(result));
    });
}
export function readFilesText(list, callback) {
    readFileList(list, callback, true);
}
export function readFileText(path, callback) {
    if (!isString(path)) {
        return callback();
    }
    readFilesText(path.split('|'), function (result) {
        callback(joinData(result, true));
    });
}
