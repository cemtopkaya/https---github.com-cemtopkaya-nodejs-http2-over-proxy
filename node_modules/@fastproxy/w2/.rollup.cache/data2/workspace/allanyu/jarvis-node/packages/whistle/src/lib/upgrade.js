import { Buffer, hparser, net } from './import-pkg';
import { handleWebsocket } from './https';
import { pluginMgr } from './plugins';
import * as util from './util';
import config from './config';
const formatHeaders = hparser.formatHeaders;
const getRawHeaderNames = hparser.getRawHeaderNames;
const getRawHeaders = hparser.getRawHeaders;
const WS_RE = /\bwebsocket\b/i;
const PLUGIN_PATH_RE = /^\/(\.\.\.whistle-path\.5b6af7b9884e1165\.\.\.\/\/\/)?(whistle|plugin)\.([^/?#]+)\/?/;
function getPluginNameByReq(req, callback) {
    if (!req) {
        return callback();
    }
    let host = req.headers.host;
    const index = host.indexOf(':');
    let port = req.isHttps ? 443 : 80;
    if (index !== -1) {
        port = host.substring(index + 1);
        host = host.substring(0, index);
    }
    const isUIPort = port == config.port || port == config.uiport;
    let isWebUI = isUIPort && util.isLocalHost(host);
    if (!isWebUI && (isWebUI = config.isWebUIHost(host)) && net.isIP(host)) {
        isWebUI = isUIPort;
    }
    let pluginName;
    let isPluginUrl;
    let internalPath;
    if (!config.pureProxy && PLUGIN_PATH_RE.test(req.url)) {
        internalPath = RegExp['$&'];
        req.isInternalUrl = !!RegExp.$1;
        isPluginUrl = RegExp.$2 === 'plugin';
        pluginName = RegExp.$3;
    }
    else if (!isWebUI) {
        pluginName =
            (isUIPort || !net.isIP(host)) && config.getPluginNameByHost(host);
    }
    if (!pluginName) {
        return callback();
    }
    const plugin = isPluginUrl
        ? pluginMgr.getPluginByName(pluginName)
        : pluginMgr.getPlugin(pluginName + ':');
    if (!isWebUI && !plugin) {
        return callback();
    }
    if (internalPath) {
        req.url = '/' + req.url.substring(internalPath.length);
    }
    pluginMgr.loadPlugin(plugin, function (err, ports) {
        const uiPort = ports && ports.uiPort;
        if (err || !uiPort) {
            const msg = [
                'HTTP/1.1',
                err ? 500 : 404,
                err ? 'Internal Server Error' : 'Not Found'
            ].join(' ');
            err = err ? '<pre>' + err + '</pre>' : 'Not Found';
            const length = Buffer.byteLength(err);
            err = [
                msg,
                'Content-Type: text/html; charset=utf8',
                'Content-Length: ' + length,
                '\r\n',
                err
            ].join('\r\n');
        }
        callback(err, uiPort);
    });
}
function upgradeHandler(req, socket) {
    ++util.proc.allWsRequests;
    ++util.proc.totalAllWsRequests;
    let done;
    let reqDestroyed;
    let resDestroyed;
    let resSocket;
    function destroy(err) {
        if (resSocket) {
            if (!resDestroyed) {
                resDestroyed = true;
                resSocket.destroy(err);
            }
        }
        else if (!reqDestroyed) {
            reqDestroyed = true;
            socket.destroy(err);
        }
        if (socket.isLogRequests) {
            --util.proc.wsRequests;
        }
        socket.isLogRequests = false;
        if (!done) {
            done = true;
            --util.proc.allWsRequests;
        }
    }
    const headers = req.headers;
    util.onSocketEnd(socket, destroy);
    util.addTunnelData(socket, headers);
    socket._clientId = util.getComposerClientId(headers);
    const getBuffer = function (method, newHeaders, path) {
        const rawData = [
            (method || 'GET') +
                ' ' +
                (path || socket.url || req.url) +
                ' ' +
                'HTTP/1.1'
        ];
        newHeaders = formatHeaders(newHeaders || headers, req.rawHeaders);
        rawData.push(getRawHeaders(newHeaders));
        return Buffer.from(rawData.join('\r\n') + '\r\n\r\n');
    };
    const sniPlugin = headers[config.SNI_PLUGIN_HEADER];
    if (sniPlugin) {
        socket.sniPlugin = req.sniPlugin = sniPlugin;
        delete headers[config.SNI_PLUGIN_HEADER];
    }
    req.isPluginReq = socket.isPluginReq = util.checkPluginReqOnce(req);
    util.handleForwardedProps(req);
    const isHttps = socket.isHttps || req.isHttps || !!headers[config.HTTPS_FIELD];
    req.isHttps = socket.isHttps = isHttps;
    // format headers
    req.isWs = true;
    socket.fullUrl = util.getFullUrl(req);
    socket._fwdHost = req._fwdHost;
    const isWs = WS_RE.test(headers.upgrade);
    getPluginNameByReq(isWs ? req : null, function (err, uiPort) {
        if (err) {
            return socket.write(err);
        }
        let clientIp;
        let clientPort;
        if (isWs) {
            const clientInfo = util.parseClientInfo(req);
            clientIp = clientInfo[0] || util.getClientIp(req);
            clientPort = clientInfo[1] || util.getClientPort(req);
            socket._remoteAddr = clientInfo[2] || util.getRemoteAddr(req);
            socket._remotePort = clientInfo[3] || util.getRemotePort(req);
            delete headers[config.CLIENT_PORT_HEAD];
        }
        // 其它协议直接转成普通https请求，方便抓包调试
        // 如果是插件的websocket请求，直接转插件
        if (!isWs || uiPort) {
            if (!isWs) {
                delete headers.upgrade;
                delete headers['http2-settings'];
                headers.connection = 'keep-alive';
            }
            else {
                req.method = 'GET';
                headers[config.CLIENT_IP_HEAD] = clientIp;
                headers[config.CLIENT_PORT_HEAD] = clientPort;
                headers['x-whistle-remote-address'] = socket._remoteAddr;
                headers['x-whistle-remote-port'] = socket._remotePort;
                headers[config.PLUGIN_HOOK_NAME_HEADER] = config.PLUGIN_HOOKS.UI;
            }
            socket.pause();
            util.connect({
                port: uiPort || config.port,
                localhost: '127.0.0.1'
            }, function (err, s) {
                resSocket = s;
                if (err || socket._hasError) {
                    return destroy(err);
                }
                resSocket.on('error', destroy);
                resSocket.write(getBuffer(req.method));
                socket.pipe(resSocket).pipe(socket);
                socket.resume();
            });
            return;
        }
        // 不能放到上面，否则转发后的协议将丢失
        delete headers[config.HTTPS_FIELD];
        socket.rawHeaderNames = getRawHeaderNames(req.rawHeaders);
        socket.headers = headers;
        socket.url = req.url;
        socket.fromTunnel = req.fromTunnel;
        socket.fromComposer = req.fromComposer;
        socket.enableXFF = req.enableXFF;
        socket.isInternalUrl = req.isInternalUrl;
        delete socket.headers[config.CLIENT_PORT_HEAD];
        socket.getBuffer = function (newHeaders, path) {
            return getBuffer(null, newHeaders, path);
        };
        handleWebsocket(socket, clientIp, clientPort);
    });
}
export default function (server) {
    server.on('upgrade', upgradeHandler);
}
