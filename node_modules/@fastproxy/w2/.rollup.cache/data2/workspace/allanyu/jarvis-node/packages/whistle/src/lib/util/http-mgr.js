import http from 'http';
import https from 'https';
import fs from 'fs';
import extend from 'extend';
import { convertSlash } from './file-mgr';
import logger from './logger';
import parseUrl from './parse-url';
import * as zlib from './zlib';
let cache = {};
const listeners = [];
let newUrls;
const TIMEOUT = 16000;
const MAX_RULES_LEN = 1024 * 72;
const MAX_FILE_LEN = 1024 * 256;
const MAX_INTERVAL = 1000 * 30;
const MIN_INTERVAL = 1000 * 10;
const EXCEED = 'EXCEED';
const OPTIONS = { encoding: 'utf8' };
const queue = [];
let queueTimer;
const FILE_RE = /^(?:[a-z]:[\\/]|[~ï½ž]?\/)/i;
const GZIP_RE = /gzip/i;
let pendingList = process.whistleStarted ? null : [];
let pluginMgr;
process.once('whistleStarted', function () {
    if (pendingList) {
        pendingList.forEach(function (item) {
            cacheAdd(item[0], item[1], item[2]);
        });
        pendingList = null;
    }
});
function getInterval(time, isLocal) {
    const len = Object.keys(cache).length || 1;
    const interval = isLocal
        ? 5000
        : Math.max(MIN_INTERVAL, Math.ceil(MAX_INTERVAL / len));
    const minTime = interval - (time > 0 ? time : 0);
    return Math.max(minTime, 1000);
}
function triggerChange(data, body) {
    if (data) {
        body = (body && body.trim()) || '';
        if (data.body === body) {
            return;
        }
        data.body = body;
    }
    if (newUrls) {
        return;
    }
    newUrls = {};
    listeners.forEach(function (l) {
        l();
    });
    Object.keys(newUrls).forEach(function (url) {
        newUrls[url] = cache[url];
    });
    cache = newUrls;
    newUrls = null;
}
function parseOptions(options) {
    if (typeof options === 'string') {
        options = parseUrl(options);
    }
    else {
        const fullUrl = options.url || options.uri;
        if (fullUrl && typeof fullUrl === 'string') {
            options = extend(options, parseUrl(fullUrl));
        }
    }
    const maxLength = options.maxLength;
    if (!(maxLength > 0)) {
        options.maxLength = 0;
    }
    options.agent = false;
    if (options.rejectUnauthorized !== true) {
        options.rejectUnauthorized = false;
    }
    if (options.headers && options.headers.trailer) {
        delete options.headers.trailer;
    }
    return options;
}
function toString(obj) {
    if (obj == null) {
        return;
    }
    if (typeof obj === 'object') {
        return JSON.stringify(obj);
    }
    if (Buffer.isBuffer(obj)) {
        return obj;
    }
    return obj + '';
}
const NOT_PLUGIN_ERR = new Error('Error: not found');
const NOT_UI_SERVER_ERR = new Error('Error: not implemented uiServer');
NOT_PLUGIN_ERR.code = 404;
NOT_UI_SERVER_ERR.code = 501;
function loadPlugin(options, callback) {
    const name = options.pluginName;
    if (!name) {
        return callback();
    }
    pluginMgr.loadPluginByName(name, function (err, ports) {
        if (err || !ports || !ports.uiPort) {
            return callback(err || (ports ? NOT_UI_SERVER_ERR : NOT_PLUGIN_ERR));
        }
        options.url =
            'http://127.0.0.1:' + ports.uiPort + options.url.substring(name.length);
        callback();
    });
}
export function request(options, callback) {
    loadPlugin(options, function (err) {
        if (err) {
            return callback(err, '', '');
        }
        options = parseOptions(options);
        const isHttps = options.protocol === 'https:';
        const httpModule = isHttps ? https : http;
        let done;
        let timer;
        let res;
        let body = '';
        let client;
        const callbackHandler = function (err) {
            clearTimeout(timer);
            err && client && client.abort();
            if (!done) {
                done = true;
                const handleCallback = function (e, data) {
                    data = e ? '' : options.needRawData ? data : data + '';
                    callback(e, data, res || '');
                };
                if (res && body && GZIP_RE.test(res.headers['content-encoding'])) {
                    zlib.gunzip(body, handleCallback);
                }
                else {
                    handleCallback(err, body);
                }
            }
        };
        const addTimeout = function () {
            clearTimeout(timer);
            timer = setTimeout(function () {
                callbackHandler(new Error('Timeout'));
            }, TIMEOUT);
        };
        addTimeout();
        const maxLength = options.maxLength;
        try {
            client = httpModule.request(options, function (r) {
                res = r;
                res.on('error', callbackHandler);
                res.on('data', function (data) {
                    body = body ? Buffer.concat([body, data]) : data;
                    addTimeout();
                    if (maxLength && body.length > maxLength) {
                        let err = undefined;
                        if (!options.ignoreExceedError) {
                            err = new Error('The response body exceeded length limit');
                            err.code = EXCEED;
                        }
                        callbackHandler(err);
                    }
                });
                res.on('end', callbackHandler);
            });
            client.on('error', callbackHandler);
            client.end(toString(options.body));
            return client;
        }
        catch (e) {
            callbackHandler(e);
        }
    });
}
function readFile(url, callback) {
    let data;
    const now = Date.now();
    const execCallback = function () {
        callback(url, Date.now() - now);
    };
    const filePath = convertSlash(url);
    fs.stat(filePath, function (err, stat) {
        data = cache[url];
        if (!data) {
            return execCallback();
        }
        if (err) {
            if (err.code === 'ENOENT') {
                err = null;
            }
            else {
                logger.error(url, err.message);
            }
            triggerChange(data);
            data.mtime = null;
            return execCallback();
        }
        if (!stat.isFile()) {
            triggerChange(data);
            data.mtime = null;
            return execCallback();
        }
        const time = stat.mtime.getTime();
        if (time === data.mtime) {
            return execCallback();
        }
        const stream = fs.createReadStream(filePath, OPTIONS);
        let done;
        let body = '';
        const listener = function (err) {
            if (done) {
                return;
            }
            execCallback();
            if (err && err.code !== 'ENOENT') {
                return;
            }
            done = true;
            data.mtime = time;
            stream.close();
            triggerChange(data, body);
        };
        stream.on('data', function (text) {
            if (done) {
                return;
            }
            body += text;
            if (body.length > MAX_FILE_LEN) {
                listener();
            }
        });
        stream.on('error', listener);
        stream.on('end', listener);
    });
}
function addQueue(url, consumeTime) {
    if (cache[url] && queue.indexOf(url) === -1) {
        queue.push(url);
    }
    let data;
    while (!queueTimer && !data) {
        url = queue.shift();
        if (!url) {
            return;
        }
        data = cache[url];
        if (data) {
            queueTimer = setTimeout(function () {
                queueTimer = null;
                updateBody(url, addQueue);
            }, getInterval(consumeTime, data.isLocalUrl || data.isLocalPath));
            return;
        }
    }
}
function updateBody(url, callback, init) {
    let data = cache[url];
    if (!data) {
        return callback && callback();
    }
    if (data.isLocalPath) {
        return readFile(url, addQueue);
    }
    const now = Date.now();
    const options = {
        url: url,
        pluginName: data.pluginName,
        maxLength: MAX_RULES_LEN,
        ignoreExceedError: true
    };
    if (data.headers) {
        options.headers = data.headers;
    }
    request(options, function (err, body, res) {
        data = cache[url];
        callback && callback(url, Date.now() - now);
        if (!data) {
            return;
        }
        const code = res.statusCode;
        let notFound = err
            ? err.code === 'ENOTFOUND' || err.code === 'ECONNREFUSED'
            : code != 200 && code != 204;
        err && logger.error('[Load Rules]', url, err.message || err);
        if (notFound) {
            data._retry = data._retry || 0;
            if (data._retry > 2) {
                !err && logger.warn('[Load Rules]', url, 'status', code);
                data._retry = -6;
                err = body = '';
                notFound = false;
            }
            ++data._retry;
        }
        else {
            data._retry = 0;
        }
        if (notFound || err) {
            if (init) {
                updateBody(url);
                return;
            }
        }
        addQueue(url);
        if (notFound || err) {
            return;
        }
        triggerChange(data, body);
    });
    return true;
}
export const addChangeListener = function (l) {
    listeners.push(l);
};
function cacheAdd(url, headers, pluginName) {
    let data = cache[url];
    if (!data) {
        cache[url] = data = {
            body: '',
            pluginName: pluginName,
            isLocalUrl: pluginName || url.indexOf('http://127.0.0.1:') === 0,
            isLocalPath: FILE_RE.test(url),
            headers: headers
        };
        updateBody(url, undefined, true);
    }
    if (newUrls) {
        newUrls[url] = 1;
    }
    return data.body;
}
export const add = function (url, headers, pluginName) {
    if (pendingList && headers && headers['x-whistle-internal-id']) {
        pendingList.push([url, headers, pluginName]);
        return '';
    }
    return cacheAdd(url, headers, pluginName);
};
export const forceUpdate = function (root) {
    Object.keys(cache).forEach(function (url) {
        if (url.indexOf(root) === 0) {
            updateBody(url);
        }
    });
};
export const clean = function () {
    if (!newUrls && Object.keys(cache).length) {
        triggerChange();
    }
};
export const setPluginMgr = function (mgr) {
    pluginMgr = mgr;
};
