import { PassThrough } from 'stream';
import wsParser from 'ws-parser';
import { Buffer } from 'safe-buffer';
import { pluginMgr } from './plugins';
import config from './config';
import { getCharset, listenerCount, onSocketEnd, toBuffer } from './util';
let pendingReqList = [];
const INTERVAL = 22 * 1000;
let proxy;
let index = 0;
const MAX_PAYLOAD = 1024 * 1024;
const conns = {};
const PING = Buffer.from('iQA=', 'base64');
const PONG = Buffer.from('ioAn6ubf', 'base64');
const PAUSE_STATUS = 1;
const IGNORE_STATUS = 2;
const MAX_COMPOSE_FRAME_COUNT = 5;
function getFrameId() {
    ++index;
    if (index > 999) {
        index = 0;
    }
    if (index > 99) {
        return Date.now() + '-' + index;
    }
    if (index > 9) {
        return Date.now() + '-0' + index;
    }
    return Date.now() + '-00' + index;
}
export default function (p) {
    proxy = p;
}
function handleSocketEnd(req, res, callback) {
    onSocketEnd(req, callback);
    onSocketEnd(res, callback);
}
function handleClose(req, res, justTunnel) {
    handleSocketEnd(req, res, function (err) {
        const ctx = conns[req.reqId];
        ctx && ctx.clearup();
        const closed = req._hasClosed;
        req._hasClosed = true;
        // 确保两个连接都关掉才行
        if (closed) {
            req.emit('_closed');
        }
        if (req.customParser) {
            !closed && removePending(req.reqId);
            return;
        }
        if (closed && !justTunnel) {
            req._emittedClosed = true;
            proxy.emit('frame', {
                reqId: req.reqId,
                frameId: getFrameId(),
                closed: true,
                code: req._errorCode || res._errorCode,
                err: err && err.message
            });
        }
    });
}
function getStatusFn(ctx, status, name) {
    status = parseInt(status, 10);
    name = name || 'receiveStatus';
    const oldStatus = ctx[name] || 0;
    status = ctx[name] = status > 0 || status < 3 ? status : 0;
    return status !== oldStatus ? status : -1;
}
function setConnStatus(ctx, status, statusObj, name) {
    statusObj.pause = statusObj.ignore = undefined;
    status = getStatusFn(ctx, status, name);
    if (status === 1) {
        statusObj.pause = true;
        return;
    }
    if (status === 2) {
        statusObj.ignore = true;
        statusObj.chunk = null;
        statusObj.ignoring = !!statusObj.callback;
    }
    statusObj.emitData && statusObj.emitData();
    if (statusObj.callback) {
        statusObj.addToReceiver && statusObj.addToReceiver();
        statusObj.callback(null, statusObj.chunk);
        statusObj.addToReceiver = null;
        statusObj.callback = null;
        statusObj.chunk = null;
    }
}
function initStatus(ctx, enable) {
    if (enable.pauseSend) {
        ctx.setSendStatus(PAUSE_STATUS);
    }
    else if (enable.ignoreSend) {
        ctx.setSendStatus(IGNORE_STATUS);
    }
    if (enable.pauseReceive) {
        ctx.setReceiveStatus(PAUSE_STATUS);
    }
    else if (enable.ignoreReceive) {
        ctx.setReceiveStatus(IGNORE_STATUS);
    }
}
function removePendingFn(reqId) {
    const index = pendingReqList.indexOf(reqId);
    if (index !== -1) {
        pendingReqList.splice(index, 1);
    }
}
function pipeStream(src, target, useSrc) {
    if (!src || !target) {
        return src || target;
    }
    src.pipe(target);
    return useSrc ? src : target;
}
function isHide(req) {
    return !config.captureData || (req._filters.hide && !req.disable.hide);
}
function emitDataToProxy(req, chunk, fromClient, ignore) {
    if (isHide(req) || req._emittedClosed) {
        return;
    }
    proxy.emit('frame', {
        reqId: req.reqId,
        frameId: getFrameId(),
        isClient: fromClient,
        length: chunk.length,
        ignore: ignore,
        bin: chunk
    });
}
function handleConnSend(ctx, reqTrans, sendStatus) {
    const req = ctx.req;
    const res = ctx.res;
    const hasEvent = ctx.hasEvent;
    const writer = res.pipeWriter || res;
    const url = ctx.url;
    ctx.sendToServer = function (data) {
        data = data.data;
        writer.write(data);
        emitDataToProxy(req, data, true);
    };
    sendStatus.emitData = function () {
        if (sendStatus.chunk) {
            emitDataToProxy(req, sendStatus.chunk, true, sendStatus.ignore);
            sendStatus.chunk = null;
        }
    };
    reqTrans._transform = function (chunk, _, cb) {
        hasEvent && proxy.emit('tunnelRequest', url);
        if (sendStatus.pause) {
            sendStatus.chunk = chunk;
            sendStatus.callback = cb;
            return;
        }
        emitDataToProxy(req, chunk, true, sendStatus.ignore);
        if (sendStatus.ignore) {
            chunk = null;
        }
        cb(null, chunk);
    };
}
function handleConnReceive(ctx, resTrans, receiveStatus) {
    const req = ctx.req;
    const hasEvent = ctx.hasEvent;
    const url = ctx.url;
    const writer = req.pipeWriter || req;
    ctx.sendToClient = function (data) {
        data = data.data;
        writer.write(data);
        emitDataToProxy(req, data);
    };
    receiveStatus.emitData = function () {
        if (receiveStatus.chunk) {
            emitDataToProxy(req, receiveStatus.chunk, undefined, receiveStatus.ignore);
            receiveStatus.chunk = null;
        }
    };
    resTrans._transform = function (chunk, _, cb) {
        hasEvent && proxy.emit('tunnelRequest', url);
        if (receiveStatus.pause) {
            receiveStatus.chunk = chunk;
            receiveStatus.callback = cb;
            return;
        }
        emitDataToProxy(req, chunk, undefined, receiveStatus.ignore);
        if (receiveStatus.ignore) {
            chunk = null;
        }
        cb(null, chunk);
    };
}
function clearupStatus(conns, reqId, sendStatus, receiveStatus) {
    delete conns[reqId];
    sendStatus.callback = null;
    receiveStatus.callback = null;
    sendStatus.addToReceiver = null;
    receiveStatus.addToReceiver = null;
    clearInterval(sendStatus.timer);
    clearInterval(receiveStatus.timer);
}
function getBinary(data, len) {
    return len > MAX_PAYLOAD ? data.slice(0, MAX_PAYLOAD) : data;
}
function drainData(status, socket, receiver, toServer) {
    if (!status.sender) {
        try {
            status.sender = wsParser.getSender(socket.pipeWriter || socket, toServer);
        }
        catch (e) { }
    }
    status.sender &&
        status.data.forEach(function (item) {
            status.sender.send(item.data, item);
            receiver.onData(item.data, item);
        });
    status.data = [];
    receiver.ping();
}
function handleFrame(receiver, socket, status, chunk, cb, toServer) {
    if (!receiver.existsCacheData) {
        status.ignoring = status.ignore;
        if (status.pause) {
            status.callback = cb;
            status.chunk = chunk;
            status.addToReceiver = function () {
                receiver.add(chunk);
            };
            drainData(status, socket, receiver, toServer);
            return;
        }
        if (status.ignore) {
            drainData(status, socket, receiver, toServer);
        }
    }
    const toRead = receiver.add(chunk);
    if (status.ignoring) {
        if (!status.ignore && toRead >= 0) {
            status.ignoring = false;
            socket.write(chunk.slice(toRead));
        }
        chunk = null;
    }
    else if (toRead >= 0 &&
        (status.pause || status.ignore || status.data.length)) {
        if (toRead) {
            const readAll = toRead === chunk.length;
            status.chunk = readAll ? null : chunk.slice(toRead);
            socket.write(readAll ? chunk : chunk.slice(0, toRead));
        }
        else {
            status.chunk = chunk;
        }
        if (status.pause) {
            status.callback = cb;
            drainData(status, socket, receiver, toServer);
            return;
        }
        if (status.ignore) {
            status.ignoring = true;
            chunk = null;
            drainData(status, socket, receiver, toServer);
        }
    }
    if (chunk && status.timer) {
        clearInterval(status.timer);
        status.timer = null;
    }
    cb(null, chunk);
}
function clearTimer(status) {
    if (!status.ignore && !status.pause) {
        clearInterval(status.timer);
        status.timer = null;
    }
}
function handleWsSend(ctx, reqTrans, sendStatus, isTunnel) {
    const req = ctx.req;
    const res = ctx.res;
    const url = ctx.url;
    let hideWs = isHide(req);
    let reqReceiver;
    if (!hideWs) {
        try {
            reqReceiver = wsParser.getReceiver(res);
        }
        catch (e) {
            hideWs = true;
        }
    }
    const eventName = isTunnel ? 'tunnelRequest' : 'wsRequest';
    const hasEvent = ctx.hasEvent;
    if (hideWs) {
        if (hasEvent) {
            reqTrans._transform = function (chunk, _, cb) {
                proxy.emit(eventName, url);
                cb(null, chunk);
            };
        }
        return;
    }
    const reqId = req.reqId;
    onSocketEnd(res, function () {
        reqReceiver.flush(function () {
            reqReceiver.cleanup();
        });
    });
    ctx.sendToServer = function (data) {
        if (sendStatus.data.length > MAX_COMPOSE_FRAME_COUNT) {
            return false;
        }
        sendStatus.data.push(data);
        if (sendStatus.ignoring ||
            sendStatus.callback ||
            !reqReceiver.existsCacheData) {
            drainData(sendStatus, res, reqReceiver, true);
        }
        return true;
    };
    reqReceiver.ping = function () {
        if (isTunnel || sendStatus.timer || req.disable.pong) {
            return;
        }
        res.write(PONG);
        sendStatus.timer = setInterval(function () {
            res.write(PONG);
            clearTimer(sendStatus);
        }, INTERVAL);
    };
    reqReceiver.onclose = function (code) {
        ctx.req._errorCode = code;
    };
    reqReceiver.onData = function (data, opts) {
        let opcode = opts.opcode;
        if (!opcode) {
            opcode = opts.binary ? 2 : 1;
        }
        proxy.emit('frame', {
            reqId: reqId,
            frameId: getFrameId(),
            isClient: true,
            mask: isTunnel ? undefined : opts.mask,
            ignore: opts.data ? undefined : sendStatus.ignoring,
            bin: getBinary(data, opts.length),
            compressed: isTunnel ? undefined : opts.compressed,
            length: opts.length,
            opcode: isTunnel ? undefined : opcode
        });
    };
    reqReceiver.onerror = function (err) {
        if (req._emittedClosed) {
            return;
        }
        req._emittedClosed = true;
        proxy.emit('frame', {
            reqId: reqId,
            frameId: getFrameId(),
            isClient: true,
            err: err.message,
            bin: ''
        });
    };
    reqTrans._transform = function (chunk, _, cb) {
        hasEvent && proxy.emit(eventName, url);
        handleFrame(reqReceiver, res, sendStatus, chunk, cb, true);
    };
}
function handleWsReceive(ctx, resTrans, receiveStatus, isTunnel) {
    const req = ctx.req;
    const res = ctx.res;
    const url = ctx.url;
    let hideWs = isHide(req);
    let resReceiver;
    if (!hideWs) {
        try {
            resReceiver = wsParser.getReceiver(res, true);
        }
        catch (e) {
            hideWs = true;
        }
    }
    const eventName = isTunnel ? 'tunnelRequest' : 'wsRequest';
    const hasEvent = ctx.hasEvent;
    if (hideWs) {
        if (hasEvent) {
            resTrans._transform = function (chunk, _, cb) {
                proxy.emit(eventName, url);
                cb(null, chunk);
            };
        }
        return;
    }
    const reqId = req.reqId;
    onSocketEnd(req, function () {
        resReceiver.flush(function () {
            resReceiver.cleanup();
        });
    });
    ctx.sendToClient = function (data) {
        if (receiveStatus.data.length > MAX_COMPOSE_FRAME_COUNT) {
            return false;
        }
        receiveStatus.data.push(data);
        if (receiveStatus.ignoring ||
            receiveStatus.callback ||
            !resReceiver.existsCacheData) {
            drainData(receiveStatus, req, resReceiver);
        }
        return true;
    };
    resReceiver.ping = function () {
        if (isTunnel || receiveStatus.timer || req.disable.ping) {
            return;
        }
        req.write(PING);
        receiveStatus.timer = setInterval(function () {
            req.write(PING);
            clearTimer(receiveStatus);
        }, INTERVAL);
    };
    resReceiver.onclose = function (code) {
        ctx.res._errorCode = code;
    };
    resReceiver.onData = function (data, opts) {
        let opcode = opts.opcode;
        if (!opcode) {
            opcode = opts.binary ? 2 : 1;
        }
        proxy.emit('frame', {
            reqId: reqId,
            frameId: getFrameId(),
            bin: getBinary(data, opts.length),
            mask: isTunnel ? undefined : opts.mask,
            ignore: opts.data ? undefined : receiveStatus.ignoring,
            compressed: isTunnel ? undefined : opts.compressed,
            length: opts.length,
            opcode: isTunnel ? undefined : opcode
        });
    };
    resReceiver.onerror = function (err) {
        if (req._emittedClosed) {
            return;
        }
        req._emittedClosed = true;
        proxy.emit('frame', {
            reqId: reqId,
            frameId: getFrameId(),
            err: err.message,
            bin: ''
        });
    };
    resTrans._transform = function (chunk, _, cb) {
        hasEvent && proxy.emit(eventName, url);
        handleFrame(resReceiver, req, receiveStatus, chunk, cb);
    };
}
function getContext(req, res, hasEvent, sendStatus, receiveStatus) {
    const reqId = req.reqId;
    const ctx = (conns[reqId] = {
        customParser: req.customParser,
        req: req,
        res: res,
        hasEvent: hasEvent,
        url: req.fullUrl,
        charset: getCharset(res.headers['content-type']) || '',
        clearup: function () {
            clearupStatus(conns, reqId, sendStatus, receiveStatus);
        },
        setSendStatus: function (status) {
            setConnStatus(ctx, status, sendStatus, 'sendStatus');
        },
        setReceiveStatus: function (status) {
            setConnStatus(ctx, status, receiveStatus);
        }
    });
    initStatus(ctx, req.enable);
    return ctx;
}
export const setContext = getContext;
export const removeContext = function (req) {
    delete conns[req.reqId];
};
export const handleUpgrade = function (req, res) {
    if (req.isPluginReq) {
        handleClose(req, res, true);
        return req.pipe(res).pipe(req);
    }
    const url = req.fullUrl;
    const customParser = req.customParser;
    const reqId = req.reqId;
    const sendStatus = { data: [] };
    const receiveStatus = { data: [] };
    const emitError = function (err) {
        req.emit('error', err);
    };
    const reqTrans = new PassThrough();
    const resTrans = new PassThrough();
    reqTrans.on('error', emitError);
    resTrans.on('error', emitError);
    res.headers = res.headers || {};
    req.wsExts = res.headers['sec-websocket-extensions'] || '';
    handleClose(req, res);
    pluginMgr.getWsPipe(req, res, function (reqRead, reqWrite, resRead, resWrite) {
        customParser && removePendingFn(reqId);
        if (req._hasClosed) {
            return;
        }
        const hasEvent = listenerCount(proxy, 'wsRequest');
        const ctx = (conns[reqId] = getContext(req, res, hasEvent, sendStatus, receiveStatus));
        if (customParser) {
            const handleInspect = function (chunk, _, cb) {
                hasEvent && proxy.emit('wsRequest', url);
                cb(null, chunk);
            };
            reqTrans._transform = handleInspect;
            resTrans._transform = handleInspect;
        }
        else {
            if (reqWrite) {
                reqWrite.headers = res.headers;
                res.pipeWriter = reqWrite;
            }
            if (resWrite) {
                resWrite.headers = res.headers;
                req.pipeWriter = resWrite;
            }
            handleWsSend(ctx, reqTrans, sendStatus);
            handleWsReceive(ctx, resTrans, receiveStatus);
        }
        pipeStream(req, reqRead)
            .pipe(reqTrans)
            .pipe(pipeStream(reqWrite, res, true));
        pipeStream(res, resRead)
            .pipe(resTrans)
            .pipe(pipeStream(resWrite, req, true));
    });
};
export const handleConnect = function (req, res) {
    const hasEvent = listenerCount(proxy, 'tunnelRequest');
    const isConn = req.inspectFrames;
    if (req.isPluginReq || (!isConn && !hasEvent)) {
        handleClose(req, res, true);
        return req.pipe(res).pipe(req);
    }
    const url = req.fullUrl;
    const reqId = req.reqId;
    const customParser = req.customParser;
    const sendStatus = { data: [] };
    const receiveStatus = { data: [] };
    const reqTrans = new PassThrough();
    const resTrans = new PassThrough();
    let ctx;
    const emitError = function (err) {
        req.emit('error', err);
    };
    reqTrans.on('error', emitError);
    resTrans.on('error', emitError);
    res.headers = res.headers || req.headers;
    handleClose(req, res, !isConn);
    pluginMgr.getTunnelPipe(req, res, function (reqRead, reqWrite, resRead, resWrite) {
        customParser && removePendingFn(reqId);
        if (req._hasClosed) {
            return;
        }
        const hide = isHide(req);
        if (isConn && !hide) {
            ctx = getContext(req, res, hasEvent, sendStatus, receiveStatus);
        }
        if (customParser || hide || !isConn) {
            const handleInspect = function (chunk, _, cb) {
                hasEvent && proxy.emit('tunnelRequest', url);
                cb(null, chunk);
            };
            reqTrans._transform = handleInspect;
            resTrans._transform = handleInspect;
        }
        else {
            req.wsExts = res.wsExts = '';
            if (reqWrite) {
                reqWrite.wsExts = '';
                res.pipeWriter = reqWrite;
            }
            if (resWrite) {
                resWrite.wsExts = '';
                req.pipeWriter = resWrite;
            }
            if (reqRead && reqWrite) {
                ctx && handleWsSend(ctx, reqTrans, sendStatus, true);
            }
            else {
                ctx && handleConnSend(ctx, reqTrans, sendStatus);
            }
            if (resRead && resWrite) {
                ctx && handleWsReceive(ctx, resTrans, receiveStatus, true);
            }
            else {
                ctx && handleConnReceive(ctx, resTrans, receiveStatus);
            }
        }
        pipeStream(req, reqRead)
            .pipe(reqTrans)
            .pipe(pipeStream(reqWrite, res, true));
        pipeStream(res, resRead)
            .pipe(resTrans)
            .pipe(pipeStream(resWrite, req, true));
    });
};
export const abort = function (reqId) {
    const ctx = conns[reqId];
    if (!ctx) {
        return;
    }
    delete conns[reqId];
    ctx.req.destroy();
    ctx.res.destroy();
};
export const getStatus = function (reqId) {
    const ctx = reqId && conns[reqId];
    if (!ctx) {
        return;
    }
    return {
        sendStatus: ctx.sendStatus,
        receiveStatus: ctx.receiveStatus
    };
};
export const removePending = function (req) {
    removePendingFn(req.reqId);
};
export const setPending = function (req) {
    const reqId = req.customParser && req.reqId;
    if (reqId && pendingReqList.indexOf(reqId) === -1) {
        pendingReqList.push(reqId);
        if (pendingReqList.length > 2000) {
            pendingReqList = pendingReqList.slice(-1600);
        }
    }
};
export const exists = function (reqId) {
    return reqId && conns[reqId];
};
export const getData = function (reqId) {
    const ctx = reqId && conns[reqId];
    if (ctx) {
        const result = {
            sendStatus: ctx.sendStatus,
            receiveStatus: ctx.receiveStatus,
            toServer: ctx.toServerData,
            toClient: ctx.toClientData
        };
        delete ctx.toServerData;
        delete ctx.toClientData;
        return result;
    }
    return pendingReqList.indexOf(reqId) === -1 ? undefined : 1;
};
export const changeStatus = function (data) {
    const ctx = conns[data.reqId];
    if (!ctx) {
        return;
    }
    if (data.sendStatus >= 0) {
        ctx.setSendStatus(data.sendStatus);
    }
    else {
        ctx.setReceiveStatus(data.receiveStatus);
    }
    return true;
};
function getBuffer(data, charset) {
    if (data.base64) {
        try {
            return Buffer.from(data.base64, 'base64');
        }
        catch (e) { }
    }
    else if (data.text) {
        return toBuffer(data.text, charset);
    }
    return;
}
export const sendData = function (data) {
    const ctx = conns[data.reqId];
    if (!ctx) {
        return;
    }
    const buf = getBuffer(data, ctx.charset);
    if (!buf) {
        return;
    }
    const isServer = data.target === 'server';
    const binary = data.type === 'bin';
    data = { binary: binary };
    if (ctx.customParser) {
        const name = isServer ? 'toServerData' : 'toClientData';
        const dataList = (ctx[name] = ctx[name] || []);
        if (dataList.length > MAX_COMPOSE_FRAME_COUNT) {
            return false;
        }
        data.base64 = buf.toString('base64');
        dataList.push(data);
        return;
    }
    data.binary = binary;
    data.length = buf.length;
    data.data = buf;
    if (isServer) {
        data.mask = true;
        return ctx.sendToServer(data);
    }
    else {
        return ctx.sendToClient(data);
    }
};
