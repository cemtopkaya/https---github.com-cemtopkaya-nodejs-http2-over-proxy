import * as util from '../util';
import * as rules from '../rules';
import { pluginMgr } from '../plugins';
import * as ca from './ca';
const remoteCerts = ca.remoteCerts;
const SNI_CALLBACK_RE = /^sniCallback:\/\/(?:whistle\.|plugin\.)?([a-z\d_\-]+)(?:\(([\s\S]*)\))?$/;
const certCallbacks = {};
export default function (socket, callback) {
    const servername = socket.servername;
    let curCert = remoteCerts.get(servername);
    let plugin = rules.resolveSNICallback(socket);
    if (plugin) {
        if (socket.rules) {
            socket.rules.sniCallback = plugin;
        }
        if (SNI_CALLBACK_RE.test(plugin.matcher)) {
            socket.sniRuleValue = RegExp.$2;
            const pluginName = RegExp.$1;
            plugin = pluginMgr.getPlugin(pluginName + ':');
            if (plugin) {
                if (curCert && curCert.name) {
                    socket.hasCertCache =
                        curCert.name + (curCert.mtime ? '+' + curCert.mtime : '');
                }
                const cbKey = servername + '/' + pluginName;
                let cbList = certCallbacks[cbKey];
                const handleCert = function (cert) {
                    if (cert === false) {
                        return callback(false);
                    }
                    if (cert && util.isString(cert.key) && util.isString(cert.cert)) {
                        socket.sniPlugin = cert.name;
                        if (!curCert ||
                            curCert.key !== cert.key ||
                            curCert.cert !== cert.cert) {
                            remoteCerts.set(servername, cert);
                            curCert = cert;
                        }
                    }
                    else {
                        if (curCert) {
                            if (cert) {
                                socket.sniPlugin = curCert.name;
                            }
                            else {
                                remoteCerts.del(servername);
                                curCert = null;
                            }
                        }
                    }
                    callback(curCert);
                };
                if (cbList) {
                    return cbList.push(handleCert);
                }
                certCallbacks[cbKey] = [handleCert];
                return pluginMgr.loadCert(socket, plugin, function (cert) {
                    cbList = certCallbacks[cbKey];
                    delete certCallbacks[cbKey];
                    cbList &&
                        cbList.forEach(function (handleCb) {
                            handleCb(cert);
                        });
                });
            }
        }
    }
    curCert && remoteCerts.del(servername);
    callback();
}
