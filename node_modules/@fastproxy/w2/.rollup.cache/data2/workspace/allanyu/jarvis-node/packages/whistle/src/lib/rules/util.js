import { Buffer, fs, path } from '../import-pkg';
import * as util from '../util';
import config from '../config';
import * as httpMgr from '../util/http-mgr';
import Storage from './storage';
import { parse as parseRule } from './index';
const INTERVAL = 1000 * 60 * 60;
const MAX_URL_LEN = 10 * 1024;
const MAX_HEADERS_LEN = 128 * 1024;
const MAX_BODY_LEN = 256 * 1024;
const MAX_METHOD_LEN = 64;
const MAX_HISTORY_LEN = 64;
let history = [];
config.addInitHook(({ LOCAL_FILES }) => {
    try {
        const _files = fs.readdirSync(LOCAL_FILES).filter(checkFilename);
        for (let i = 0, len = _files.length; i < len; i++) {
            const _name = _files[i];
            try {
                const stat = fs.statSync(path.join(LOCAL_FILES, _name));
                if (stat.isFile()) {
                    uploadFiles.push({
                        name: _name,
                        date: stat.mtime.getTime()
                    });
                }
            }
            catch (e) { }
            if (uploadFiles.length >= MAX_FILENAME_LEN) {
                break;
            }
        }
        if (uploadFiles.length) {
            uploadFiles.sort(function (prev, next) {
                return util.compare(prev.date, next.date);
            });
        }
    }
    catch (e) { }
});
let _rulesStorage;
const getRulesStorage = () => {
    if (!_rulesStorage) {
        _rulesStorage = new Storage(config.rulesDir, { Default: true }, config.disableWebUI);
    }
    return _rulesStorage;
};
let _valuesStorage;
const getValuesStorage = () => {
    if (!_valuesStorage)
        _valuesStorage = new Storage(config.valuesDir, undefined, config.disableWebUI);
    return _valuesStorage;
};
let _propertiesStorage;
const getPropertiesStorage = () => {
    if (!_propertiesStorage) {
        _propertiesStorage = new Storage(config.propertiesDir, undefined, config.disableWebUI);
        didAfterPropertiesStorageInited(_propertiesStorage);
    }
    return _propertiesStorage;
};
const LINE_END_RE = /\n|\r\n|\r/g;
const MAX_REMOTE_RULES_COUNT = 16;
const REMOTE_RULES_RE = /^\s*@(`?)(whistle\.[a-z\d_\-]+(?:\/[^\s#]*)?|(?:https?:\/\/|[a-z]:[\\/]|~?\/)[^\s#]+|\$(?:whistle\.)?[a-z\d_-]+[/:][^\s#]+)\s*?\1(?:#.*)?$/gim;
const MAX_COUNT_BY_IMPORT = 60;
const uploadFiles = [];
const MAX_FILENAME_LEN = 60;
const ILLEGAL_FILENAME_RE = /[\\/:*?"<>|\s]/;
let inlineValues;
let proxy;
const CONTROL_RE = /[\u001e\u001f\u200e\u200f\u200d\u200c\u202a\u202d\u202e\u202c\u206e\u206f\u206b\u206a\u206d\u206c]+/g;
const MULTI_LINE_VALUE_RE = /^[^\n\r\S]*(```+)[^\n\r\S]*(\S+)[^\n\r\S]*[\r\n]([\s\S]+?)[\r\n][^\n\r\S]*\1\s*$/gm;
/** 延迟初始化后做一些操作 */
function didAfterPropertiesStorageInited(propertiesStorage) {
    try {
        history = JSON.parse(propertiesStorage.readFile('composerHistory'));
        if (Array.isArray(history)) {
            history = history.filter(checkHistory);
            history = history.slice(0, MAX_HISTORY_LEN);
        }
        else {
            history = [];
        }
    }
    catch (e) { }
    const limitValueLen = (name, len) => {
        const value = propertiesStorage.getProperty(name);
        if (typeof value !== 'string') {
            propertiesStorage.setProperty(name, name);
        }
        else if (value.length > len) {
            propertiesStorage.setProperty(name, value.substring(0, len));
        }
    };
    limitValueLen('Custom1', 16);
    limitValueLen('Custom2', 16);
}
function checkFilename(name) {
    if (!name || typeof name !== 'string' || name.length > MAX_FILENAME_LEN) {
        return false;
    }
    return !ILLEGAL_FILENAME_RE.test(name);
}
function checkHistory(data) {
    if (typeof data.url === 'string' &&
        typeof data.method === 'string' &&
        typeof data.headers === 'string') {
        if (!data.body) {
            data.body = '';
            return true;
        }
        return typeof data.body === 'string';
    }
    return undefined;
}
/**
 * rules
 */
function resolveInlineValues(str) {
    str = str && str.replace(CONTROL_RE, '').trim();
    if (!str || str.indexOf('```') === -1) {
        return str;
    }
    return str.replace(MULTI_LINE_VALUE_RE, function (_, __, key, value) {
        inlineValues = inlineValues || {};
        if (!inlineValues[key]) {
            inlineValues[key] = value;
        }
        return '';
    });
}
const reverseRules = (text, orig) => {
    if (!text) {
        return orig ? [] : '';
    }
    text = resolveInlineValues(text);
    const textList = text.split(LINE_END_RE).reverse();
    return orig ? textList : textList.join('\n');
};
export function parseRules() {
    const disableRules = !config.notAllowedDisableRules &&
        getPropertiesStorage().getProperty('disabledAllRules');
    const shadowRules = disableRules && config.allowDisableShadowRules ? null : config.shadowRules;
    let value = [];
    if (!disableRules && !config.multiEnv) {
        getAllRulesFile().forEach(function (file) {
            if (file.selected) {
                value.push(file.data);
            }
        });
    }
    const backRulesFirst = !config.disabledBackOption &&
        getPropertiesStorage().getProperty('backRulesFirst') === true;
    const defaultRules = disableRules || defaultRulesIsDisabled() ? null : getDefaultRules();
    if (defaultRules) {
        if (backRulesFirst) {
            value.unshift(defaultRules);
        }
        else {
            value.push(defaultRules);
        }
    }
    if (backRulesFirst) {
        value = reverseRules(value.join('\n'), true);
    }
    let valueStr = value && value.join('\r\n');
    if (shadowRules) {
        if (backRulesFirst) {
            valueStr = reverseRules(shadowRules) + '\n' + value;
        }
        else {
            valueStr += '\n' + shadowRules;
        }
    }
    let rulesText = valueStr;
    let index = 0;
    if (rulesText) {
        rulesText = rulesText.replace(REMOTE_RULES_RE, function (_, apo, rulesUrl) {
            if (index >= MAX_REMOTE_RULES_COUNT) {
                return '';
            }
            ++index;
            const remoteRules = util.getRemoteRules(apo, rulesUrl);
            return backRulesFirst ? reverseRules(remoteRules) : remoteRules;
        });
    }
    if (!index) {
        httpMgr.clean();
    }
    parseRule(rulesText, null, inlineValues);
    inlineValues = null;
}
httpMgr.addChangeListener(parseRules);
function setDefaultRules(data) {
    data = typeof data !== 'string' ? '' : data;
    const oldData = getRulesStorage().getProperty('defalutRules') || '';
    getRulesStorage().setProperty('defalutRules', data);
    parseRules();
    return data !== oldData;
}
function getDefaultRules() {
    return getRulesStorage().getProperty('defalutRules');
}
function disableDefaultRules() {
    getRulesStorage().setProperty('disabledDefalutRules', true);
    parseRules();
}
function enableDefaultRules() {
    getRulesStorage().setProperty('disabledDefalutRules', false);
    parseRules();
}
function defaultRulesIsDisabled() {
    return getRulesStorage().getProperty('disabledDefalutRules');
}
function selectRulesFile(file) {
    if (!getRulesStorage().existsFile(file) || config.multiEnv) {
        return;
    }
    const selectedList = allowMultipleChoice() ? getSelectedRulesList() : [];
    if (selectedList.indexOf(file) == -1) {
        selectedList.push(file);
        getRulesStorage().setProperty('selectedList', selectedList);
    }
    parseRules();
    return selectedList;
}
function unselectRulesFile(file, force) {
    if (!force && config.multiEnv) {
        return;
    }
    const selectedList = getSelectedRulesList();
    const index = selectedList.indexOf(file);
    if (index != -1) {
        selectedList.splice(index, 1);
        getRulesStorage().setProperty('selectedList', selectedList);
    }
    parseRules();
    return selectedList;
}
function allowMultipleChoice() {
    return (!config.disabledMultipleOption &&
        getPropertiesStorage().getProperty('allowMultipleChoice'));
}
function clearSelection() {
    getRulesStorage().setProperty('selectedList', []);
    parseRules();
}
function getSelectedRulesList() {
    if (config.multiEnv) {
        return [];
    }
    let selectedList = getRulesStorage().getProperty('selectedList');
    if (!Array.isArray(selectedList)) {
        selectedList = [];
        getRulesStorage().setProperty('selectedList', selectedList);
    }
    return selectedList;
}
function removeRulesFile(file) {
    unselectRulesFile(file, true);
    return getRulesStorage().removeFile(file);
}
function renameRulesFile(file, newFile) {
    if (!getRulesStorage().renameFile(file, newFile)) {
        return;
    }
    const selectedList = getSelectedRulesList();
    const index = selectedList.indexOf(file);
    if (index != -1) {
        selectedList[index] = newFile;
        getRulesStorage().setProperty('selectedList', selectedList);
    }
    return true;
}
function addRulesFile(file, data) {
    return getRulesStorage().writeFile(file, data);
}
function getAllRulesFile() {
    const list = getRulesStorage().getFileList();
    const selectedList = getSelectedRulesList();
    list.forEach(function (file) {
        file.selected = selectedList.indexOf(file.name) != -1;
    });
    return list;
}
function resetRulesIfResort(fromName, toName) {
    const selectedList = getSelectedRulesList();
    if (selectedList.indexOf(fromName) == -1 &&
        selectedList.indexOf(toName) == -1) {
        return;
    }
    parseRules();
}
function moveRulesTo(fromName, toName, clientId) {
    if (getRulesStorage().moveTo(fromName, toName)) {
        resetRulesIfResort(fromName, toName);
        config.setModified(clientId, true);
        proxy.emit('rulesDataChange', 'move', fromName, toName);
        return true;
    }
    return false;
}
export const rules = {
    getRecycleBin: () => getRulesStorage().recycleBin,
    enableBackRulesFirst: function (backRulesFirst) {
        const curFlag = getPropertiesStorage().getProperty('backRulesFirst') === true;
        if (curFlag !== backRulesFirst) {
            getPropertiesStorage().setProperty('backRulesFirst', backRulesFirst);
            parseRules();
        }
    },
    moveTo: moveRulesTo,
    moveToTop: function (name, clientId) {
        const first = name && getAllRulesFile()[0];
        first && moveRulesTo(name, first.name, clientId);
    },
    get: function (file) {
        return getRulesStorage().readFile(file);
    },
    remove: function (file, clientId) {
        if (removeRulesFile(file)) {
            config.setModified(clientId, true);
            proxy.emit('rulesDataChange', 'remove', file);
        }
    },
    add: function (file, data, clientId) {
        if (file !== 'Default' && addRulesFile(file, data)) {
            config.setModified(clientId, true);
            proxy.emit('rulesDataChange', 'add', file);
        }
    },
    rename: function (file, newFile, clientId) {
        if (renameRulesFile(file, newFile)) {
            config.setModified(clientId, true);
            proxy.emit('rulesDataChange', 'rename', file, newFile);
        }
    },
    select: selectRulesFile,
    unselect: unselectRulesFile,
    list: getAllRulesFile,
    getDefault: getDefaultRules,
    setDefault: function (value, clientId) {
        if (setDefaultRules(value)) {
            config.setModified(clientId, true);
            proxy.emit('rulesDataChange', 'add', 'Default');
        }
    },
    enableDefault: enableDefaultRules,
    disableDefault: disableDefaultRules,
    defaultRulesIsDisabled: defaultRulesIsDisabled,
    parseRules: parseRules,
    clearSelection: clearSelection,
    getSelectedList: getSelectedRulesList,
    /**
     * whistle没有实现该方法
     * @deprecated
     */
    setSysHosts: (hosts, callback) => {
        // FIXME: whistle没有实现该方法
    }
};
/**
 * values
 */
function addValuesFile(file, data) {
    return getValuesStorage().writeFile(file, data);
}
function indexOfUploadFiles(name) {
    for (let i = 0, len = uploadFiles.length; i < len; i++) {
        const file = uploadFiles[i];
        if (file.name === name) {
            return i;
        }
    }
    return -1;
}
export const values = {
    getRecycleBin: () => getValuesStorage().recycleBin,
    getUploadFiles: function () {
        return uploadFiles;
    },
    download: function (name, res) {
        if (!checkFilename(name)) {
            return res.end();
        }
        res.download(path.join(config.LOCAL_FILES, name), name);
    },
    existsFile: function (name) {
        return name && indexOfUploadFiles(name) !== -1;
    },
    LIMIMT_FILES_COUNT: MAX_FILENAME_LEN,
    addUploadFile: function (options, callback) {
        const name = options.name;
        if (!checkFilename(name)) {
            return callback();
        }
        if (uploadFiles.length >= MAX_FILENAME_LEN &&
            indexOfUploadFiles(name) === -1) {
            return callback(new Error('The number of uploaded files cannot exceed 60.'));
        }
        let content;
        let base64 = options.base64;
        const headers = options.headers;
        if (headers && typeof headers === 'string') {
            try {
                content = Buffer.from(headers + '\r\n\r\n');
            }
            catch (e) {
                return callback();
            }
        }
        if (base64 && typeof base64 === 'string') {
            try {
                base64 = Buffer.from(base64, 'base64');
                content = content ? Buffer.concat([content, base64]) : base64;
            }
            catch (e) {
                return callback();
            }
        }
        if (!content) {
            return callback();
        }
        fs.writeFile(path.join(config.LOCAL_FILES, name), content.toString(), function (err) {
            if (!err) {
                const index = indexOfUploadFiles(name);
                if (index !== -1) {
                    uploadFiles.splice(index, 1);
                }
                uploadFiles.unshift({
                    name: name,
                    date: Date.now()
                });
            }
            callback(err);
        });
    },
    removeUploadFile: function (name, callback) {
        if (!checkFilename(name) || indexOfUploadFiles(name) === -1) {
            return callback();
        }
        fs.unlink(path.join(config.LOCAL_FILES, name), function (err) {
            const index = indexOfUploadFiles(name);
            if (index === -1 || !err || err.code === 'ENOENT') {
                if (index !== -1) {
                    uploadFiles.splice(index, 1);
                }
                return callback();
            }
            callback(err);
        });
    },
    moveTo: function (fromName, toName, clientId) {
        if (getValuesStorage().moveTo(fromName, toName)) {
            config.setModified(clientId);
            proxy.emit('valuesDataChange', 'move', fromName, toName);
            return true;
        }
        return false;
    },
    add: function (file, data, clientId) {
        if (addValuesFile(file, data)) {
            config.setModified(clientId);
            proxy.emit('valuesDataChange', 'add', file);
        }
    },
    get: function (file) {
        return getValuesStorage().readFile(file);
    },
    remove: function remove(file, clientId) {
        if (getValuesStorage().removeFile(file)) {
            config.setModified(clientId);
            proxy.emit('valuesDataChange', 'remove', file);
        }
    },
    rename: function (file, newFile, clientId) {
        if (getValuesStorage().renameFile(file, newFile)) {
            config.setModified(clientId);
            proxy.emit('valuesDataChange', 'rename', file, newFile);
        }
    },
    list: function list() {
        const selectedFile = getValuesStorage().getProperty('selectedFile');
        const list = getValuesStorage().getFileList();
        if (selectedFile) {
            list.forEach(function (file) {
                file.selected = file.name == selectedFile;
            });
        }
        return list;
    },
    select: function (file) {
        typeof file === 'string' &&
            getValuesStorage().setProperty('selectedFile', file);
    },
    unselect: function () {
        getValuesStorage().removeProperty('selectedFile');
    }
};
setTimeout(function getWhistleVersion() {
    util.getLatestVersion(config.registry, function (ver) {
        ver && getPropertiesStorage().writeFile('latestVersion', ver);
        setTimeout(getWhistleVersion, INTERVAL);
    });
}, 1000); //等待package的信息配置更新完成
/**
 * properties
 */
let composerTimer;
function saveComposerHistory() {
    composerTimer = null;
    try {
        getPropertiesStorage().writeFile('composerHistory', JSON.stringify(history));
    }
    catch (e) { }
}
export const properties = {
    getLatestVersion: function () {
        const version = getPropertiesStorage().readFile('latestVersion');
        return typeof version === 'string' && version.length < 60 ? version : '';
    },
    isEnableCapture: function () {
        if (config.multiEnv) {
            return false;
        }
        if (config.isEnableCapture != null) {
            return config.isEnableCapture;
        }
        return !!getPropertiesStorage().getProperty('interceptHttpsConnects');
    },
    setEnableCapture: function (enable) {
        config.isEnableCapture = enable;
        getPropertiesStorage().setProperty('interceptHttpsConnects', enable);
    },
    isEnableHttp2: function () {
        if (config.isEnableHttp2 != null) {
            return config.isEnableHttp2;
        }
        return getPropertiesStorage().getProperty('enableHttp2') !== false;
    },
    setEnableHttp2: function (enable) {
        config.isEnableHttp2 = enable;
        getPropertiesStorage().setProperty('enableHttp2', enable);
    },
    set: function (name, value) {
        typeof name === 'string'
            ? getPropertiesStorage().setProperty(name, value)
            : getPropertiesStorage().setProperties(name);
    },
    remove: function (name) {
        getPropertiesStorage().removeProperty(name);
    },
    get: function (name) {
        return getPropertiesStorage().getProperty(name);
    },
    getHistory: function () {
        return history;
    },
    addHistory: function (data) {
        if (!data.needResponse || !checkHistory(data)) {
            return;
        }
        const url = data.url;
        const method = data.method;
        const headers = data.headers;
        const body = data.body;
        const result = {
            date: Date.now(),
            useH2: data.useH2,
            url: url.length > MAX_URL_LEN ? url.substring(0, MAX_URL_LEN) : url,
            method: method.length > MAX_METHOD_LEN
                ? method.substring(0, MAX_METHOD_LEN)
                : method,
            headers: headers.length > MAX_HEADERS_LEN
                ? headers.substring(0, MAX_HEADERS_LEN)
                : headers,
            body: body.length > MAX_BODY_LEN ? body.substring(0, MAX_BODY_LEN) : body,
            isHexText: !!data.isHexText
        };
        for (let i = 0, len = history.length; i < len; i++) {
            const item = history[i];
            if (item.url === result.url &&
                item.method === result.method &&
                item.headers === result.headers &&
                item.body === result.body &&
                !item.useH2 !== result.useH2) {
                history.splice(i, 1);
                break;
            }
        }
        history.unshift(result);
        const overflow = history.length - MAX_HISTORY_LEN;
        if (overflow > 0) {
            history.splice(MAX_HISTORY_LEN, overflow);
        }
        if (!composerTimer) {
            composerTimer = setTimeout(saveComposerHistory, 2000);
        }
    }
};
function getRules(rules) {
    if (Array.isArray(rules)) {
        return rules.join('\n');
    }
    if (typeof rules === 'string') {
        return rules;
    }
    return undefined;
}
export const addRules = function (rules, replace, clientId) {
    if (rules == null) {
        return;
    }
    replace = replace !== false;
    let hasChanged;
    if (Array.isArray(rules) || typeof rules === 'string') {
        if (replace !== false || !getDefaultRules()) {
            hasChanged = setDefaultRules(getRules(rules));
        }
    }
    else {
        const keys = Object.keys(rules).slice(0, MAX_COUNT_BY_IMPORT);
        keys.forEach(function (name) {
            let item = name ? rules[name] : null;
            if (Array.isArray(item) || typeof item === 'string') {
                item = { rules: item };
            }
            if (item) {
                item.rules = getRules(item.rules);
                if (typeof item.replace !== 'boolean') {
                    item.replace = replace;
                }
                if (name === 'Default') {
                    if (typeof item.rules === 'string' &&
                        (item.replace !== false || !getDefaultRules())) {
                        if (setDefaultRules(item.rules)) {
                            hasChanged = true;
                        }
                    }
                    if (item.enable) {
                        enableDefaultRules();
                    }
                    else if (item.enable === false) {
                        disableDefaultRules();
                    }
                }
                else {
                    if (typeof item.rules === 'string' &&
                        (item.replace !== false || !getRulesStorage().existsFile(name))) {
                        if (addRulesFile(name, item.rules)) {
                            hasChanged = true;
                        }
                    }
                    if (item.enable) {
                        selectRulesFile(name);
                    }
                    else if (item.enable === false) {
                        unselectRulesFile(name);
                    }
                }
            }
        });
    }
    if (hasChanged) {
        config.setModified(clientId, true);
    }
};
export const addValues = function (values, replace, clientId) {
    if (values == null || Array.isArray(values)) {
        return;
    }
    replace = replace !== false;
    let hasChanged;
    const keys = Object.keys(values).slice(0, MAX_COUNT_BY_IMPORT);
    keys.forEach(function (name) {
        if (/\s/.test(name) || (!replace && getValuesStorage().existsFile(name))) {
            return;
        }
        let value = name ? values[name] : null;
        if (value == null) {
            return;
        }
        if (typeof value !== 'string') {
            value = JSON.stringify(value, null, '  ');
        }
        if (addValuesFile(name, value)) {
            hasChanged = true;
        }
    });
    if (hasChanged) {
        config.setModified(clientId);
    }
};
export const setup = function (p) {
    proxy = p;
};
