import http, { Agent as httpAgent } from 'http';
import fs from 'fs';
import path from 'path';
import tls from 'tls';
import { parse as parseUrl } from 'url';
import { Agent as httpsAgent } from 'https';
import { agent } from 'hagent';
import WebSocket from 'ws';
import requestDeps from 'request';
import createDebug from 'debug';
import configIns from '../lib/config';
import config from './config';
import events from './events';
const debug = createDebug('@w2.tests.utils');
const requestProxy = requestDeps.defaults({
    proxy: 'http://127.0.0.1:' + config.port
});
let count = 0;
let end;
export const setEnd = function () {
    end = true;
};
function exit() {
    if (--count <= 0) {
        if (end) {
            process.exit(0);
        }
        else {
            events.emit('next');
        }
    }
}
function setHost(fullUrl, opts) {
    let host = opts.host;
    if (host || opts.port > 0) {
        const urlOpts = parseUrl(fullUrl);
        host = host || urlOpts.hostname;
        const port = opts.port || urlOpts.port;
        if (port) {
            host = host + ':' + port;
        }
        fullUrl = fullUrl.replace(/\/\/[^/]+/, '//' + host);
    }
    return fullUrl.replace(/^ws/, 'http');
}
export const requestWS = function (url, callback) {
    return new Promise(resolve => {
        ++count;
        const options = parseUrl(url);
        const ws = new WebSocket(setHost(url, { host: '127.0.0.1', port: config.port }), {
            headers: { host: options.host },
            rejectUnauthorized: true
        });
        let done;
        ws.on('open', function open() {
            if (/checkStatusCode/.test(url)) {
                if (done) {
                    return;
                }
                done = true;
                callback?.('checkStatusCode');
                resolve('checkStatusCode');
                exit();
            }
            else {
                ws.send('something');
            }
        });
        ws.on('message', function (data) {
            if (done) {
                return;
            }
            done = true;
            callback?.(JSON.parse(data));
            resolve(JSON.parse(data));
            exit();
        });
    });
};
export const request = (options, callback) => new Promise((resolve, reject) => {
    ++count;
    if (typeof options === 'string' && /^ws/.test(options)) {
        const url = options;
        const opts = parseUrl(url);
        const isSsl = /^wss:/.test(url);
        configIns.connect({
            proxyHost: '127.0.0.1',
            proxyPort: config.port,
            host: opts.hostname,
            port: opts.port || (isSsl ? 443 : 80),
            headers: {
                host: opts.host,
                'proxy-connection': 'keep-alive'
            }
        }, function (socket) {
            const agent = isSsl ? new httpsAgent() : new httpAgent();
            if (isSsl) {
                socket = tls.connect({
                    rejectUnauthorized: false,
                    socket: socket,
                    servername: opts.hostname
                });
            }
            agent.createConnection = function () {
                return socket;
            };
            const ws = new WebSocket(url, {
                agent: agent,
                rejectUnauthorized: true
            });
            ws.on('open', function open() {
                ws.send('something');
            });
            let done = false;
            ws.on('message', function (data) {
                if (done) {
                    return;
                }
                done = true;
                callback?.(JSON.parse(data));
                resolve(JSON.parse(data));
                exit();
            });
        });
    }
    else {
        if (typeof options === 'string') {
            options = {
                url: options,
                rejectUnauthorized: false
            };
        }
        if (options.isTunnel) {
            options.agent = new agent.httpsOverHttp({
                proxy: {
                    host: '127.0.0.1',
                    port: config.port,
                    url: options.url,
                    headers: {
                        host: parseUrl(options.url).host,
                        'x-whistle-policy': 'tunnel'
                    }
                },
                rejectUnauthorized: false
            });
        }
        const reqCallback = function (err, res, body) {
            debug('reqCallback, url: %s, body: %O', options.url, body);
            try {
                const data = /\?resBody=/.test(options.url)
                    ? body
                    : /doNotParseJson/.test(options.url)
                        ? body
                        : JSON.parse(body);
                callback?.(res, data, err);
                if (err) {
                    reject(err);
                }
                else {
                    resolve({
                        res,
                        data
                    });
                }
            }
            catch (e) {
                /*eslint no-console: "off"*/
                console.log(options);
                reject(e);
            }
            exit();
        };
        options.isTunnel ? requestDeps(options, reqCallback) : requestProxy(options, reqCallback);
    }
});
export function noop() {
    /** noop */
}
export function getTextBySize(size) {
    return new Array(size + 1).join('1');
}
function connect(host, port, callback) {
    let done = false;
    const execCallback = function (err, socket) {
        if (done) {
            return;
        }
        done = true;
        callback(err, socket);
    };
    const req = http.request({
        method: 'CONNECT',
        host: '127.0.0.1',
        port: config.port,
        agent: false,
        headers: {
            'user-agent': 'test/whistle',
            'proxy-connection': 'keep-alive',
            'x-whistle-policy': 'tunnel',
            host: host + (port ? ':' + port : '')
        }
    });
    req.on('error', execCallback);
    req.on('connect', function (res, socket, head) {
        execCallback(null, socket);
    });
    req.end();
}
export function proxy(url, callback) {
    ++count;
    const options = parseUrl(url);
    connect(options.hostname, options.port, function (err, socket) {
        if (err) {
            if (callback) {
                callback(err);
            }
            else {
                throw err;
            }
            exit();
            return;
        }
        options.createConnection = function () {
            return socket;
        };
        http
            .request(options, function (res) {
            if (callback) {
                res.on('data', noop);
                let done = false;
                res.on('error', function (err) {
                    if (done) {
                        return;
                    }
                    done = true;
                    callback(err, res);
                    exit();
                });
                res.on('end', function () {
                    if (done) {
                        return;
                    }
                    done = true;
                    callback(err, res);
                    exit();
                });
            }
            else {
                exit();
            }
        })
            .end();
    });
}
export function getValues() {
    const values = {};
    const dir = path.join(__dirname, '../../__tests__/assets/values');
    fs.readdirSync(dir).map(function (name) {
        values[name] = fs.readFileSync(path.join(dir, name), { encoding: 'utf8' });
    });
    return values;
}
