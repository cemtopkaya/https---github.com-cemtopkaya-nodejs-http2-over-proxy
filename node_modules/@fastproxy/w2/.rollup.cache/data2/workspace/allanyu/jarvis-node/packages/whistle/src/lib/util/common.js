import { fs, fse, os, path, pkgInfo } from '../import-pkg';
const HEAD_RE = /^head$/i;
const HOME_DIR_RE = /^[~～]\//;
const ILLEGAL_TRAILERS = [
    'host',
    'transfer-encoding',
    'content-length',
    'cache-control',
    'te',
    'max-forwards',
    'authorization',
    'set-cookie',
    'content-encoding',
    'content-type',
    'content-range',
    'trailer',
    'connection',
    'upgrade',
    'http2-settings',
    'proxy-connection',
    'transfer-encoding',
    'keep-alive'
];
export const REMOTE_URL_RE = /^\s*((?:git[+@]|github:)[^\s]+\/whistle\.[a-z\d_-]+(?:\.git)?|https?:\/\/[^\s]+)\s*$/i;
export function isHead(req) {
    return HEAD_RE.test(req.method);
}
export const getUpdateUrl = function (conf) {
    const url = conf.updateUrl;
    if (url && REMOTE_URL_RE.test(url) && url.length < 2100) {
        return url;
    }
};
export const noop = function () { };
export function removeIPV6Prefix(ip) {
    if (typeof ip !== 'string') {
        return '';
    }
    return ip.indexOf('::ffff:') === 0 ? ip.substring(7) : ip;
}
export function hasBody(res, req) {
    if (req && isHead(req)) {
        return false;
    }
    const statusCode = res.statusCode;
    return !(statusCode == 204 ||
        (statusCode >= 300 && statusCode < 400) ||
        (100 <= statusCode && statusCode <= 199));
}
export function isEmptyObject(a) {
    if (a) {
        for (const _i in a) {
            return false;
        }
    }
    return true;
}
export const lowerCaseify = function (obj, rawNames) {
    const result = {};
    if (!obj) {
        return result;
    }
    Object.keys(obj).forEach(function (name) {
        const value = obj[name];
        if (value !== undefined) {
            const key = name.toLowerCase();
            result[key] = Array.isArray(value) ? value : value + '';
            if (rawNames) {
                rawNames[key] = name;
            }
        }
    });
    return result;
};
export const removeIllegalTrailers = function (headers) {
    ILLEGAL_TRAILERS.forEach(function (key) {
        delete headers[key];
    });
};
export const addTrailerNames = function (res, newTrailers, rawNames, delTrailers, req) {
    if (!hasBody(res, req) || isEmptyObject(newTrailers)) {
        return;
    }
    const headers = res.headers;
    delete headers['content-length'];
    delete headers['transfer-encoding'];
    const nameMap = {};
    const curTrailers = headers.trailer;
    if (curTrailers) {
        if (typeof curTrailers === 'string') {
            nameMap[curTrailers.toLowerCase()] = curTrailers;
        }
        else if (Array.isArray(curTrailers)) {
            curTrailers.forEach(function (key) {
                if (key && typeof key === 'string') {
                    nameMap[key.toLowerCase()] = key;
                }
            });
        }
    }
    Object.keys(newTrailers).forEach(function (key) {
        const lkey = key.toLowerCase();
        if ((!delTrailers || !delTrailers[lkey]) &&
            ILLEGAL_TRAILERS.indexOf(lkey) === -1) {
            nameMap[lkey] = key;
        }
    });
    if (rawNames && !rawNames.trailer) {
        rawNames.trailer = 'Trailer';
    }
    headers.trailer = Object.keys(nameMap).map(function (key) {
        return nameMap[key];
    });
};
export const onResEnd = function (res, callback) {
    const state = res._readableState || '';
    if (state.endEmitted) {
        return callback();
    }
    res.on('end', callback);
};
const UPGRADE_RE = /^\s*upgrade\s*$/i;
const WS_RE = /^\s*websocket\s*$/i;
const CONNECT_RE = /^\s*CONNECT\s*$/i;
const CONNECT_PROTOS = 'connect:,socket:,tunnel:,conn:,tls:,tcp:'.split(',');
export const isUpgrade = function (options, headers) {
    const p = options.protocol;
    if (p === 'ws:' || p === 'wss:' || options.method === 'UPGRADE') {
        return true;
    }
    return headers && UPGRADE_RE.test(headers.connection);
};
export function isWebSocket(options, headers) {
    const p = options.protocol;
    if (p === 'ws:' || p === 'wss:' || options.method === 'UPGRADE') {
        return true;
    }
    return (headers &&
        UPGRADE_RE.test(headers.connection) &&
        WS_RE.test(headers.upgrade));
}
export function isConnect(options) {
    return (CONNECT_RE.test(options.method) ||
        CONNECT_PROTOS.indexOf(options.protocol) !== -1);
}
const PROTOCOL_RE = /^[a-z0-9.-]+:\/\//i;
export function hasProtocol(url) {
    return PROTOCOL_RE.test(url);
}
export function setProtocol(url, isHttps) {
    return hasProtocol(url) ? url : (isHttps ? 'https://' : 'http://') + url;
}
export function getProtocol(url) {
    return hasProtocol(url) ? url.substring(0, url.indexOf('://') + 1) : null;
}
export function removeProtocol(url, clear) {
    return hasProtocol(url)
        ? url.substring(url.indexOf('://') + (clear ? 3 : 1))
        : url;
}
export function replaceProtocol(url, protocol) {
    return (protocol || 'http:') + removeProtocol(url);
}
export function getHomedir() {
    //默认设置为`~`，防止Linux在开机启动时Node无法获取homedir
    return ((typeof os.homedir === 'function'
        ? os.homedir()
        : process.env[process.platform == 'win32' ? 'USERPROFILE' : 'HOME']) ||
        '~');
}
export function getHomePath(dir) {
    if (!dir || !HOME_DIR_RE.test(dir)) {
        return dir;
    }
    return path.join(getHomedir(), '.' + dir.substring(1));
}
export function getWhistlePath() {
    return (getHomePath(process.env.WHISTLE_PATH) ||
        path.join(getHomedir(), '.WhistleAppData'));
}
export function getLogFile(name) {
    const whistlePath = getWhistlePath();
    fse.ensureDirSync(whistlePath);
    return path.join(whistlePath, pkgInfo.name.replace('/', '-') + (name ? '-' + name : '') + '.log');
}
function padLeft(n) {
    return n > 9 ? n + '' : '0' + n;
}
function getDate() {
    const date = new Date();
    return (date.getFullYear() + padLeft(date.getMonth() + 1) + padLeft(date.getDate()));
}
export const writeLogSync = function (msg) {
    try {
        fs.writeFileSync(getLogFile(), msg, { flag: 'a' });
    }
    catch (e) {
        msg += '\r\n' + e.stack;
        try {
            fs.writeFileSync(getLogFile('error'), msg, { flag: 'a' });
        }
        catch (e) {
            fs.writeFileSync(getLogFile(getDate()), msg + '\r\n' + e.stack, {
                flag: 'a'
            });
        }
    }
};
const SPEC_TAGS = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '`': '&#96;'
};
const SPEC_TAG_RE = /[&<>"'`]/g;
function transformTag(tag) {
    return SPEC_TAGS[tag] || tag;
}
export const encodeHtml = function (str) {
    if (typeof str !== 'string') {
        return str;
    }
    return str.replace(SPEC_TAG_RE, transformTag);
};
const SEP_RE_G = /^[^\n\r\S]*```+\s*$/gm;
export const wrapRuleValue = function (key, value, size, policy) {
    if (!key || value == null) {
        return '';
    }
    if (!value || typeof value !== 'string') {
        return '\n``` ' + key + '\n\n```\n';
    }
    const isOverSize = size > 0 && value.length > size;
    if (isOverSize) {
        if (policy === 'ignore') {
            return '';
        }
        if (policy === 'empty') {
            return '\n``` ' + key + '\n\n```\n';
        }
        value = value.substring(0, size);
    }
    let list = value.match(SEP_RE_G);
    if (!list) {
        return '\n``` ' + key + '\n' + value + '\n```\n';
    }
    list = list.map(function (item) {
        return item.trim().length;
    });
    const count = Math.max.apply(null, list) + 1;
    const sep = typeof '`'.repeat === 'function' ? '`'.repeat(count) : '```````````';
    return '\n' + sep + ' ' + key + '\n' + value + '\n' + sep + '\n';
};
export const isGroup = function (name) {
    return name && name[0] === '\r';
};
