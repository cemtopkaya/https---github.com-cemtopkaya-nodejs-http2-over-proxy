import { getRawHeaderNames } from 'hparser';
import { PassThrough } from '../import-pkg';
import * as rules from '../rules';
import * as util from '../util';
import { pluginMgr } from '../plugins';
import * as fileMgr from '../util/file-mgr';
import * as transproto from '../util/transproto';
const getEncodeTransform = transproto.getEncodeTransform;
const getDecodeTransform = transproto.getDecodeTransform;
const HTTP_RE = /^https?:/;
const MAX_PAYLOAD_SIZE = 1024 * 256;
function resolveRules(req, rules) {
    if (!rules) {
        return;
    }
    req.curUrl = req.fullUrl = util.getFullUrl(req);
    if (rules.initRules) {
        rules.initRules(req);
    }
    else {
        const _pluginRules = rules.resolveReqRules(req);
        // 插件不支持rulesFile协议
        delete req.rules.rulesFile;
        util.mergeRules(req, _pluginRules);
    }
}
function setupRules(req, next) {
    resolveRules(req, rules);
    rules.resolveRulesFile(req, function () {
        pluginMgr.resolveWhistlePlugins(req);
        pluginMgr.getRules(req, function (pluginRules) {
            req.pluginRules = pluginRules;
            resolveRules(req, pluginRules);
            util.filterWeakRule(req);
            let ruleUrl = util.rule.getUrl(req.rules.rule);
            if (ruleUrl !== req.fullUrl && ruleUrl && HTTP_RE.test(ruleUrl)) {
                ruleUrl = util.encodeNonLatin1Char(ruleUrl);
            }
            req.options = util.parseUrl(ruleUrl || req.fullUrl);
            if (req.isH2 && ruleUrl && req.options.protocol === 'http:' && ruleUrl !== req.fullUrl) {
                req.isH2 = false;
            }
            const rawNames = (req.rawHeaderNames = Array.isArray(req.rawHeaders) ? getRawHeaderNames(req.rawHeaders) : {});
            rawNames.connection = rawNames.connection || 'Connection';
            rawNames['proxy-authorization'] = rawNames['proxy-authorization'] || 'Proxy-Authorization';
            next();
        });
    });
}
function getDecoder(obj) {
    return function (socket, callback) {
        const encoding = obj._originEncoding;
        const handleError = function (err) {
            obj.emit('error', err);
        };
        let decoder;
        if (obj._needGunzip || socket || encoding !== obj.headers['content-encoding']) {
            const stream = encoding && (obj._srcResponse || obj);
            util.readOneChunk(stream, function (chunk) {
                obj._needGunzip = false;
                if (chunk) {
                    if (chunk[0] === 31 && (chunk[1] == null || chunk[1] === 139)) {
                        decoder = util.getUnzipStream(encoding);
                        obj._needGunzip = true;
                    }
                    else {
                        decoder = new PassThrough();
                        obj._originEncoding = null;
                    }
                    decoder.write(chunk);
                }
                handleDecode(stream);
            });
        }
        else {
            handleDecode();
        }
        function handleDecode(stream) {
            decoder && decoder.on('error', handleError);
            if (socket) {
                delete obj.headers['content-length'];
                const enTrans = getEncodeTransform();
                const deTrans = getDecodeTransform();
                enTrans.pipe(socket).pipe(deTrans);
                enTrans.on('error', handleError);
                deTrans.on('error', handleError);
                if (decoder) {
                    decoder.pipe(enTrans);
                }
                else {
                    decoder = enTrans;
                }
                socket = deTrans;
            }
            callback(decoder, socket, stream);
        }
    };
}
function getEncoder(obj, req) {
    return function (socket, callback) {
        let encoding;
        const enable = req && req.enable;
        if (enable && enable.gzip && (obj._needGunzip || !obj._originEncoding)) {
            encoding = 'gzip';
        }
        else {
            encoding = obj._needGunzip && obj.headers;
        }
        let encoder = encoding && util.getZipStream(encoding);
        const handleError = function (err) {
            obj.emit('error', err);
        };
        encoder && encoder.on('error', handleError);
        if (socket) {
            delete obj.headers['content-length'];
            const enTrans = getEncodeTransform();
            const deTrans = getDecodeTransform();
            enTrans.on('error', handleError);
            deTrans.on('error', handleError);
            enTrans.pipe(socket).pipe(deTrans);
            socket = enTrans;
            if (encoder) {
                deTrans.pipe(encoder);
            }
            else {
                encoder = deTrans;
            }
            socket.pipe = function (stream) {
                return encoder.pipe(stream);
            };
            obj.emit('bodyStreamReady', socket);
        }
        callback(socket || encoder);
    };
}
export function inspectRules(req, res, next) {
    if (req.isLogRequests !== false) {
        ++util.proc.httpRequests;
        ++util.proc.totalHttpRequests;
        req.isLogRequests = true;
    }
    req.reqId = util.getReqId();
    req.curUrl = req.fullUrl = util.getFullUrl(req);
    req._originEncoding = req.headers['content-encoding'];
    req.onDecode = function (callback) {
        const decode = getDecoder(req);
        pluginMgr.getReqReadPipe(req, function (socket) {
            decode(socket, callback);
        });
    };
    req.onEncode = function (callback) {
        const encode = getEncoder(req);
        pluginMgr.getReqWritePipe(req, function (socket) {
            encode(socket, callback);
        });
    };
    res.onDecode = function (callback) {
        const decode = getDecoder(res);
        pluginMgr.getResReadPipe(req, res, function (socket) {
            decode(socket, callback);
        });
    };
    res.onEncode = function (callback) {
        const encode = getEncoder(res, req);
        pluginMgr.getResWritePipe(req, res, function (socket) {
            encode(socket, callback);
        });
    };
    rules.initHeaderRules(req, true);
    pluginMgr.resolvePipePlugin(req, function () {
        const reqReadPort = req._pipePluginPorts.reqReadPort;
        if (reqReadPort || req._pipePluginPorts.reqWritePort) {
            delete req.headers['content-length'];
        }
        const hasBodyFilter = rules.resolveBodyFilter(req);
        req._bodyFilters = null;
        if (hasBodyFilter || reqReadPort) {
            req._needGunzip = true;
            let payloadSize = MAX_PAYLOAD_SIZE;
            if (!hasBodyFilter) {
                payloadSize = rules.hasReqScript(req) ? 0 : 1;
            }
            req.getPayload(function (_err, payload) {
                req._reqBody = fileMgr.decode(payload);
                setupRules(req, next);
            }, payloadSize);
        }
        else {
            setupRules(req, next);
        }
    });
}
