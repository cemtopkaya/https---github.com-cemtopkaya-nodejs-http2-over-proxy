import Debug from 'debug';
import { HttpAgent, HttpsAgent, LRU, crypto, dns, extend, fs, fse, http, https, json5, net, path, pkgInfo, qs, socks, tunnel, url } from './import-pkg';
import { toBuffer } from './util/file-mgr';
import * as common from './util/common';
const debug = Debug('@w2.lib.config');
let customUIHost;
let customHostPluginMap = {};
const customPluginNameHost = {};
const WHISTLE_PLUGIN_RE = /^(?:whistle\.)?([a-z\d_\-]+)$/;
const CMD_RE = /^[\w]{1,12}(?:\s+-g)?$/;
const httpsAgents = new LRU({ max: 360 });
const socksAgents = new LRU({ max: 100 });
const version = process.version.substring(1).split('.');
const majorVersion = parseInt(version[0], 10);
let disableAgent = majorVersion > 10;
const uid = Date.now() + '-' + process.pid + '-' + Math.floor(Math.random() * 10000);
const IPV4_RE = /^([\d.]+)(:\d{1,5})?$/;
const IPV6_RE = /^\[([\w:]+)\](:\d{1,5})?$/;
const noop = function () { };
const DATA_KEY_RE = /^(clientip|clientid|tunneldata)([=.])([\w.-]+)$/i;
const LOCAL_UI_HOST_LIST = ['local.whistlejs.com', 'local.wproxy.org', 'l.wproxy.org', 'rootca.pro'];
const variableProperties = [
    'encrypted',
    'sockets',
    'dataDirname',
    'storage',
    'baseDir',
    'noGlobalPlugins',
    'pluginsDataMap',
    'globalData',
    'username',
    'password',
    'debugMode',
    'localUIHost',
    'extra',
    'rules',
    'values',
    'dnsCache',
    'allowDisableShadowRules'
];
const KEEP_ALIVE_MSECS = 10000;
const CONN_TIMEOUT = 30000;
export class Config {
    constructor() {
        this.version = pkgInfo.version;
        this.name = pkgInfo.name;
        this.dataDirname = pkgInfo.dataDirname;
        this.localUIHost = pkgInfo.localUIHost;
        this.sockets = pkgInfo.sockets;
        this.timeout = pkgInfo.timeout;
        this.registry = pkgInfo.registry;
        this.port = pkgInfo.port;
        this.uid = uid;
        this.rejectUnauthorized = false;
        this.enableH2 = majorVersion > 12; // 支持 HTTP2 要求的最低 Node 版本
        this.ASSESTS_PATH = path.join(__dirname, '../../assets');
        this.REQ_FROM_HEADER = 'x-whistle-request-from';
        this.WHISTLE_POLICY_HEADER = 'x-whistle-policy';
        this.CUSTOM_CERT_HEADER = 'x-whistle-exists-custom-cert';
        this.ENABLE_CAPTURE_HEADER = 'x-whistle-enable-capture';
        this.CLIENT_IP_HEAD = 'x-forwarded-for';
        this.HTTPS_FIELD = 'x-whistle-https-request';
        this.HTTPS_PROTO_HEADER = 'x-forwarded-proto';
        this.REAL_HOST_HEADER = 'x-whistle-real-host';
        this.FWD_HOST_HEADER = 'x-forwarded-host';
        this.INTERNAL_ID = Date.now() + '/' + process.pid + '/' + Math.floor(Math.random() * 100000);
        this.INTERNAL_ID_HEADER = '_x-whistle-internal-id';
        this.SNI_PLUGIN_HEADER = 'x-whistle-sni-callback-plugin-' + uid;
        this.PROXY_ID_HEADER = 'x-whistle-proxy-id-' + uid;
        this.CLIENT_PORT_HEAD = 'x-whistle-client-port';
        this.WEBUI_HEAD = 'x-forwarded-from-whistle-' + uid;
        this.RES_RULES_HEAD = 'x-whistle-res-rules-' + uid;
        this.CLIENT_INFO_HEAD = 'x-whistle-client-info-' + uid;
        this.REMOTE_ADDR_HEAD = 'x-whistle-remote-address-' + uid;
        this.REMOTE_PORT_HEAD = 'x-whistle-remote-port-' + uid;
        this.WEBUI_PATH = '/.whistle-path.5b6af7b9884e1165/';
        this.PREVIEW_PATH_RE = /\?\?\?WHISTLE_PREVIEW_CHARSET=([A-Z\d_-]+)\?\?\?$/;
        this.PLUGIN_HOOK_NAME_HEADER = 'x-whistle-plugin-hook-name_';
        this.CLIENT_ID_HEADER = 'x-whistle-client-id';
        this.COMPOSER_CLIENT_ID_HEADER = 'x-whistle-client-id-' + uid;
        this.TUNNEL_DATA_HEADER = 'x-whistle-tunnel-data';
        this.TEMP_TUNNEL_DATA_HEADER = 'x-whistle-tunnel-data-' + uid;
        this.SNI_TYPE_HEADER = 'x-whistle-sni-type-' + uid;
        this.ALPN_PROTOCOL_HEADER = 'x-whistle-alpn-protocol';
        this.PLUGIN_HOOKS = {
            SNI: 'sni-' + uid,
            AUTH: 'auth-' + uid,
            HTTP: 'http-' + uid,
            UI: 'ui-' + uid,
            TUNNEL: 'tunnel-' + uid,
            TUNNEL_RULES: 'tunnel-rules-' + uid,
            REQ_STATS: 'req-stats-' + uid,
            RES_STATS: 'res-stats-' + uid,
            REQ_RULES: 'req-rules-' + uid,
            RES_RULES: 'res-rules-' + uid,
            REQ_READ: 'req-read-' + uid,
            REQ_WRITE: 'req-write-' + uid,
            RES_READ: 'res-read-' + uid,
            RES_WRITE: 'res-write-' + uid,
            WS_REQ_READ: 'ws-req-read-' + uid,
            WS_REQ_WRITE: 'ws-req-write-' + uid,
            WS_RES_READ: 'ws-res-read-' + uid,
            WS_RES_WRITE: 'ws-res-write-' + uid,
            TUNNEL_REQ_READ: 'tunnel-req-read-' + uid,
            TUNNEL_REQ_WRITE: 'tunnel-req-write-' + uid,
            TUNNEL_RES_READ: 'tunnel-res-read-' + uid,
            TUNNEL_RES_WRITE: 'tunnel-res-write-' + uid
        };
        this.CONN_TIMEOUT = CONN_TIMEOUT;
        this.getHomedir = common.getHomedir;
        this.getHomePath = common.getHomePath;
        this.getWhistlePath = common.getWhistlePath;
        this.CUSTOM_PLUGIN_PATH = path.join(this.getWhistlePath(), 'custom_plugins');
        this.CUSTOM_CERTS_DIR = path.resolve(this.getWhistlePath(), 'custom_certs');
        this.pluginHostMap = {};
        this.allowPluginList = [];
        this.blockPluginList = [];
        this.reqCacheSize = 600;
        this.frameCacheSize = 600;
        this.debug = false;
        this.middlewares = [];
        this.notUninstallPluginPaths = [];
        this.pluginPaths = [];
        this.prePluginsPath = [];
        this.projectPluginPaths = [];
        this.accountPluginsPath = [];
        this.customPluginPaths = [];
        this.addon = [];
        this.uiHostList = [];
        this.guest = {};
        this.inited = false;
        this.initedHooks = [];
        this.getDataDir = (dirname) => {
            const dir = path.join(this.getWhistlePath(), dirname || '.' + this.name);
            fse.ensureDirSync(dir);
            return dir;
        };
        this.baseDir = this.getDataDir();
        this.getHttpsAgent = (options, reqOpts) => {
            const key = getCacheKey(options);
            let agent = httpsAgents.get(key);
            if (reqOpts) {
                const headers = options.headers || {};
                const proxyHeaders = {};
                Object.keys(headers).forEach(function (key) {
                    const rawKey = key.split('-').map(capitalize).join('-');
                    proxyHeaders[rawKey] = headers[key];
                });
                reqOpts._tunnelProxyHeaders = proxyHeaders;
            }
            if (!agent) {
                options.proxyAuth = options.auth;
                options.rejectUnauthorized = this.rejectUnauthorized;
                options.proxy = {
                    host: options.proxyHost,
                    port: options.proxyPort,
                    enableIntercept: options.enableIntercept,
                    keepStreamResume: options.keepStreamResume,
                    proxyTunnelPath: options.proxyTunnelPath
                };
                let agentName = options.isHttps ? 'httpsOverHttp' : 'httpOverHttp';
                if (options.proxyServername) {
                    options.proxy.servername = options.proxyServername;
                    agentName += 's';
                }
                agent = new tunnel[agentName](options);
                httpsAgents.set(key, agent);
                agent.on('free', preventThrowOutError);
            }
            return agent;
        };
        this.setLocalUIHost = (hostname) => {
            this.customLocalUIHost = getHostname(hostname);
        };
        this.isWebUIHost = (host) => {
            if (host === 'local.wproxy.org' ||
                this.uiHostList.indexOf(host) !== -1 ||
                (customUIHost && customUIHost.indexOf(host) !== -1)) {
                return true;
            }
            if (this.pureProxy) {
                return false;
            }
            return LOCAL_UI_HOST_LIST.indexOf(host) !== -1;
        };
        this.isLocalUIUrl = (url) => {
            const host = getHostname(url);
            return this.isWebUIHost(host) || !!this.pluginHostMap[host] || !!customHostPluginMap[host];
        };
        this.getPluginNameByHost = (host) => {
            host = getHostname(host);
            if (this.isWebUIHost(host)) {
                return;
            }
            return this.pluginHostMap[host] || customHostPluginMap[host];
        };
        this.extend = (newConf) => {
            this.pluginHostMap = {};
            this.uiport = this.port;
            if (newConf) {
                this.uiMiddleware = newConf.uiMiddlewares || newConf.uiMiddleware;
                if (newConf.cmdName && CMD_RE.test(newConf.cmdName)) {
                    this.cmdName = newConf.cmdName;
                }
                if (newConf.account && typeof newConf.account === 'string') {
                    this.account = newConf.account;
                }
                this.allowPluginList = getPluginList(newConf.allowPluginList);
                this.blockPluginList = getPluginList(newConf.blockPluginList);
                if (newConf.webUIPath && /^[\w.-]+$/.test(newConf.webUIPath)) {
                    this.WEBUI_PATH = '/.' + newConf.webUIPath + this.WEBUI_PATH.substring(1);
                }
                if (newConf.cluster) {
                    this.headless = true;
                    this.workerIndex = process.env.workerIndex;
                    if (typeof newConf.mode !== 'string') {
                        newConf.mode = '';
                    }
                }
                let dnsServer = newConf.dnsServer;
                let resolve6;
                let dnsOptional;
                if (dnsServer && typeof dnsServer === 'string') {
                    dnsServer = dnsServer.trim();
                    if (/^https?:\/\/.+/.test(dnsServer)) {
                        this.dnsOverHttps = dnsServer;
                    }
                    else {
                        dnsServer = dnsServer.split(/[|,&]/);
                    }
                }
                if (Array.isArray(dnsServer)) {
                    const newServers = [];
                    dnsServer.forEach(function (ip) {
                        ip = (typeof ip === 'string' && ip.trim()) || '';
                        if (/^ipv6$/i.test(ip)) {
                            resolve6 = true;
                        }
                        else if (ip === 'optional' || ip === 'default') {
                            dnsOptional = true;
                        }
                        else if (net.isIP(ip)) {
                            newServers.push(ip);
                        }
                        else if (IPV4_RE.test(ip) || IPV6_RE.test(ip)) {
                            const dnsIp = RegExp.$1;
                            const dnsPort = RegExp.$2;
                            if (net.isIP(dnsIp) && (!dnsPort || isPort(dnsPort.substring(1)))) {
                                newServers.push(ip);
                            }
                        }
                    });
                    if (newServers.length) {
                        dns.setServers(newServers);
                        this.resolve6 = resolve6;
                        this.dnsOptional = dnsOptional;
                        this.dnsServer = newServers.join();
                    }
                }
                if (newConf.inspect || newConf.inspectBrk) {
                    this.inspectMode = true;
                    process.env.PFORK_MODE = 'inline';
                }
                variableProperties.forEach(name => {
                    this[name] = newConf[name] || pkgInfo[name];
                });
                const shadowRules = parseString(newConf.shadowRules);
                const resolveShadowValues = (obj) => {
                    if ((!obj.rules || typeof obj.rules === 'string') && obj.values && typeof obj.values !== 'string') {
                        this.shadowRules = obj.rules.trim();
                        if (Object.keys(obj.values).length) {
                            this.shadowValues = obj.values;
                        }
                    }
                    else {
                        this.rules = extend({}, newConf.rules, obj);
                    }
                };
                if (typeof shadowRules === 'string') {
                    this.shadowRules = shadowRules.trim();
                }
                else if (Array.isArray(shadowRules)) {
                    if (typeof shadowRules[0] === 'string') {
                        this.shadowRules = shadowRules[0].trim();
                        if (shadowRules[1]) {
                            this.rules = extend({}, newConf.rules, shadowRules[1]);
                        }
                        if (shadowRules[2]) {
                            this.values = extend({}, newConf.values, shadowRules[2]);
                        }
                    }
                    else if (shadowRules[0]) {
                        resolveShadowValues(shadowRules[0]);
                        if (shadowRules[1]) {
                            this.values = extend({}, newConf.values, shadowRules[1]);
                        }
                    }
                    else if (shadowRules[1]) {
                        this.values = extend({}, newConf.values, shadowRules[1]);
                    }
                }
                else if (shadowRules) {
                    resolveShadowValues(shadowRules);
                }
                let extra = newConf.extra;
                if (extra && typeof extra === 'string') {
                    extra = /^\s*\{[\w\W]*\}\s*$/.test(extra) ? extra : readFileText(extra);
                    try {
                        extra = extra && JSON.parse(extra);
                        if (extra && typeof extra === 'object') {
                            this.pluginsDataMap = extend({}, this.pluginsDataMap, extra);
                        }
                    }
                    catch (e) { }
                    extra = null;
                }
                const customHandler = newConf.customHandler || newConf.customHandle;
                if (typeof customHandler === 'function') {
                    this.customHandler = customHandler;
                }
                if (newConf.realPort && isPort(newConf.realPort) && this.realPort != this.port) {
                    this.realPort = newConf.realPort;
                }
                const realHost = newConf.realHost;
                if (typeof realHost === 'string' && (!realHost || /^[\w.-]+$/.test(realHost))) {
                    this.realHost = newConf.realHost;
                }
                const socksPort = getHostPort(newConf.socksPort);
                if (socksPort) {
                    this.socksPort = socksPort.port;
                    this.socksHost = socksPort.host;
                }
                const httpPort = getHostPort(newConf.httpPort);
                if (httpPort) {
                    this.httpPort = httpPort.port;
                    this.httpHost = httpPort.host;
                }
                const httpsPort = getHostPort(newConf.httpsPort);
                if (httpsPort) {
                    this.httpsPort = httpsPort.port;
                    this.httpsHost = httpsPort.host;
                }
                if (newConf.host && typeof newConf.host === 'string') {
                    this.defaultHost = newConf.host;
                }
                if (typeof newConf.authKey === 'string') {
                    this.authKey = newConf.authKey;
                }
                if (typeof newConf.guestAuthKey === 'string') {
                    this.guestAuthKey = newConf.guestAuthKey;
                }
                if (newConf.reqCacheSize !== undefined && newConf.reqCacheSize > 0) {
                    this.reqCacheSize = newConf.reqCacheSize;
                }
                if (newConf.frameCacheSize !== undefined && newConf.frameCacheSize > 0) {
                    this.frameCacheSize = newConf.frameCacheSize;
                }
                this.allowMultipleChoice = newConf.allowMultipleChoice;
                if (typeof newConf.mode === 'string') {
                    const mode = newConf.mode.trim().split(/\s*[|,&]\s*/);
                    mode.forEach(m => {
                        m = m.trim();
                        if (/^(pureProxy|debug|master|disableAuthUI|captureData|headless|strict|proxyServer|encrypted|noGzip|disableUpdateTips|proxifier2?)$/.test(m)) {
                            this[m] = true;
                        }
                        else if (m === 'showPluginReq') {
                            this.showPluginReq = this.debugMode;
                        }
                        else if (m === 'disableCustomCerts') {
                            this.disableCustomCerts = true;
                        }
                        else if (m === 'nohost' || m === 'multienv' || m === 'multiEnv') {
                            this[m] = true;
                            this.multiEnv = true;
                        }
                        else if (m === 'proxyOnly') {
                            this.pureProxy = true;
                        }
                        else if (m === 'useMultipleRules' || m === 'enableMultipleRules') {
                            this.allowMultipleChoice = true;
                        }
                        else if (m === 'disableMultipleRules') {
                            this.allowMultipleChoice = false;
                        }
                        else if (m === 'notAllowDisableRules' || m === 'notAllowedDisableRules') {
                            this.notAllowedDisableRules = true;
                        }
                        else if (m === 'disableBackOption' || m === 'disabledBackOption') {
                            this.disabledBackOption = true;
                        }
                        else if (m === 'disableMultipleOption' || m === 'disabledMultipleOption') {
                            this.disabledMultipleOption = true;
                        }
                        else if (m === 'disableRulesOptions' || m === 'disabledRulesOptions') {
                            this.disabledRulesOptions = true;
                            this.disabledBackOption = true;
                            this.disabledMultipleOption = true;
                            this.notAllowedDisableRules = true;
                        }
                        else if (m === 'notAllowDisablePlugins' || m === 'notAllowedDisablePlugins') {
                            this.notAllowedDisablePlugins = true;
                        }
                        else if (m === 'socks') {
                            this.socksMode = true;
                        }
                        else if (m === 'network') {
                            this.networkMode = true;
                        }
                        else if (m === 'shadowRules') {
                            this.shadowRulesMode = true;
                        }
                        else if (m === 'shadowRulesOnly') {
                            this.shadowRulesMode = true;
                            this.disableWebUI = true;
                        }
                        else if (m === 'plugins') {
                            this.pluginsMode = true;
                        }
                        else if (m === 'pluginsOnly') {
                            this.pluginsOnlyMode = true;
                        }
                        else if (m === 'rules') {
                            this.rulesMode = true;
                        }
                        else if (m === 'rulesOnly') {
                            this.rulesOnlyMode = true;
                        }
                        else if (m === 'httpProxy') {
                            this.pureProxy = true;
                        }
                        else if (m === 'keepXFF' || m === 'x-forwarded-for' || m === 'forwardedFor') {
                            this.keepXFF = true;
                        }
                        else if (m === 'x-forwarded-host') {
                            this.enableFwdHost = true;
                        }
                        else if (m === 'x-forwarded-proto') {
                            this.enableFwdProto = true;
                        }
                        else if (m === 'INADDR_ANY') {
                            this.INADDR_ANY = true;
                        }
                        else if (m === 'buildIn' || m === 'build-in') {
                            process.env.PFORK_EXEC_PATH = process.execPath;
                        }
                        else if (m === 'safe' || m === 'rejectUnauthorized') {
                            this.rejectUnauthorized = true;
                        }
                        else if (['capture', 'intercept', 'enable-capture', 'enableCapture'].indexOf(m) !== -1) {
                            this.isEnableCapture = true;
                        }
                        else if (['disable-capture', 'disableCapture'].indexOf(m) !== -1) {
                            this.isEnableCapture = false;
                        }
                        else if (['http2', 'enable-http2', 'enableHttp2', 'enable-h2', 'enableH2'].indexOf(m) !== -1) {
                            this.isEnableHttp2 = true;
                        }
                        else if (['disable-http2', 'disableHttp2', 'disable-h2', 'disableH2'].indexOf(m) !== -1) {
                            this.isEnableHttp2 = false;
                        }
                        else if (m === 'hideLeftBar' || m === 'hideLeftMenu') {
                            this.hideLeftMenu = true;
                        }
                        else if (DATA_KEY_RE.test(m)) {
                            const type = RegExp.$1;
                            const override = RegExp.$2 === '=';
                            const key = RegExp.$3.toLowerCase();
                            switch (type) {
                                case 'clientip':
                                    this.overCipKey = override;
                                    this.cipKey = key;
                                    break;
                                case 'clientid':
                                    this.overCidKey = override;
                                    this.cidKey = key;
                                    break;
                                default:
                                    this.overTdKey = override;
                                    this.tdKey = key;
                                    break;
                            }
                        }
                    });
                    if (this.headless) {
                        this.noGlobalPlugins = true;
                        this.pluginsOnlyMode = true;
                        this.disableWebUI = true;
                        delete this.rulesOnlyMode;
                    }
                    else if (this.shadowRulesMode) {
                        this.networkMode = true;
                        delete this.rulesOnlyMode;
                        delete this.pluginsOnlyMode;
                    }
                    if (this.rulesOnlyMode) {
                        delete this.pluginsOnlyMode;
                        delete this.networkMode;
                        delete this.pluginsMode;
                        this.rulesMode = true;
                    }
                    else if (this.pluginsOnlyMode) {
                        delete this.networkMode;
                        this.rulesMode = true;
                        this.pluginsMode = true;
                    }
                    else if (this.networkMode) {
                        delete this.rulesMode;
                        delete this.pluginsMode;
                    }
                    else if (this.rulesMode) {
                        delete this.pluginsMode;
                        delete this.networkMode;
                    }
                }
                if (newConf.timeout && /^\d+$/.test(`${newConf.timeout}`)) {
                    this.timeout = +newConf.timeout;
                }
                this.setGuestAuth(newConf);
                this.disableAllRules = newConf.disableAllRules;
                this.disableAllPlugins = newConf.disableAllPlugins;
                if (newConf.replaceExistRule === false) {
                    this.replaceExistRule = false;
                }
                else {
                    this.replaceExistRule = newConf.replaceRules;
                }
                if (newConf.replaceExistValue === false) {
                    this.replaceExistValue = false;
                }
                else {
                    this.replaceExistValue = newConf.replaceValues;
                }
                if (newConf.certDir && typeof newConf.certDir === 'string') {
                    this.certDir = path.resolve(newConf.certDir);
                }
                const mw = newConf.middlewares || newConf.middleware;
                if (typeof mw === 'string') {
                    this.middlewares = mw.trim().split(/\s*,\s*/);
                }
                const secureFilter = getSecureFilter(newConf.secureFilter);
                if (typeof secureFilter === 'function') {
                    this.secureFilter = secureFilter;
                }
                this.notUninstallPluginPaths = this.getPaths(newConf.notUninstallPluginPath || newConf.notUninstallPluginPaths);
                this.pluginPaths = this.getPaths(newConf.pluginPaths || newConf.pluginsPath || newConf.pluginPath);
                this.prePluginsPath = this.projectPluginPaths = this.getPaths(newConf.projectPluginPaths || newConf.projectPluginsPath || newConf.projectPluginPath);
                this.accountPluginsPath = this.getPaths(newConf.accountPluginsPath);
                this.customPluginPaths = this.getPaths(newConf.customPluginPaths || newConf.customPluginsPath || newConf.customPluginPath, true);
                this.addon = this.getPaths(newConf.addonsPath || newConf.addonPath || newConf.addon);
                if (this.accountPluginsPath) {
                    this.customPluginPaths = this.accountPluginsPath.concat(this.customPluginPaths || []);
                }
                if (this.customPluginPaths) {
                    this.prePluginsPath = (this.prePluginsPath || []).concat(this.customPluginPaths);
                }
                let pluginHost = newConf.pluginHost;
                if (typeof pluginHost === 'string' && (pluginHost = pluginHost.trim())) {
                    pluginHost = qs.parse(pluginHost);
                    Object.keys(pluginHost).forEach(name => {
                        let host = pluginHost[name];
                        if (typeof host === 'string' && (host = host.trim())) {
                            host = host.toLowerCase().split(/\s*[|,&]\s*/);
                            host.forEach((h) => {
                                this.pluginHostMap[h] = name;
                            });
                        }
                    });
                }
                const port = getHostPort(newConf.port);
                if (port) {
                    this.host = port.host;
                    this.uiport = this.port = port.port;
                }
                if (this.disableWebUI) {
                    this.notAllowedDisablePlugins = true;
                }
                else {
                    const uiPort = getHostPort(newConf.uiport);
                    if (uiPort) {
                        this.customUIPort = uiPort.port != this.port;
                        this.uiport = uiPort.port;
                        this.uihost = uiPort.host;
                    }
                }
            }
            if (!this.rulesMode) {
                this.captureData = true;
            }
            if (!this.authKey) {
                this.authKey = 'auto_' + (Date.now() + Math.random().toFixed(6));
            }
            this.middlewares = Array.isArray(this.middlewares) ? this.middlewares.filter(item => !!item).map(resolvePath) : [];
            this.uiHostList = [];
            if (typeof this.localUIHost === 'string') {
                const localHostList = this.localUIHost.toLowerCase().split(/\s*[|,&]\s*/);
                localHostList.forEach(hostname => {
                    hostname = getHostname(hostname);
                    if (hostname && LOCAL_UI_HOST_LIST.indexOf(hostname) == -1) {
                        this.uiHostList.push(hostname);
                    }
                });
                LOCAL_UI_HOST_LIST.push.apply(LOCAL_UI_HOST_LIST, this.uiHostList);
                // 兼容老版本
                this.customLocalUIHost = this.uiHostList[0];
            }
            this.localUIHost = 'local.whistlejs.com';
            this.sockets = Math.max(this.sockets || 0, 1);
            if (this.strict) {
                this.sockets = Math.max(this.sockets, 360);
            }
            this.agentConfig = {
                maxSockets: this.sockets,
                keepAlive: true,
                keepAliveMsecs: KEEP_ALIVE_MSECS,
                maxFreeSockets: 0
            };
            // node 11及以上版本缓存连接有问题，先禁掉
            disableAgent = disableAgent || this.debug;
            this.httpAgent = disableAgent ? false : createAgent(this.agentConfig);
            this.httpsAgent = disableAgent ? false : createAgent(this.agentConfig, true);
            let baseDir = this.baseDir
                ? path.resolve(this.getHomePath(this.baseDir), this.dataDirname)
                : this.getDataDir(this.dataDirname);
            const customDirs = path.join(baseDir, 'custom_dirs');
            this.baseDir = baseDir;
            this.storage = this.storage && encodeURIComponent(this.storage);
            if (this.storage) {
                baseDir = path.join(customDirs, this.storage);
            }
            fse.ensureDirSync(baseDir);
            this.baseDirHash = createHash(baseDir);
            if (this.password) {
                this.passwordHash = createHash(this.password);
            }
            this.rulesDir = path.join(baseDir, 'rules');
            this.valuesDir = path.join(baseDir, 'values');
            this.propertiesDir = path.join(baseDir, 'properties');
            if (this.storage && newConf?.copy) {
                const copyDir = typeof newConf.copy === 'string' && encodeURIComponent(newConf.copy);
                if (copyDir !== this.storage) {
                    const dataDir = copyDir ? path.join(customDirs, copyDir) : this.baseDir;
                    const rulesDir = path.join(dataDir, 'rules');
                    const valuesDir = path.join(dataDir, 'values');
                    const propsDir = path.join(dataDir, 'properties');
                    fse.ensureDirSync(rulesDir);
                    fse.ensureDirSync(valuesDir);
                    fse.ensureDirSync(propsDir);
                    fse.copySync(rulesDir, this.rulesDir);
                    fse.copySync(valuesDir, this.valuesDir);
                    fse.copySync(propsDir, this.propertiesDir);
                }
            }
            const clientIdFile = path.join(this.baseDir, '.clientid');
            let clientId = readFileText(clientIdFile);
            if (!clientId) {
                clientId = [Date.now(), Math.random(), Math.random(), Math.random(), Math.random(), Math.random()].join();
                fs.writeFileSync(clientIdFile, clientId);
            }
            this.clientId = clientId;
            this.LOCAL_FILES = path.join(this.baseDir, 'local_files');
            fse.ensureDirSync(this.LOCAL_FILES);
            if (!this.inited) {
                debug('Invoke inited hooks: ' + this.initedHooks.length);
                this.initedHooks.map(item => item(this));
                this.inited = true;
            }
            return this;
        };
        /** 添加配置初始化后的处理钩子 */
        this.addInitHook = (hook) => {
            if (this.initedHooks.every(item => item !== hook)) {
                this.initedHooks.push(hook);
                if (this.inited)
                    hook(this);
            }
        };
        this.getSocksAgent = (options) => {
            const key = getCacheKey(options, true);
            let agent = socksAgents.get(key);
            if (agent) {
                return agent;
            }
            extend(options, this.agentConfig);
            options.proxyPort = parseInt(options.proxyPort, 10) || 1080;
            options.rejectUnauthorized = this.rejectUnauthorized;
            options.localDNS = false;
            options.auths = this.getAuths(options);
            agent = options.isHttps ? new socks.HttpsAgent(options) : new socks.HttpAgent(options);
            socksAgents.set(key, agent);
            agent.on('free', preventThrowOutError);
            return agent;
        };
        this.setModified = (clientId, isRules) => {
            if (isRules) {
                this.mrulesClientId = clientId || '';
                this.mrulesTime = Date.now();
            }
            else {
                this.mvaluesClientId = clientId || '';
                this.mvaluesTime = Date.now();
            }
        };
        this.getAuths = (_url) => {
            const options = typeof _url === 'string' ? url.parse(_url) : _url;
            if (!options || !options.auth) {
                return [socks.auth.None()];
            }
            const auths = [];
            options.auth.split('|').forEach(function (auth) {
                auth = auth.trim();
                if (auth) {
                    const index = auth.indexOf(':');
                    auths.push({
                        username: index == -1 ? auth : auth.substring(0, index),
                        password: index == -1 ? '' : auth.substring(index + 1)
                    });
                }
            });
            return auths.length
                ? auths.map(function (auth) {
                    return socks.auth.UserPassword(auth.username, auth.password);
                })
                : [socks.auth.None()];
        };
        this.setAuth = (auth) => {
            if (auth) {
                this.username = getString(auth.username);
                const password = (this.password = getString(auth.password));
                this.passwordHash = password && createHash(password);
                this.setGuestAuth(auth);
            }
            return this;
        };
        this.getPluginData = (name) => {
            const pluginsDataMap = name && this.pluginsDataMap;
            if (!pluginsDataMap) {
                return;
            }
            const index = name.indexOf('whistle.');
            if (index !== -1) {
                name = name.substring(index + 8);
            }
            return pluginsDataMap[name];
        };
        this.setGuestAuth = (auth) => {
            if (!auth)
                return;
            if (auth.guestName === '-' && !auth.guestPassword) {
                this.guest = {};
            }
            else if (auth.guestName && auth.guestPassword) {
                this.guest = {
                    username: auth.guestName,
                    password: auth.guestPassword
                };
            }
            else if (auth.guest) {
                this.guest = auth.guest;
            }
        };
        this.setUIHost = (host) => {
            customUIHost = parseHost(host);
        };
        this.setPluginUIHost = (pluginName, host) => {
            if (!pluginName || !WHISTLE_PLUGIN_RE.test(pluginName)) {
                return;
            }
            pluginName = RegExp.$1;
            host = parseHost(host);
            if (host) {
                customPluginNameHost[pluginName] = host;
                host.forEach((h) => {
                    delete customHostPluginMap[h];
                });
            }
            else {
                delete customPluginNameHost[pluginName];
            }
            customHostPluginMap = {};
            Object.keys(customPluginNameHost).forEach(name => {
                const list = customPluginNameHost[name];
                list &&
                    list.forEach((h) => {
                        customHostPluginMap[h] = name;
                    });
            });
        };
        this.toBuffer = (buf) => {
            if (buf == null || Buffer.isBuffer(buf)) {
                return buf;
            }
            buf += '';
            return Buffer.from(buf);
        };
        this.setHeader = (headers, name, value) => {
            const keys = Object.keys(headers);
            for (let i = 0, len = keys.length; i < len; i++) {
                const key = keys[i];
                if (key.toLowerCase() === name) {
                    headers[key] = value;
                    return;
                }
            }
            headers[name] = value;
        };
        this.connect = (options, cb) => {
            const headers = options.headers || {};
            const proxyOptions = {
                method: 'CONNECT',
                agent: false,
                proxyTunnelPath: options.proxyTunnelPath,
                enableIntercept: options.enableIntercept,
                path: getTunnelPath(headers),
                host: options.proxyHost,
                port: options.proxyPort,
                rejectUnauthorized: this.rejectUnauthorized,
                headers: headers
            };
            let httpModule = http;
            if (options.proxyServername) {
                proxyOptions.servername = options.proxyServername;
                httpModule = https;
            }
            let auth = options.proxyAuth || options.auth;
            if (auth) {
                auth = 'Basic ' + toBuffer(auth)?.toString('base64');
                this.setHeader(headers, 'proxy-authorization', auth);
            }
            const timer = setTimeout(function () {
                if (req) {
                    req.emit('error', new Error('Timeout'));
                    req.destroy();
                    req.socket && req.socket.destroy();
                }
            }, CONN_TIMEOUT);
            const req = httpModule.request(proxyOptions);
            req.on('error', noop);
            req
                .on('connect', function (res, socket) {
                clearTimeout(timer);
                socket.on('error', noop);
                if (res.statusCode !== 200) {
                    const err = new Error('Tunneling socket could not be established, statusCode=' + res.statusCode);
                    err.statusCode = res.statusCode;
                    socket.destroy();
                    process.nextTick(function () {
                        req.emit('error', err);
                    });
                    return;
                }
                if (res.headers['x-whistle-allow-tunnel-ack']) {
                    socket.write('1');
                }
                cb(socket, res);
            })
                .end();
            return req;
        };
        this.getPaths = (paths, isCustom) => {
            if (typeof paths === 'string') {
                paths = paths.trim().split(/\s*[|,;]\s*/);
            }
            else if (!Array.isArray(paths)) {
                return [];
            }
            const result = [];
            paths.forEach((path) => {
                if (isCustom && ['self', 'buildin', 'buildIn', 'build-in'].indexOf(path) !== -1) {
                    result.push(this.CUSTOM_PLUGIN_PATH);
                }
                else if (path && typeof path === 'string') {
                    result.push(path);
                }
            });
            return result.length ? result : [];
        };
        try {
            fse.ensureDirSync(this.CUSTOM_CERTS_DIR);
        }
        catch (e) { }
    }
}
// const config = new Config();
let async_id_symbol;
if (majorVersion < 16) {
    try {
        async_id_symbol = process.binding('async_wrap').async_id_symbol;
    }
    catch (e) { }
}
const emptyHandle = {
    asyncReset: noop,
    getAsyncId: noop
};
function createAgent(agentConfig, https) {
    const agent = new (https ? HttpsAgent : HttpAgent)(agentConfig);
    if (async_id_symbol) {
        const addRequest = agent.addRequest;
        agent.addRequest = function (req, options) {
            // fix: https://github.com/nodejs/node/issues/13539
            const freeSockets = this.freeSockets[this.getName(options)];
            if (freeSockets && freeSockets.length) {
                const socket = freeSockets[0];
                const handle = socket._handle;
                if (!handle) {
                    socket._handle = emptyHandle;
                }
                else if (typeof handle.asyncReset !== 'function') {
                    handle.asyncReset = noop;
                }
                const originalRef = socket.ref;
                socket.ref = function () {
                    socket.ref = originalRef;
                    if (socket._handle === emptyHandle) {
                        delete socket._handle;
                    }
                    else if (socket._handle.asyncReset === noop) {
                        delete socket._handle.asyncReset;
                    }
                    socket.ref();
                };
            }
            const onSocket = req.onSocket;
            req.onSocket = function (socket) {
                try {
                    socket[async_id_symbol] = socket._handle.getAsyncId();
                }
                catch (e) { }
                onSocket.apply(this, arguments);
            };
            addRequest.apply(this, arguments);
        };
    }
    return agent;
}
function capitalize(str) {
    return (str && str[0].toUpperCase()) + str.substring(1);
}
function getCacheKey(options, isSocks) {
    let auth = options.auth || options.proxyAuth;
    if (!auth) {
        const headers = options.headers || '';
        auth = headers['proxy-authorization'] || '';
    }
    const ip = (!isSocks && options.clientIp) || '';
    return [
        options.proxyServername ? 'https-proxy' : '',
        options.isHttps ? 'https' : 'http',
        options.proxyHost,
        options.proxyPort,
        auth,
        ip,
        options.proxyTunnelPath || '',
        (options.isHttps && options.cacheKey) || ''
    ].join(':');
}
function parseHost(host) {
    if (Array.isArray(host)) {
        return host.filter(function (h) {
            return h && typeof h === 'string';
        });
    }
    host = typeof host === 'string' ? host.trim() : '';
    return (host && host.split('|').map(getHostname)) || [];
}
function getTunnelPath(headers) {
    const host = headers.host || headers.Host;
    if (host) {
        return host;
    }
    const keys = Object.keys(headers);
    for (let i = 0, len = keys.length; i < len; i++) {
        const key = keys[i];
        if (key.toLowerCase() === 'host') {
            return headers[key];
        }
    }
}
function preventThrowOutError(socket) {
    if (socket.listeners('error').indexOf(freeSocketErrorListener) === -1) {
        socket.once('error', freeSocketErrorListener);
    }
}
function freeSocketErrorListener() {
    const socket = this;
    socket.destroy();
    socket.emit('agentRemove');
    socket.removeListener('error', freeSocketErrorListener);
}
function resolvePath(file) {
    if (!file || !(file = file.trim())) {
        return file;
    }
    return /^[\w-]+$/.test(file) ? file : path.resolve(file);
}
function getHostname(_url) {
    if (typeof _url !== 'string') {
        return '';
    }
    if (_url.indexOf('/') != -1) {
        return url.parse(_url).hostname || '';
    }
    const index = _url.indexOf(':');
    return index == -1 ? _url : _url.substring(0, index);
}
function getSecureFilter(secureFilter) {
    if (typeof secureFilter === 'function') {
        return secureFilter;
    }
    if (!secureFilter || typeof secureFilter !== 'string') {
        return;
    }
    try {
        // FIXME: 处理require的情况
        return require(secureFilter);
    }
    catch (e) { }
}
function getString(str) {
    return str && typeof str === 'string' ? str : '';
}
function createHash(str) {
    const shasum = crypto.createHash('sha1');
    shasum.update(str);
    return shasum.digest('hex');
}
function readFileText(filepath) {
    try {
        return fs.readFileSync(filepath, { encoding: 'utf8' }).trim();
    }
    catch (e) {
        return void 0;
    }
}
function getHostPort(str) {
    if (!str || !/^(?:([\w.-]+):)?([1-9]\d{0,4})$/.test(`${str}`)) {
        return;
    }
    return {
        host: RegExp.$1,
        port: parseInt(RegExp.$2, 10)
    };
}
function isPort(port) {
    return /^\d+$/.test(`${port}`) && port <= 65535 && port > 0;
}
function parseString(str) {
    str = str && typeof str === 'string' ? str.trim() : '';
    if (!str) {
        return '';
    }
    str = readFileText(str) || str;
    if (!/\s/.test(str) && str.indexOf('%') !== -1) {
        try {
            str = decodeURIComponent(str);
        }
        catch (e) { }
    }
    if (/^\{[\s\S]+\}$/.test(str) || /^\[[\s\S]+\]$/.test(str)) {
        try {
            return json5.parse(str);
        }
        catch (e) { }
    }
    return str;
}
function getPluginList(list) {
    if (typeof list === 'string') {
        list = list.trim().split(/\s*[,|]\s*/);
    }
    let result = [];
    if (Array.isArray(list)) {
        list.forEach(function (name) {
            if (WHISTLE_PLUGIN_RE.test(name)) {
                result = result || [];
                result.push(RegExp.$1);
            }
        });
    }
    return result;
}
export default new Config();
