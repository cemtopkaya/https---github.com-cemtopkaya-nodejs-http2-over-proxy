import colors from 'colors/safe';
import createDebug from 'debug';
import { fork, kill } from 'pfork';
import { EventEmitter, LRU, extend, fs, fse, http, path } from '../import-pkg';
import * as util from '../util';
import logger from '../util/logger';
import config from '../config';
import * as rulesMgr from '../rules';
import RulesMgr from '../rules/rules';
import { properties } from '../rules/util';
import * as httpMgr from '../util/http-mgr';
import * as protocols from '../rules/protocols';
import getPlugins from './get-plugins';
import getPluginsSync from './get-plugins-sync';
import * as pluginUtil from './util';
const debug = createDebug('@w2.lib.plugins.plugin-mgr');
const encodeURIComponent = util.encodeURIComponent;
const REMOTE_RULES_RE = /^\s*@(`?)(whistle\.[a-z\d_\-]+(?:\/[^\s#]*)?|(?:https?:\/\/|[a-z]:[\\/]|~?\/)[^\s#]+|\$(?:whistle\.)?[a-z\d_-]+[/:][^\s#]+)\s*?\1(?:#.*)?$/im;
const PLUGIN_MAIN = path.join(__dirname, './load-plugin');
const PIPE_PLUGIN_RE = /^pipe:\/\/(?:whistle\.|plugin\.)?([a-z\d_\-]+)(?:\(([\s\S]*)\))?$/;
const RULE_VALUE_HEADER = 'x-whistle-rule-value';
const SNI_VALUE_HEADER = 'x-whistle-sni-value';
const GLOBAL_PLUGIN_VARS_HEAD = 'x-whistle-global-plugin-vars' + config.uid;
const PLUGIN_VARS_HEAD = 'x-whistle-plugin-vars' + config.uid;
const RULE_URL_HEADER = 'x-whistle-rule-url';
const ETAG_HEADER = 'x-whistle-etag';
const MAX_AGE_HEADER = 'x-whistle-max-age';
const FULL_URL_HEADER = 'x-whistle-full-url';
const REAL_URL_HEADER = 'x-whistle-real-url';
const RELATIVE_URL_HEADER = 'x-whistle-relative-url';
const EXTRA_URL_HEADER = 'x-whistle-extra-url';
const UI_REQUEST_HEADER = 'x-whistle-auth-ui-request';
const REQ_ID_HEADER = 'x-whistle-req-id';
const PIPE_VALUE_HEADER = 'x-whistle-pipe-value';
const CUSTOM_PARSER_HEADER = 'x-whistle-frame-parser';
const STATUS_CODE_HEADER = 'x-whistle-status-code';
const PLUGIN_REQUEST_HEADER = 'x-whistle-plugin-request';
const LOCAL_HOST_HEADER = 'x-whistle-local-host';
const PROXY_VALUE_HEADER = 'x-whistle-proxy-value';
const PAC_VALUE_HEADER = 'x-whistle-pac-value';
const METHOD_HEADER = 'x-whistle-method';
const SHOW_LOGIN_BOX = 'x-whistle2-show-login-box.' + config.uid;
const FROM_TUNNEL_HEADER = 'x-whistle-from-tunnel-req-' + config.uid;
const CLIENT_PORT_HEAD = config.CLIENT_PORT_HEAD;
const HOST_IP_HEADER = 'x-whistle-host-ip';
const GLOBAL_VALUE_HEAD = 'x-whistle-global-value';
const SERVER_NAME_HEAD = 'x-whistle-server-name';
const COMMON_NAME_HEAD = 'x-whistle-common-name';
const CERT_CACHE_INFO = 'x-whistle-cert-cache-info';
const STATUS_ERR = new Error('Non 200');
const INTERVAL = 6000;
const CHECK_INTERVAL = 1000 * 60 * 60;
const MAX_CERT_SIZE = 72 * 1024;
const portsField = typeof Symbol === 'undefined' ? '_ports' : Symbol('_ports'); // eslint-disable-line
const UTF8_OPTIONS = { encoding: 'utf8' };
let allPlugins = {};
const authPlugins = [];
const tunnelKeys = [];
const LOCALHOST = '127.0.0.1';
const MAX_RULES_LENGTH = 1024 * 256;
const rulesCache = new LRU({ max: 36 });
const CUSTOM_CERT_HEADER = config.CUSTOM_CERT_HEADER;
const ENABLE_CAPTURE_HEADER = config.ENABLE_CAPTURE_HEADER;
const PLUGIN_HOOKS = config.PLUGIN_HOOKS;
const PLUGIN_HOOK_NAME_HEADER = config.PLUGIN_HOOK_NAME_HEADER;
const HTTP_RE = /^https?:\/\//;
const conf = {};
const PLUGIN_RULE_RE = /^([a-z\d_\-]+)(?:\(([\s\S]*)\))?$/;
const PLUGIN_RULE_RE2 = /^(?:\w+\.)?([a-z\d_\-]+)(?:\:\/\/([\s\S]*))?$/;
const PLUGIN_RE = /^plugin:\/\//;
const PLUGIN_KEY_RE = /^\$(?:whistle\.)?([a-z\d_-]+)[/:]([\S\s]+)$/;
const MAX_VALUE_LEN = 1024 * 1024 * 16;
const EXCLUDE_CONF_KEYS = {
    uid: 1,
    INTERNAL_ID: 1,
    SNI_PLUGIN_HEADER: 1,
    WEBUI_HEAD: 1,
    CLIENT_INFO_HEAD: 1,
    COMPOSER_CLIENT_ID_HEADER: 1,
    TEMP_TUNNEL_DATA_HEADER: 1
};
const EXCLUDE_NAMES = {
    password: 1,
    shadowRules: 1,
    rules: 1,
    values: 1
};
const debugMode = config.debugMode;
let whistleProxy;
const getPlugin = (cb) => {
    const notLoadPlugins = config.networkMode || config.rulesOnlyMode;
    notLoadPlugins ? cb({}) : getPlugins(cb);
};
config.addInitHook(() => {
    const notLoadPlugins = config.networkMode || config.rulesOnlyMode;
    allPlugins = notLoadPlugins ? {} : getPluginsSync();
    debug('set plugin conf after config inited, ', Object.keys(allPlugins));
    Object.keys(config).forEach(name => {
        if (EXCLUDE_NAMES[name]) {
            return;
        }
        const value = config[name];
        if (name === 'passwordHash') {
            conf.password = value;
        }
        if (name === 'globalData') {
            conf.globalData = value;
        }
        else if (!EXCLUDE_CONF_KEYS[name]) {
            const type = typeof value;
            if (type == 'string' || type == 'number' || type === 'boolean') {
                conf[name] = value;
            }
        }
    });
    conf.PLUGIN_HOOKS = config.PLUGIN_HOOKS;
    conf.uiHostList = config.uiHostList;
    const pluginHostMap = config.pluginHostMap;
    const pluginHosts = (conf.pluginHosts = {});
    if (pluginHostMap) {
        Object.keys(pluginHostMap).forEach(host => {
            const name = pluginHostMap[host];
            const list = (pluginHosts[name] = pluginHosts[name] || []);
            list.push(host);
        });
    }
});
export class PluginMgr extends EventEmitter {
    constructor() {
        super();
        this.getTunnelKeys = () => {
            return tunnelKeys;
        };
        this.updateRules = () => {
            this.emit('updateRules');
        };
        this.loadCert = (req, plugin, callback) => {
            this.loadPlugin(plugin, (err, ports) => {
                if (err || !ports || !ports.sniPort) {
                    return callback();
                }
                const options = this.getOptions(req);
                options.maxLength = MAX_CERT_SIZE;
                options.headers[PLUGIN_HOOK_NAME_HEADER] = PLUGIN_HOOKS.SNI;
                options.headers[SERVER_NAME_HEAD] = encodeURIComponent(req.serverName);
                options.headers[COMMON_NAME_HEAD] = encodeURIComponent(req.commonName);
                if (!req.useSNI || req.isHttpsServer) {
                    options.headers[config.SNI_TYPE_HEADER] = req.isHttpsServer ? '1' : '0';
                }
                if (req.sniRuleValue) {
                    options.headers[SNI_VALUE_HEADER] = encodeURIComponent(req.sniRuleValue);
                }
                if (req.hasCertCache) {
                    options.headers[CERT_CACHE_INFO] = req.hasCertCache;
                }
                options.port = ports.sniPort;
                requestPlugin(options, (err, body, res) => {
                    if (err || res.statusCode !== 200) {
                        return callback(err || STATUS_ERR);
                    }
                    if (!body) {
                        return callback();
                    }
                    if (body === 'false') {
                        return callback(false);
                    }
                    if (body === 'true') {
                        return callback(true);
                    }
                    try {
                        body = JSON.parse(body);
                        if (!body || !body.name || !util.isString(body.key) || !util.isString(body.cert)) {
                            return callback();
                        }
                        callback({
                            key: body.key,
                            cert: body.cert,
                            name: body.name,
                            mtime: body.mtime > 0 ? body.mtime : undefined
                        });
                    }
                    catch (e) {
                        callback(e);
                    }
                });
            });
        };
        this.addRuleHeaders = (req, rules, headers, isPipe) => {
            headers = headers || req.headers;
            addPluginHeaders(req, headers);
            if (req._isUIRequest) {
                headers[UI_REQUEST_HEADER] = '1';
                return headers;
            }
            rules = rules || '';
            const localHost = getValue(rules.host);
            if (localHost) {
                headers[LOCAL_HOST_HEADER] = localHost;
            }
            let rule = rules.rule;
            if (isPipe) {
                if (req._pipePlugin) {
                    rule = rule || rulesMgr.resolveRule(req);
                    let value;
                    if (rule) {
                        let name = req._pipePlugin.moduleName;
                        name = name.substring(name.indexOf('.') + 1) + '://';
                        if (rule.matcher.indexOf(name) === 0)
                            value = util.getMatcherValue(rule);
                    }
                    rule = { plugin: req._pipePlugin, value: value };
                }
                else {
                    rule = null;
                }
            }
            addPluginVars(req, headers, rule);
            const proxyRule = getValue(rules.proxy);
            if (proxyRule) {
                headers[PROXY_VALUE_HEADER] = proxyRule;
            }
            const pac = getValue(rules.pac);
            if (pac) {
                headers[PAC_VALUE_HEADER] = pac;
            }
            if (req._pipeValue) {
                headers[PIPE_VALUE_HEADER] = encodeURIComponent(req._pipeValue);
            }
            if (req.customParser) {
                headers[CUSTOM_PARSER_HEADER] = req.customParser;
            }
            else {
                delete headers[CUSTOM_CERT_HEADER];
            }
            if (req.globalValue) {
                headers[GLOBAL_VALUE_HEAD] = encodeURIComponent(req.globalValue);
            }
            return headers;
        };
        this.loadPlugin = (plugin, callback) => {
            const s = Date.now();
            if (!plugin) {
                return callback(null, '');
            }
            debug('loadPlugin ~ plugin path:%s', plugin.path);
            const ports = plugin[portsField];
            if (ports) {
                return callback(null, ports);
            }
            util.getBoundIp(config.host, (host) => {
                conf.host = host || LOCALHOST;
                const moduleName = plugin.moduleName;
                const name = moduleName.substring(moduleName.indexOf('/') + 1);
                const isInline = config.inspectMode || process.env.PFORK_MODE === 'inline';
                fork({
                    data: config.getPluginData(moduleName),
                    _inspect: config.inspectMode,
                    name: moduleName,
                    script: PLUGIN_MAIN,
                    value: plugin.path,
                    version: plugin.version,
                    staticDir: plugin.staticDir,
                    CUSTOM_CERT_HEADER: CUSTOM_CERT_HEADER,
                    ENABLE_CAPTURE_HEADER: ENABLE_CAPTURE_HEADER,
                    RULE_VALUE_HEADER: RULE_VALUE_HEADER,
                    SNI_VALUE_HEADER: SNI_VALUE_HEADER,
                    GLOBAL_PLUGIN_VARS_HEAD: GLOBAL_PLUGIN_VARS_HEAD,
                    PLUGIN_VARS_HEAD: PLUGIN_VARS_HEAD,
                    RULE_URL_HEADER: RULE_URL_HEADER,
                    MAX_AGE_HEADER: MAX_AGE_HEADER,
                    ETAG_HEADER: ETAG_HEADER,
                    FULL_URL_HEADER: FULL_URL_HEADER,
                    REAL_URL_HEADER: REAL_URL_HEADER,
                    RELATIVE_URL_HEADER: RELATIVE_URL_HEADER,
                    EXTRA_URL_HEADER: EXTRA_URL_HEADER,
                    REQ_ID_HEADER: REQ_ID_HEADER,
                    PIPE_VALUE_HEADER: PIPE_VALUE_HEADER,
                    CUSTOM_PARSER_HEADER: CUSTOM_PARSER_HEADER,
                    STATUS_CODE_HEADER: STATUS_CODE_HEADER,
                    PLUGIN_REQUEST_HEADER: PLUGIN_REQUEST_HEADER,
                    LOCAL_HOST_HEADER: LOCAL_HOST_HEADER,
                    HOST_VALUE_HEADER: LOCAL_HOST_HEADER,
                    PROXY_VALUE_HEADER: PROXY_VALUE_HEADER,
                    PAC_VALUE_HEADER: PAC_VALUE_HEADER,
                    METHOD_HEADER: METHOD_HEADER,
                    SHOW_LOGIN_BOX: SHOW_LOGIN_BOX,
                    FROM_TUNNEL_HEADER: FROM_TUNNEL_HEADER,
                    CLIENT_IP_HEADER: config.CLIENT_IP_HEAD,
                    CLIENT_PORT_HEAD: CLIENT_PORT_HEAD,
                    UI_REQUEST_HEADER: UI_REQUEST_HEADER,
                    GLOBAL_VALUE_HEAD: GLOBAL_VALUE_HEAD,
                    SERVER_NAME_HEAD: SERVER_NAME_HEAD,
                    COMMON_NAME_HEAD: COMMON_NAME_HEAD,
                    CERT_CACHE_INFO: CERT_CACHE_INFO,
                    HOST_IP_HEADER: HOST_IP_HEADER,
                    debugMode: debugMode,
                    config: isInline ? extend(true, {}, conf) : conf // 防止 inline 时，子进程删除 conf
                }, (err, ports, child, first) => {
                    debug(`Load plugin <${name}> costime: ${Date.now() - s}, has error: %o`, err);
                    callback(err, ports);
                    if (!first) {
                        return;
                    }
                    if (err) {
                        whistleProxy.emit('pluginLoadError', err, name, moduleName);
                        logger.error(err);
                        const mode = process.env.PFORK_MODE;
                        if (debugMode || mode === 'inline' || mode === 'bind') {
                            console.log(err);
                        }
                    }
                    else {
                        whistleProxy.emit('pluginLoad', child, name, moduleName);
                        plugin[portsField] = ports;
                        child.on('close', () => {
                            delete plugin[portsField];
                        });
                    }
                });
            });
        };
        this.loadPluginByName = (name, callback) => {
            this.loadPlugin(this.getActivePluginByName(name), callback);
        };
        this.getActivePluginByName = (name) => {
            return this.isDisabled(name) ? null : allPlugins[name + ':'];
        };
        this.stopPlugin = (plugin) => {
            kill({
                script: PLUGIN_MAIN,
                value: plugin.path
            }, 10000);
        };
        this.getPlugins = () => {
            return allPlugins;
        };
        this.isDisabled = (name) => {
            if (config.notAllowedDisablePlugins) {
                return false;
            }
            if (properties.get('disabledAllPlugins')) {
                return true;
            }
            const disabledPlugins = properties.get('disabledPlugins') || {};
            return disabledPlugins[name];
        };
        this.getPlugin = (protocol) => {
            return this.isDisabled(protocol.slice(0, -1)) ? null : allPlugins[protocol];
        };
        this.getPluginByName = (name) => {
            return name && allPlugins[name + ':'];
        };
        this.getPluginByRuleUrl = (ruleUrl) => {
            if (!ruleUrl || typeof ruleUrl !== 'string') {
                return;
            }
            const index = ruleUrl.indexOf(':');
            if (index == -1) {
                return null;
            }
            const protocol = ruleUrl.substring(0, index + 1);
            return this.isDisabled(protocol.slice(0, -1)) ? null : allPlugins[protocol];
        };
        this.loadAuthPlugins = (req, callback) => {
            if (!authPlugins.length) {
                return callback();
            }
            req._isUIRequest = true;
            this._loadPlugins(authPlugins, (ports) => {
                ports = ports.map((port, i) => {
                    return {
                        authPort: port && port.authPort,
                        plugin: authPlugins[i]
                    };
                });
                const rest = ports.length;
                if (!rest) {
                    return callback();
                }
                const options = this.getOptions(req);
                authReq(true, ports, req, options, (forbidden) => {
                    if (!config.disableAuthUI && forbidden) {
                        if (req._redirectUrl || req._authHtmlUrl) {
                            return callback(req._redirectUrl, null, req._authHtmlUrl);
                        }
                        const status = req._authStatus ? (req._showLoginBox ? 401 : 403) : 502;
                        return callback(status, forbidden);
                    }
                    return callback();
                });
            });
        };
        this.resolvePipePlugin = (req, callback) => {
            if (req._pipePlugin == null) {
                let pipe;
                const hRules = req.headerRulesMgr;
                if (config.multiEnv) {
                    pipe = (hRules && hRules.resolvePipe(req)) || rulesMgr.resolvePipe(req);
                }
                else {
                    pipe = rulesMgr.resolvePipe(req) || (hRules && hRules.resolvePipe(req));
                }
                let plugin;
                req._pipeRule = pipe;
                if (pipe && PIPE_PLUGIN_RE.test(pipe.matcher)) {
                    req._pipeValue = RegExp.$2;
                    plugin = this.getPlugin(RegExp.$1 + ':');
                }
                req._pipePlugin = plugin || '';
            }
            this.loadPlugin(req._pipePlugin, (_, ports) => {
                req._pipePluginPorts = ports || '';
                callback(ports);
            });
        };
        this.postStats = (req, res) => {
            const plugins = req.whistlePlugins;
            const type = res ? '_postResStats' : '_postReqStats';
            if (!plugins || req.isPluginReq || req[type]) {
                return;
            }
            req[type] = true;
            this.loadPlugins(plugins, (ports) => {
                ports = ports
                    .map((port, i) => {
                    const plugin = plugins[i];
                    const statsPort = port && (res ? port.resStatsPort : port.statsPort);
                    if (!statsPort) {
                        return;
                    }
                    return {
                        plugin: plugin.plugin,
                        port: statsPort,
                        value: plugin.value,
                        url: plugin.url
                    };
                })
                    .filter(emptyFilter);
                if (!ports.length) {
                    return;
                }
                const options = this.getOptions(req, res, 'resRules');
                options.headers[PLUGIN_HOOK_NAME_HEADER] = PLUGIN_HOOKS[res ? 'RES_STATS' : 'REQ_STATS'];
                ports.forEach((item) => {
                    const opts = extend({}, options);
                    opts.headers = extend({}, options.headers);
                    opts.port = item.port;
                    addPluginVars(req, opts.headers, item);
                    const request = http.request(opts, (response) => {
                        response.on('error', util.noop);
                        response.on('data', util.noop);
                    });
                    request.on('error', util.noop);
                    request.end();
                });
            });
        };
        this.resolveWhistlePlugins = (req) => {
            const rules = req.rules;
            const plugins = [];
            const plugin = (req.pluginMgr = this.getPluginByRuleUrl(util.rule.getUrl(rules.rule)));
            if (plugin) {
                rules._pluginRule = rules.rule;
                const ruleValue = util.getMatcherValue(rules.rule);
                const ruleUrl = util.getUrlValue(rules.rule, true);
                plugins.push({
                    plugin: plugin,
                    value: ruleValue,
                    isRegExp: rules.rule.isRegExp,
                    rawPattern: rules.rule.rawPattern,
                    url: ruleUrl == ruleValue ? undefined : ruleUrl
                });
            }
            if (rules.plugin) {
                const _plugins = [plugin];
                rules.plugin.list.forEach((rule) => {
                    const info = this.getPluginByPluginRule(rule);
                    if (info && _plugins.indexOf(info.plugin) == -1) {
                        info.isRegExp = rule.isRegExp;
                        info.rawPattern = rule.rawPattern;
                        _plugins.push(info.plugin);
                        plugins.push(info);
                    }
                });
            }
            if (plugins.length) {
                req.whistlePlugins = plugins;
            }
            return plugin;
        };
        this.updatePluginRules = (name) => {
            name && httpMgr.forceUpdate('http://127.0.0.1:' + config.port + '/whistle.' + name + '/');
        };
        this.setProxy = (p) => {
            whistleProxy = p;
        };
        this.getWsPipe = (req, res, callback) => {
            req._websocketExtensions = res.headers['sec-websocket-extensions'] || '';
            this.getWsReqReadPipe(req, (reqRead) => {
                this.getWsReqWritePipe(req, (reqWrite) => {
                    this.getWsResReadPipe(req, res, (resReadStream) => {
                        this.getWsResWritePipe(req, res, (resWriteStream) => {
                            callback(reqRead, reqWrite, resReadStream, resWriteStream);
                        });
                    });
                });
            });
        };
        this.getTunnelPipe = (req, res, callback) => {
            this.getTunnelReqReadPipe(req, (reqRead) => {
                this.getTunnelReqWritePipe(req, (reqWrite) => {
                    this.getTunnelResReadPipe(req, res, (resRead) => {
                        this.getTunnelResWritePipe(req, res, (resWrite) => {
                            callback(reqRead, reqWrite, resRead, resWrite);
                        });
                    });
                });
            });
        };
        this.getRules = (req, callback) => {
            this.getRulesMgr('rules', req, null, this.getPluginRulesCallback(req, callback));
        };
        this.getResRules = (req, res, callback) => {
            req.curUrl = req.fullUrl;
            if (!req.resHeaders && res) {
                req.resHeaders = res.headers;
            }
            const resRules = rulesMgr.resolveResRules(req);
            const pRules = req.pluginRules && req.pluginRules.resolveResRules(req, true);
            const fRules = req.rulesFileMgr && req.rulesFileMgr.resolveResRules(req, true);
            const hRules = req.headerRulesMgr && req.headerRulesMgr.resolveResRules(req, true);
            fRules && util.mergeRules(req, fRules, true);
            config.multiEnv && util.mergeRules(req, resRules, true);
            hRules && util.mergeRules(req, hRules, true);
            pRules && util.mergeRules(req, pRules, true);
            !config.multiEnv && util.mergeRules(req, resRules, true);
            let resScriptRules;
            let resHeaderRules = res.headers[config.RES_RULES_HEAD];
            if (resHeaderRules) {
                try {
                    resHeaderRules = rulesToJson(decodeURIComponent(resHeaderRules));
                    if (resHeaderRules) {
                        resScriptRules = resScriptRules || [];
                        resScriptRules.push(resHeaderRules);
                    }
                }
                catch (e) { }
            }
            delete res.headers[config.RES_RULES_HEAD];
            rulesMgr.resolveResRulesFile(req, res, (result) => {
                if (result) {
                    resScriptRules = resScriptRules || [];
                    resScriptRules.push(result);
                }
                req.resScriptRules = resScriptRules;
                this.getRulesMgr('resRules', req, res, (pluginRulesMgr) => {
                    if (!pluginRulesMgr && resScriptRules) {
                        pluginRulesMgr = parseRulesList(req, resScriptRules, true);
                    }
                    req.resScriptRules = resScriptRules = null;
                    callback(pluginRulesMgr);
                });
            });
        };
        this.getTunnelRules = (req, callback) => {
            this.getRulesMgr('tunnelRules', req, null, this.getPluginRulesCallback(req, callback));
        };
        this.getRulesMgr = (type, req, res, callback) => {
            const plugins = req.whistlePlugins;
            if (!plugins) {
                return callback();
            }
            this.getRulesFromPlugins(type, req, res, callback);
        };
        this.getRulesFromPlugins = (type, req, res, callback) => {
            const plugins = req.whistlePlugins;
            this.loadPlugins(plugins, (ports) => {
                ports = ports.map((port, i) => {
                    const plugin = plugins[i];
                    return {
                        port: port && port[type + 'Port'],
                        authPort: port && port.authPort,
                        plugin: plugin.plugin,
                        isRegExp: plugin.isRegExp,
                        rawPattern: plugin.rawPattern,
                        value: plugin.value,
                        url: plugin.url
                    };
                });
                let rest = ports.length;
                if (!rest) {
                    return callback();
                }
                let results = [];
                const options = this.getOptions(req, res, type);
                const isResRules = type == 'resRules';
                const enableAuth = !isResRules &&
                    req.justAuth !== false &&
                    (!req.isPluginReq || req._isProxyReq) &&
                    (!req.fromTunnel || !util.isAuthCapture(req));
                authReq(enableAuth, ports, req, options, (forbidden) => {
                    if (forbidden) {
                        const noTunnel = !req.isTunnel;
                        req._authForbidden = true;
                        const mgr = new RulesMgr({ msg: forbidden });
                        if (noTunnel && req._authHtmlUrl) {
                            mgr.parse('* ignore://!method|!file|!http|!https method://get ' + req._authHtmlUrl);
                        }
                        else if (noTunnel && req._redirectUrl) {
                            mgr.parse('* ignore://!redirect redirect://' + req._redirectUrl);
                        }
                        else {
                            const status = req._authStatus ? (req._showLoginBox ? 401 : 403) : 502;
                            mgr.parse('* ignore://!statusCode|!resBody|!resType|!resCharset status://' +
                                status +
                                ' resBody://{msg} resType://html resCharset://utf8');
                        }
                        return callback(mgr);
                    }
                    if (req.justAuth) {
                        return callback();
                    }
                    const hookName = isResRules ? 'RES_RULES' : type === 'tunnelRules' ? 'TUNNEL_RULES' : 'REQ_RULES';
                    options.headers[PLUGIN_HOOK_NAME_HEADER] = PLUGIN_HOOKS[hookName];
                    const execCallback = () => {
                        if (--rest <= 0) {
                            if (req.resScriptRules) {
                                results = results.concat(req.resScriptRules);
                            }
                            callback(parseRulesList(req, results, isResRules));
                        }
                    };
                    ports.forEach((item, i) => {
                        const plugin = item.plugin;
                        if (!item.port) {
                            const rulesText = isResRules ? plugin.resRules : plugin._rules;
                            if (rulesText) {
                                results[i] = {
                                    text: rulesText,
                                    values: plugin[util.PLUGIN_VALUES],
                                    root: plugin.path
                                };
                            }
                            return execCallback();
                        }
                        const opts = getPluginReqOpts(item, req, options, item.port);
                        const cacheKey = plugin.moduleName + '\n' + type;
                        const data = rulesCache.get(cacheKey);
                        const updateMaxAge = (obj, age) => {
                            if (age >= 0) {
                                obj.maxAge = age;
                                obj.now = Date.now();
                            }
                        };
                        const handleRules = (err, body, values, raw, res) => {
                            if (err === false && data) {
                                body = data.body;
                                values = data.values;
                                raw = data.raw;
                                updateMaxAge(data, res && res.headers[MAX_AGE_HEADER]);
                            }
                            else if (res) {
                                const etag = res.headers[ETAG_HEADER];
                                const maxAge = res.headers[MAX_AGE_HEADER];
                                let newData = {};
                                if (maxAge >= 0) {
                                    updateMaxAge(newData, maxAge);
                                }
                                if (etag) {
                                    newData = newData || {};
                                    newData.etag = etag;
                                }
                                if (newData) {
                                    newData.body = body;
                                    newData.values = values;
                                    newData.raw = raw;
                                    rulesCache.set(cacheKey, newData);
                                }
                                else {
                                    rulesCache.del(cacheKey);
                                }
                            }
                            const pendingCallbacks = data && data.pendingCallbacks;
                            if (pendingCallbacks) {
                                delete data.pendingCallbacks;
                                pendingCallbacks.forEach((cb) => {
                                    cb(err, body, values, raw);
                                });
                            }
                            body = body || '';
                            if (isResRules) {
                                body += plugin.resRules ? '\n' + plugin.resRules : '';
                            }
                            else {
                                body += plugin._rules ? '\n' + plugin._rules : '';
                            }
                            if (body || values) {
                                const pluginVals = plugin[util.PLUGIN_VALUES];
                                if (values && pluginVals) {
                                    const vals = extend({}, pluginVals);
                                    values = extend(vals, values);
                                }
                                else {
                                    values = values || pluginVals;
                                }
                                results[i] = {
                                    text: body,
                                    values: values,
                                    root: plugin.path
                                };
                            }
                            execCallback();
                        };
                        delete opts.headers[ETAG_HEADER];
                        if (data) {
                            if (Date.now() - data.now <= data.maxAge) {
                                return handleRules(false);
                            }
                            if (data.etag) {
                                opts.headers[ETAG_HEADER] = data.etag;
                            }
                            if (data.maxAge >= 0) {
                                if (data.pendingCallbacks) {
                                    data.pendingCallbacks.push(handleRules);
                                    return;
                                }
                                data.pendingCallbacks = [];
                            }
                        }
                        opts.ignoreExceedError = true;
                        opts.maxLength = MAX_RULES_LENGTH;
                        requestRules(opts, handleRules);
                    });
                });
            });
        };
        this.getPluginRulesCallback = (req, callback) => {
            return (pluginRules) => {
                req.pluginRules = pluginRules;
                callback(pluginRules);
            };
        };
        this.resolveKey = (url, rule, req) => {
            if (!PLUGIN_KEY_RE.test(url)) {
                return;
            }
            const name = RegExp.$1;
            const key = RegExp.$2;
            if (!this.getActivePluginByName(name)) {
                return;
            }
            const ruleName = protocols.getRuleProto(rule);
            const headers = extend({}, req && req.headers, config.pluginHeaders);
            if (req) {
                addPluginHeaders(req, headers, true);
                headers[METHOD_HEADER] = req.method ? encodeURIComponent(req.method) : 'GET';
                delete headers.upgrade;
                delete headers.connection;
                delete headers['content-length'];
            }
            if (ruleName) {
                headers['x-whistle-rule-proto'] = ruleName;
            }
            return {
                originalKey: url,
                pluginName: name,
                maxLength: MAX_VALUE_LEN,
                url: name + '/api/key/value?key=' + util.encodeURIComponent(key),
                headers: headers
            };
        };
        this.requestText = (options, callback) => {
            return requestValue(options, callback);
        };
        this.requestBin = (options, callback) => {
            return requestValue(options, callback, true);
        };
        this.getPipe = (type, hookName) => {
            debug('getPipe, type: %s, hookName: %s', type, hookName);
            const isRes = type.toLowerCase().indexOf('res') !== -1;
            hookName = PLUGIN_HOOKS[hookName];
            return (req, res, callback) => {
                if (!isRes) {
                    callback = res;
                    res = undefined;
                }
                this.resolvePipePlugin(req, (ports) => {
                    const port = ports && ports[type + 'Port'];
                    if (!port || req._hasClosed || req._hasError) {
                        return callback?.();
                    }
                    const options = this.getOptions(req, res, isRes && 'resRules', true);
                    options.headers[PLUGIN_HOOK_NAME_HEADER] = hookName;
                    options.headers['x-whistle-request-tunnel-ack'] = 1;
                    options.proxyHost = LOCALHOST;
                    options.proxyPort = port;
                    delete options.headers[CUSTOM_PARSER_HEADER];
                    if (req._websocketExtensions !== null) {
                        if (req._websocketExtensions) {
                            req.headers['sec-websocket-extensions'] = req._websocketExtensions;
                        }
                        else {
                            delete req.headers['sec-websocket-extensions'];
                        }
                    }
                    let client;
                    const destroy = () => {
                        if (client) {
                            client.destroy();
                            client.socket && client.socket.destroy();
                            client = null;
                        }
                    };
                    const handleError = (err) => {
                        if (client) {
                            destroy();
                            if (err) {
                                debugMode && console.log(req._pipeRule.matcher, type);
                                (res || req).emit('error', err);
                            }
                        }
                    };
                    const handleConnect = (socket, _res) => {
                        if (req._hasError) {
                            return socket.destroy();
                        }
                        callback?.(socket);
                    };
                    client = config.connect(options, handleConnect);
                    client.on('error', () => {
                        if (client) {
                            destroy();
                            client = !req._hasError && config.connect(options, handleConnect);
                            client && util.onSocketEnd(client, handleError);
                        }
                    });
                    req.once('_closed', destroy);
                });
            };
        };
        this.getReqReadPipe = this.getPipe('reqRead', 'REQ_READ');
        this.getReqWritePipe = this.getPipe('reqWrite', 'REQ_WRITE');
        this.getResReadPipe = this.getPipe('resRead', 'RES_READ');
        this.getResWritePipe = this.getPipe('resWrite', 'RES_WRITE');
        this.getWsReqReadPipe = this.getPipe('wsReqRead', 'WS_REQ_READ');
        this.getWsReqWritePipe = this.getPipe('wsReqWrite', 'WS_REQ_WRITE');
        this.getWsResReadPipe = this.getPipe('wsResRead', 'WS_RES_READ');
        this.getWsResWritePipe = this.getPipe('wsResWrite', 'WS_RES_WRITE');
        this.getTunnelReqReadPipe = this.getPipe('tunnelReqRead', 'TUNNEL_REQ_READ');
        this.getTunnelReqWritePipe = this.getPipe('tunnelReqWrite', 'TUNNEL_REQ_WRITE');
        this.getTunnelResReadPipe = this.getPipe('tunnelResRead', 'TUNNEL_RES_READ');
        this.getTunnelResWritePipe = this.getPipe('tunnelResWrite', 'TUNNEL_RES_WRITE');
        this._loadPlugins = (plugins, callback) => {
            let rest = plugins.length;
            const results = [];
            const execCallback = () => {
                --rest === 0 && callback(results);
            };
            plugins.forEach((plugin, i) => {
                this.loadPlugin(plugin, (_err, ports) => {
                    plugin.ports = ports;
                    results[i] = ports || null;
                    execCallback();
                });
            });
        };
        this.loadPlugins = (plugins, callback) => {
            plugins = plugins.map((plugin) => {
                return plugin.plugin;
            });
            this._loadPlugins(plugins, callback);
        };
        this.getOptions = (req, res, type, isPipe) => {
            const fullUrl = req.fullUrl || util.getFullUrl(req);
            const options = util.parseUrl(fullUrl);
            const isResRules = res && type === 'resRules';
            const headers = extend({}, isResRules ? res.headers : req.headers);
            delete headers.upgrade;
            delete headers.connection;
            options.headers = this.addRuleHeaders(req, req.rules, headers, isPipe);
            delete headers['content-length'];
            headers[METHOD_HEADER] = encodeURIComponent(req.method || 'GET');
            if (isResRules) {
                headers.host = req.headers.host;
                headers[HOST_IP_HEADER] = req.hostIp || LOCALHOST;
                headers[STATUS_CODE_HEADER] = encodeURIComponent(res.statusCode == null ? '' : res.statusCode);
                if (req.headers.cookie) {
                    headers.cookie = req.headers.cookie;
                }
                else {
                    delete headers.cookie;
                }
            }
            if (req.isPluginReq) {
                headers[PLUGIN_REQUEST_HEADER] = 1;
            }
            if (req._existsCustomCert) {
                headers[CUSTOM_CERT_HEADER] = 1;
            }
            if (req._enableCapture) {
                headers[ENABLE_CAPTURE_HEADER] = 1;
            }
            options.protocol = 'http:';
            options.host = LOCALHOST;
            options.hostname = null;
            options.agent = false;
            return options;
        };
        this.getPluginByPluginRule = (pluginRule) => {
            if (!pluginRule) {
                return;
            }
            let value = pluginRule.matcher;
            if (PLUGIN_RE.test(value)) {
                value = util.getMatcherValue(pluginRule);
            }
            else {
                value = util.rule.getMatcher(pluginRule);
            }
            if (PLUGIN_RULE_RE.test(value) || PLUGIN_RULE_RE2.test(value)) {
                value = RegExp.$2;
                const plugin = this.getPlugin(RegExp.$1 + ':');
                if (!plugin) {
                    return;
                }
                const ruleUrl = util.getUrlValue(pluginRule, true);
                return (plugin && {
                    plugin: plugin,
                    value: value,
                    url: ruleUrl == value ? undefined : ruleUrl
                });
            }
            return;
        };
        this.on('updateRules', () => {
            debug('on:updateRules, allPlugins=', Object.keys(allPlugins));
            rulesMgr.clearAppend();
            let hasRulesUrl;
            const authPlugins = [];
            const tunnelKeys = [];
            Object.keys(allPlugins)
                .sort((a, b) => {
                const p1 = allPlugins[a];
                const p2 = allPlugins[b];
                return util.compare(p1.priority, p2.priority) || util.compare(p2.mtime, p1.mtime) || (a > b ? 1 : 0);
            })
                .forEach(name => {
                if (this.isDisabled(name.slice(0, -1))) {
                    return;
                }
                const plugin = allPlugins[name];
                let rules = plugin.rules;
                if (plugin.enableAuthUI) {
                    authPlugins.push(plugin);
                }
                if (plugin.tunnelKey) {
                    plugin.tunnelKey.forEach((key) => {
                        if (tunnelKeys.indexOf(key) === -1) {
                            tunnelKeys.push(key);
                        }
                    });
                }
                if (rules) {
                    rules = rules.replace(REMOTE_RULES_RE, (_, apo, rulesUrl) => {
                        hasRulesUrl = true;
                        return util.getRemoteRules(apo, rulesUrl);
                    });
                    rulesMgr.append(rules, plugin.path);
                }
            });
            if (!hasRulesUrl) {
                httpMgr.clean();
            }
        });
        this.emit('updateRules');
        this.on('update', (result) => {
            Object.keys(result).forEach(name => {
                this.stopPlugin(result[name]);
            });
        });
        this.on('uninstall', (result) => {
            Object.keys(result).forEach(name => {
                this.stopPlugin(result[name]);
            });
        });
    }
}
function showVerbose(oldData, newData) {
    if (!debugMode) {
        return;
    }
    let uninstallData;
    let installData;
    let updateData;
    Object.keys(oldData).forEach(name => {
        const oldItem = oldData[name];
        const newItem = newData[name];
        if (!newItem) {
            uninstallData = uninstallData || {};
            uninstallData[name] = oldItem;
        }
        else if (newItem.path != oldItem.path || newItem.mtime != oldItem.mtime) {
            updateData = updateData || {};
            updateData[name] = newItem;
        }
    });
    Object.keys(newData).forEach(name => {
        if (!oldData[name]) {
            installData = installData || {};
            installData[name] = newData[name];
        }
    });
    uninstallData &&
        Object.keys(uninstallData).forEach(name => {
            console.log(colors.red(util.formatDate(new Date(uninstallData[name].mtime)) + ' [uninstall plugin] ' + name.slice(0, -1)));
        });
    installData &&
        Object.keys(installData).forEach(name => {
            console.log(colors.green(util.formatDate(new Date(installData[name].mtime)) + ' [install plugin] ' + name.slice(0, -1)));
        });
    updateData &&
        Object.keys(updateData).forEach(name => {
            console.log(colors.yellow(util.formatDate(new Date(updateData[name].mtime)) + ' [update plugin] ' + name.slice(0, -1)));
        });
}
function readFile(filepath, callback) {
    fs.readFile(filepath, UTF8_OPTIONS, (err, text) => {
        if (!err) {
            return callback(err, text);
        }
        fs.readFile(filepath, UTF8_OPTIONS, callback);
    });
}
function readReqRules(dir, callback) {
    readFile(path.join(path.join(dir, '_rules.txt')), (err, rulesText) => {
        if (err) {
            readFile(path.join(path.join(dir, 'reqRules.txt')), (_, rulesText) => {
                callback(util.trim(rulesText));
            });
            return;
        }
        callback(util.trim(rulesText));
    });
}
function readJson(pkgPath, callback) {
    fse.readJson(pkgPath, (err, json) => {
        if (!err) {
            return callback(err, json);
        }
        fse.readJson(pkgPath, callback);
    });
}
function readPackages(obj, callback) {
    const _plugins = {};
    let count = 0;
    const callbackHandler = () => {
        if (--count <= 0) {
            callback(_plugins);
        }
    };
    Object.keys(obj).forEach(name => {
        const pkg = allPlugins[name];
        const newPkg = obj[name];
        if (!pkg || pkg.path != newPkg.path || pkg.mtime != newPkg.mtime) {
            ++count;
            readJson(path.join(newPkg.path, 'package.json'), (_, result) => {
                if (result && result.version && pluginUtil.isPluginName(result.name)) {
                    const conf = result.whistleConfig || '';
                    const tabs = conf.inspectorTabs || conf.inspectorTab || '';
                    const hintList = util.getHintList(conf);
                    const simpleName = name.slice(0, -1);
                    newPkg.enableAuthUI = !!conf.enableAuthUI;
                    newPkg.updateUrl = util.getUpdateUrl(conf);
                    newPkg.inheritAuth = !!conf.inheritAuth;
                    newPkg.tunnelKey = util.getTunnelKey(conf);
                    newPkg.version = result.version;
                    newPkg.staticDir = util.getStaticDir(conf);
                    newPkg.priority = parseInt(conf.priority, 10) || parseInt(result.pluginPriority, 10) || 0;
                    newPkg.rulesUrl = util.getCgiUrl(conf.rulesUrl);
                    newPkg.valuesUrl = util.getCgiUrl(conf.valuesUrl);
                    newPkg.networkMenus = util.getPluginMenu(conf.networkMenus || conf.networkMenu, simpleName);
                    newPkg.rulesMenus = util.getPluginMenu(conf.rulesMenus || conf.rulesMenu, simpleName);
                    newPkg.valuesMenus = util.getPluginMenu(conf.valuesMenus || conf.valuesMenu, simpleName);
                    newPkg.reqTab = util.getCustomTab(tabs.req, simpleName);
                    newPkg.resTab = util.getCustomTab(tabs.res, simpleName);
                    newPkg.tab = util.getCustomTab(tabs, simpleName);
                    newPkg.comTab = util.getCustomTab(conf.composerTab, simpleName);
                    newPkg[util.PLUGIN_MENU_CONFIG] = util.getPluginMenuConfig(conf);
                    newPkg[util.PLUGIN_INSPECTOR_CONFIG] = util.getPluginInspectorConfig(conf);
                    newPkg.hintUrl = hintList ? undefined : util.getCgiUrl(conf.hintUrl);
                    newPkg.hintList = hintList;
                    newPkg.pluginVars = util.getPluginVarsConf(conf);
                    newPkg.hideShortProtocol = !!conf.hideShortProtocol;
                    newPkg.hideLongProtocol = !!conf.hideLongProtocol;
                    newPkg.homepage = pluginUtil.getHomePageFromPackage(result);
                    newPkg.description = result.description;
                    newPkg.moduleName = result.name;
                    newPkg.pluginHomepage = pluginUtil.getPluginHomepage(result);
                    newPkg.openInPlugins = conf.openInPlugins ? 1 : undefined;
                    newPkg.registry = util.getRegistry(result);
                    newPkg.latest = pkg && pkg.latest;
                    _plugins[name] = newPkg;
                    readFile(path.join(path.join(newPkg.path, 'rules.txt')), (_err, rulesText) => {
                        newPkg.rules = util.renderPluginRules(util.trim(rulesText), result, simpleName);
                        readReqRules(newPkg.path, (rulesText) => {
                            newPkg._rules = util.renderPluginRules(util.trim(rulesText), result, simpleName);
                            readFile(path.join(path.join(newPkg.path, '_values.txt')), (_err, rulesText) => {
                                newPkg[util.PLUGIN_VALUES] = pluginUtil.parseValues(util.renderPluginRules(rulesText, result, simpleName));
                                readFile(path.join(path.join(newPkg.path, 'resRules.txt')), (_err, rulesText) => {
                                    newPkg.resRules = util.renderPluginRules(util.trim(rulesText), result, simpleName);
                                    callbackHandler();
                                });
                            });
                        });
                    });
                }
                else {
                    callbackHandler();
                }
            });
        }
        else {
            _plugins[name] = pkg;
        }
    });
    if (count <= 0) {
        callback(_plugins);
    }
}
function checkUpdate(pluginNames) {
    pluginNames = pluginNames || Object.keys(allPlugins);
    let name = pluginNames.shift();
    let plugin;
    while (name) {
        if ((plugin = allPlugins[name]) && !plugin.isProj) {
            break;
        }
        name = pluginNames.shift();
    }
    if (name) {
        util.getLatestVersion(plugin, (ver) => {
            if (ver && plugin.version !== ver) {
                plugin.latest = ver;
            }
            checkUpdate(pluginNames);
        });
    }
    else {
        setTimeout(checkUpdate, CHECK_INTERVAL);
    }
}
setTimeout(checkUpdate, 5000);
(function update() {
    !config.inspectMode &&
        setTimeout(() => {
            getPlugin((result) => {
                readPackages(result, (_plugins) => {
                    let updatePlugins;
                    let uninstallPlugins;
                    const pluginNames = Object.keys(allPlugins);
                    pluginNames.forEach(name => {
                        const plugin = allPlugins[name];
                        const newPlugin = _plugins[name];
                        if (!newPlugin) {
                            uninstallPlugins = uninstallPlugins || {};
                            uninstallPlugins[name] = plugin;
                        }
                        else if (newPlugin.path != plugin.path || newPlugin.mtime != plugin.mtime) {
                            updatePlugins = updatePlugins || {};
                            updatePlugins[name] = newPlugin;
                        }
                    });
                    showVerbose(allPlugins, _plugins);
                    allPlugins = _plugins;
                    if (uninstallPlugins || updatePlugins || Object.keys(_plugins).length !== pluginNames.length) {
                        uninstallPlugins && pluginMgr.emit('uninstall', uninstallPlugins);
                        updatePlugins && pluginMgr.emit('update', updatePlugins);
                        pluginMgr.emit('updateRules');
                    }
                    update();
                });
            });
        }, INTERVAL);
})();
function getValue(rule) {
    if (!rule) {
        return;
    }
    let value = util.getMatcherValue(rule) || '';
    value += rule.port ? ':' + rule.port : '';
    return encodeURIComponent(value);
}
function addRealUrl(req, newHeaders) {
    let realUrl = req._realUrl;
    if (!realUrl) {
        const href = req.options && req.options.href;
        realUrl = util.isUrl(href) ? href : null;
    }
    if (realUrl && realUrl != req.fullUrl) {
        newHeaders[REAL_URL_HEADER] = encodeURIComponent(realUrl);
    }
    const rule = req.rules && req.rules.rule;
    if (rule) {
        if (rule.url !== rule.matcher) {
            const relPath = rule.url.substring(rule.matcher.length);
            newHeaders[RELATIVE_URL_HEADER] = encodeURIComponent(relPath);
        }
        if (rule.url) {
            newHeaders[RULE_URL_HEADER] = encodeURIComponent(rule.url);
        }
    }
}
function getPluginVars(value) {
    if (value) {
        try {
            value = JSON.stringify(value);
            return Buffer.from(value).toString('base64');
        }
        catch (e) { }
    }
    return undefined;
}
function addPluginVars(req, headers, rule) {
    addRealUrl(req, headers);
    if (!rule) {
        delete headers[RULE_VALUE_HEADER];
        delete headers[GLOBAL_PLUGIN_VARS_HEAD];
        delete headers[PLUGIN_VARS_HEAD];
        return;
    }
    const plugin = rule.plugin;
    let name;
    let value;
    if (plugin) {
        name = plugin.moduleName.split('.', 2)[1];
        value = rule.value;
    }
    else {
        name = rule.matcher.split(':', 1)[0];
        value = util.getMatcherValue(rule);
    }
    if (value) {
        headers[RULE_VALUE_HEADER] = encodeURIComponent(value);
    }
    else {
        delete headers[RULE_VALUE_HEADER];
    }
    if (rule.rawPattern) {
        headers['x-whistle-raw-pattern_'] = encodeURIComponent((rule.isRegExp ? 1 : 0) + ',' + rule.rawPattern);
    }
    if (rule.url) {
        let extraUrl = rule.url;
        if (value) {
            extraUrl = rule.url.substring(value.length);
        }
        if (extraUrl) {
            headers[EXTRA_URL_HEADER] = encodeURIComponent(extraUrl);
        }
    }
    value = getPluginVars(req._globalPluginVars && req._globalPluginVars[name]);
    if (value) {
        headers[GLOBAL_PLUGIN_VARS_HEAD] = value;
    }
    else {
        delete headers[GLOBAL_PLUGIN_VARS_HEAD];
    }
    value = getPluginVars(req._pluginVars && req._pluginVars[name]);
    if (value) {
        headers[PLUGIN_VARS_HEAD] = value;
    }
    else {
        delete headers[PLUGIN_VARS_HEAD];
    }
}
function addPluginHeaders(req, headers, isKey) {
    if (req.reqId) {
        headers[REQ_ID_HEADER] = req.reqId;
    }
    if (req.fullUrl) {
        headers[FULL_URL_HEADER] = encodeURIComponent(req.fullUrl);
    }
    const clientIp = req.clientIp || util.getClientIp(req);
    if (clientIp) {
        headers[config.CLIENT_IP_HEAD] = clientIp;
    }
    const clientPort = req.clientPort || util.getClientPort(req);
    if (clientPort) {
        headers[config.CLIENT_PORT_HEAD] = clientPort;
    }
    if (req.fromTunnel) {
        headers[FROM_TUNNEL_HEADER] = '1';
    }
    else {
        delete headers[FROM_TUNNEL_HEADER];
    }
    headers[isKey ? 'x-whistle-remote-address' : config.REMOTE_ADDR_HEAD] = req._remoteAddr || LOCALHOST;
    headers[isKey ? 'x-whistle-remote-port' : config.REMOTE_PORT_HEAD] = req._remotePort || '0';
    if (req.fromComposer) {
        headers[config.REQ_FROM_HEADER] = 'W2COMPOSER';
    }
    else {
        delete headers[config.REQ_FROM_HEADER];
    }
    return headers;
}
function parseRulesList(req, results, isResRules) {
    const values = {};
    results = results.filter(emptyFilter);
    results.reverse().forEach((item) => {
        extend(values, item.values);
    });
    const pluginRulesMgr = new RulesMgr(values);
    pluginRulesMgr.parse(results);
    if (isResRules) {
        req.curUrl = req.fullUrl;
        util.mergeRules(req, pluginRulesMgr.resolveRules(req), true);
    }
    return pluginRulesMgr;
}
function getPluginReqOpts(item, req, options, port) {
    const opts = extend({}, options);
    opts.headers = extend({}, options.headers);
    opts.port = port;
    addPluginVars(req, opts.headers, item);
    return opts;
}
function authReq(isReq, ports, req, options, callback) {
    if (!isReq) {
        return callback();
    }
    let rest = ports.length;
    let forbidden;
    const execCallback = () => {
        if (--rest === 0) {
            callback(forbidden);
        }
    };
    ports.forEach((item) => {
        if (!item.authPort) {
            return execCallback();
        }
        options.headers[PLUGIN_HOOK_NAME_HEADER] = PLUGIN_HOOKS.AUTH;
        const opts = getPluginReqOpts(item, req, options, item.authPort);
        opts.maxLength = MAX_RULES_LENGTH;
        requestPlugin(opts, (err, body, res) => {
            const headers = res && res.headers;
            if (err || body) {
                if (!forbidden) {
                    if (debugMode) {
                        forbidden = err ? err.message || 'Error' : body;
                    }
                    else {
                        forbidden = err ? 'Error' : body;
                    }
                    if (headers) {
                        let authHtmlUrl = headers['x-auth-html-url'];
                        req._authStatus = headers['x-auth-status'];
                        if (authHtmlUrl) {
                            try {
                                authHtmlUrl = decodeURIComponent(authHtmlUrl);
                                req._authHtmlUrl = HTTP_RE.test(authHtmlUrl) ? authHtmlUrl : 'file://' + authHtmlUrl;
                            }
                            catch (e) { }
                        }
                        else if (headers.location) {
                            req._redirectUrl = headers.location;
                        }
                        else if (headers[SHOW_LOGIN_BOX]) {
                            req._showLoginBox = true;
                        }
                    }
                }
                err && logger.error(err);
            }
            if (!forbidden && headers) {
                Object.keys(headers).forEach(key => {
                    if (key.indexOf('x-whistle-') === 0 || key === 'proxy-authorization') {
                        const value = headers[key];
                        if (key === config.WHISTLE_POLICY_HEADER && value === 'enableCaptureByAuth') {
                            req._forceCapture = true;
                        }
                        req.headers[key] = value;
                        options.headers[key] = value;
                    }
                });
            }
            execCallback();
        });
    });
}
function requestPlugin(options, callback, retryCount = 0) {
    util.request(options, (err, body, res) => {
        if (err && retryCount < 5) {
            return requestPlugin(options, callback, ++retryCount);
        }
        if (res && res.statusCode == 304) {
            return callback(false, null, res);
        }
        callback(null, body && body.trim(), res);
    });
}
function requestRules(options, callback) {
    requestPlugin(options, (err, body, res) => {
        if (err === false) {
            return callback(false, null, null, null, res);
        }
        let rules = body;
        let values = null;
        const data = !err && rulesToJson(body);
        if (data) {
            rules = data.text;
            values = data.values;
        }
        callback(err, rules, values, body, res);
    });
}
function rulesToJson(body) {
    if (body && /^\{[\s\S]+\}$/.test(body)) {
        try {
            body = JSON.parse(body);
            return {
                root: typeof body.root === 'string' ? body.root : null,
                text: typeof body.rules === 'string' ? body.rules : '',
                values: body.values
            };
        }
        catch (e) { }
    }
    return undefined;
}
function emptyFilter(val) {
    return !!val;
}
function requestValue(options, callback, isBin) {
    options.needRawData = isBin;
    const handleCallback = (err, body, res) => {
        const code = res && res.statusCode;
        if (code != 200) {
            body = '';
            if (!err) {
                err = new Error('Error: response ' + code);
                err.code = code || 500;
            }
        }
        callback(body, err, res);
    };
    httpMgr.request(extend({}, options), (err, body, res) => {
        if (err) {
            return httpMgr.request(options, handleCallback);
        }
        handleCallback(err, body, res);
    });
    return options;
}
export const pluginMgr = new PluginMgr();
httpMgr.setPluginMgr(pluginMgr);
util.setPluginMgr(pluginMgr);
httpMgr.addChangeListener(pluginMgr.updateRules);
rulesMgr.setGetPluginFn(pluginMgr.getActivePluginByName);
