import { fs, fse, path } from '../import-pkg';
import logger from '../util/logger';
const ENCODING = { encoding: 'utf8' };
const NAME_RE = /^\d+\.([\s\S]+)$/;
const MAX_COUNT = 200;
const noop = function () { };
function readFileSafe(file, retry) {
    try {
        file = fs.readFileSync(file, ENCODING);
    }
    catch (e) {
        if (retry) {
            file = undefined;
        }
        else {
            return readFileSafe(file, true);
        }
    }
    return file || '';
}
function getName(item) {
    return item.name;
}
class RecycleBin {
    constructor(dir) {
        this.recycle = (filename, data) => {
            if (!filename) {
                return;
            }
            try {
                const name = Date.now() + '.' + encodeURIComponent(filename);
                data = data ? data + '' : '';
                const item = {
                    name: name,
                    data: data
                };
                this._list.unshift(item);
                this._map[name] = item;
                fs.writeFile(path.join(this._dir, name), data, noop);
            }
            catch (e) {
                logger.error(e);
            }
        };
        this.recover = (name) => {
            const item = this._map[name];
            if (item) {
                delete this._map[name];
                this._list.splice(this._list.indexOf(item), 1);
                fs.unlink(path.join(this._dir, name), noop);
            }
            return item;
        };
        this.remove = this.recover;
        this.list = () => {
            return this._list.map(getName);
        };
        this.getFile = (name) => {
            return this._map[name];
        };
        fse.ensureDirSync(dir);
        let list = [];
        const map = {};
        this._dir = dir;
        fs.readdirSync(dir).forEach((name) => {
            if (NAME_RE.test(name)) {
                const item = {
                    name: name,
                    data: readFileSafe(path.join(dir, name))
                };
                map[name] = item;
                list.push(item);
            }
        });
        list.sort((a, b) => {
            a = a.name;
            b = b.name;
            a = a.substring(0, a.indexOf('.'));
            b = b.substring(0, a.indexOf('.'));
            const aLen = a.length;
            const bLen = b.length;
            return aLen > bLen || (aLen === bLen && a > b) ? -1 : 1;
        });
        if (list.length > MAX_COUNT) {
            list.slice(MAX_COUNT).forEach(item => {
                try {
                    delete map[item.name];
                    fs.unlinkSync(path.join(dir, item.name)); // FIXME: 原版直接用name, bug
                }
                catch (e) { }
            });
            list = list.slice(0, MAX_COUNT);
        }
        this._list = list;
        this._map = map;
    }
}
export default RecycleBin;
