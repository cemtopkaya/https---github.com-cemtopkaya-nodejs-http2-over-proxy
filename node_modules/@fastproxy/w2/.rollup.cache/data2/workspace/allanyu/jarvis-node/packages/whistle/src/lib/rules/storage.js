import { fs, fse, path } from '../import-pkg';
import logger from '../util/logger';
import RecycleBin from './recycle-bin';
const ENCODING = { encoding: 'utf8' };
const RETRY_INTERVAL = 16000;
const ASCII_RE = /[\x00-\x7f]/g;
const MAX_FILENAME_LEN = 254;
const EMPTY_ARR = [];
function encodeName(index, name) {
    let filename;
    try {
        filename = index + '.' + encodeURIComponent(name);
        if (filename.length <= MAX_FILENAME_LEN) {
            return filename;
        }
    }
    catch (e) { }
    try {
        filename = index + '.' + name.replace(ASCII_RE, encodeURIComponent);
        if (filename.length <= MAX_FILENAME_LEN) {
            return filename;
        }
    }
    catch (e) {
        logger.error(e);
    }
    return index + '.' + name;
}
function readFileSafe(file, retry) {
    try {
        file = fs.readFileSync(file, ENCODING);
    }
    catch (e) {
        if (retry) {
            file = undefined;
        }
        else {
            return readFileSafe(file, true);
        }
    }
    return file || '';
}
function readJsonSafe(file, retry) {
    try {
        file = fs.readFileSync(file, ENCODING);
        file = file && JSON.parse(file);
    }
    catch (e) {
        if (retry) {
            file = null;
        }
        else {
            return readJsonSafe(file, true);
        }
    }
    return file;
}
function copyFileObj(file) {
    if (!file) {
        return file;
    }
    return {
        index: file.index,
        name: file.name,
        data: file.data,
        selected: file.selected
    };
}
function noop() { }
function compare(v1, v2) {
    return v1 == v2 ? 0 : v1 > v2 ? 1 : -1;
}
export default class Storage {
    constructor(dir, filters = {}, disabled) {
        this._writePropertiesPending = false;
        this._writePropertiesWaiting = false;
        this._writeProperties = () => {
            if (this._disabled || this._writePropertiesPending) {
                this._writePropertiesWaiting = true;
                return;
            }
            clearTimeout(this._writePropertiesTimeout);
            this._writePropertiesPending = true;
            fse.outputJson(this._properties, this._cache.properties, (err) => {
                this._writePropertiesPending = false;
                if (err) {
                    this._writePropertiesTimeout = setTimeout(this._writeProperties.bind(this), RETRY_INTERVAL);
                    logger.error(err);
                }
                else {
                    copyFile(this._properties, this._backupProps, () => {
                        if (this._writePropertiesWaiting) {
                            this._writePropertiesWaiting = false;
                            this._writeProperties();
                        }
                    });
                }
            });
        };
        this._writeFile = (file) => {
            if (this._disabled || !(file = this._cache.files[file])) {
                return;
            }
            if (file._pending) {
                file._waiting = true;
                return;
            }
            clearTimeout(file._timeout);
            file._pending = true;
            fs.writeFile(this._getFilePath(file), file.data, (err) => {
                file._pending = false;
                if (err) {
                    file._timeout = setTimeout(() => {
                        this._writeFile(file.name);
                    }, RETRY_INTERVAL);
                    logger.error(err);
                }
                else {
                    copyFile(this._getFilePath(file), this._getFilePath(file, true), () => {
                        if (file._waiting) {
                            file._waiting = false;
                            this._writeFile(file.name);
                        }
                    });
                }
            });
        };
        this._getFilePath = (file, backup) => {
            file = typeof file === 'string' ? this._cache.files[file] : file;
            const name = encodeName(file.index, file.name);
            return path.join(backup ? this._backupDir : this._files, name);
        };
        this.count = () => {
            return this._disabled ? 0 : Object.keys(this._cache.files).length;
        };
        this.existsFile = (file) => {
            return !this._disabled && this._cache.files[file];
        };
        this.getFileList = (origObj) => {
            const cache = this._cache;
            const files = cache.files;
            const filesOrder = cache.properties.filesOrder;
            return this._disabled
                ? EMPTY_ARR
                : filesOrder.map((file) => {
                    return origObj ? files[file] : copyFileObj(files[file]);
                });
        };
        this.writeFile = (file, data) => {
            if (this._disabled || !file) {
                return;
            }
            const cache = this._cache;
            let fileData = cache.files[file];
            let hasChanged = true;
            data = typeof data === 'string' ? data : '';
            if (!fileData) {
                fileData = cache.files[file] = {
                    index: ++cache.maxIndex,
                    name: file
                };
                cache.properties.filesOrder.push(file);
                this._writeProperties();
            }
            else if (fileData.data === data) {
                hasChanged = false;
            }
            fileData.data = data;
            this._writeFile(file);
            return hasChanged;
        };
        this.updateFile = (file, data) => {
            return (!this._disabled && this.existsFile(file) && this.writeFile(file, data));
        };
        this.readFile = (file) => {
            file = !this._disabled && file && this._cache.files[file];
            return file && file.data;
        };
        this.removeFile = (file) => {
            const files = this._cache.files;
            file = !this._disabled && file && files[file];
            if (!file) {
                return;
            }
            const filesOrder = this._cache.properties.filesOrder;
            filesOrder.splice(filesOrder.indexOf(file.name), 1);
            this.recycleBin.recycle(file.name, file.data);
            delete files[file.name];
            fs.unlink(this._getFilePath(file), (err) => {
                if (!err) {
                    fs.unlink(this._getFilePath(file, true), noop);
                }
            });
            this._writeProperties();
            return true;
        };
        this.renameFile = (file, newFile) => {
            const cache = this._cache;
            if (this._disabled ||
                !newFile ||
                !(file = cache.files[file]) ||
                cache.files[newFile]) {
                return;
            }
            const filesOrder = this._cache.properties.filesOrder;
            filesOrder[filesOrder.indexOf(file.name)] = newFile;
            const path = this._getFilePath(file);
            const backupPath = this._getFilePath(file, true);
            delete cache.files[file.name];
            file.name = newFile;
            cache.files[newFile] = file;
            fs.rename(path, this._getFilePath(file), (err) => {
                if (!err) {
                    fs.rename(backupPath, this._getFilePath(file, true), noop);
                }
            }); //不考虑并发
            this._writeProperties();
            return true;
        };
        this.moveTo = (fromName, toName) => {
            const filesOrder = this._cache.properties.filesOrder;
            const fromIndex = filesOrder.indexOf(fromName);
            if (this._disabled || fromIndex === -1) {
                return false;
            }
            const toIndex = filesOrder.indexOf(toName);
            if (toIndex === -1 || fromIndex === toIndex) {
                return false;
            }
            filesOrder.splice(fromIndex, 1);
            filesOrder.splice(toIndex, 0, fromName);
            this._writeProperties();
            return true;
        };
        this.setProperty = (name, value) => {
            if (!this._disabled) {
                this._cache.properties[name] = value;
                this._writeProperties();
            }
        };
        this.hasProperty = (name) => {
            return !this._disabled && name in this._cache.properties;
        };
        this.setProperties = (obj) => {
            if (this._disabled || !obj) {
                return;
            }
            const props = this._cache.properties;
            Object.keys(obj).forEach(key => {
                props[key] = obj[key];
            });
            this._writeProperties();
            return true;
        };
        this.getProperty = (name) => {
            return this._disabled ? null : this._cache.properties[name];
        };
        this.removeProperty = (name) => {
            if (!this._disabled && this.hasProperty(name) && name !== 'filesOrder') {
                delete this._cache.properties[name];
                this._writeProperties();
            }
        };
        this.recycleBin = new RecycleBin(path.join(dir, '.recycle_bin'));
        const backupDir = path.join(dir, '.backup');
        fse.ensureDirSync(dir);
        fse.ensureDirSync(backupDir);
        this._disabled = disabled === true;
        this._backupDir = backupDir;
        this._files = path.join(dir, 'files');
        this._properties = path.join(dir, 'properties');
        this._backupProps = path.join(backupDir, 'properties');
        fse.ensureDirSync(this._files);
        fse.ensureFileSync(this._properties);
        let maxIndex = -1;
        const files = {};
        const fileNames = { properties: true };
        fs.readdirSync(this._files).forEach((file) => {
            if (!/^(\d+)\.(.+)$/.test(file)) {
                return;
            }
            const index = parseInt(RegExp.$1, 10);
            let filename = RegExp.$2;
            try {
                filename = decodeURIComponent(filename);
            }
            catch (e) {
                logger.error(e);
            }
            if (filters[filename]) {
                return;
            }
            const filePath = path.join(this._files, file);
            if (files[filename]) {
                return fs.unlinkSync(filePath);
            }
            if (index > maxIndex) {
                maxIndex = index;
            }
            let data = readFileSafe(filePath);
            const backFile = path.join(backupDir, file);
            if (data) {
                fs.writeFileSync(backFile, data);
            }
            else {
                data = readFileSafe(backFile);
                if (data) {
                    fs.writeFileSync(filePath, data);
                }
            }
            files[filename] = {
                index: index,
                name: filename,
                data: data
            };
            const newFile = encodeName(index, filename);
            fileNames[newFile] = true;
            if (file !== newFile) {
                fs.writeFileSync(path.join(this._files, newFile), data);
                fs.writeFileSync(path.join(backupDir, newFile), data);
                fs.unlinkSync(filePath);
            }
        });
        let properties = readJsonSafe(this._properties);
        if (properties) {
            fse.outputJsonSync(this._backupProps, properties);
        }
        else {
            properties = readJsonSafe(this._backupProps);
            if (properties) {
                fse.outputJsonSync(this._properties, properties);
            }
            else {
                properties = {};
            }
        }
        this._cache = {
            maxIndex: maxIndex,
            files: files,
            properties: properties
        };
        let filesOrder = properties.filesOrder;
        if (!Array.isArray(filesOrder)) {
            filesOrder = null;
        }
        filesOrder = Object.keys(files).sort((cur, next) => {
            if (filesOrder) {
                const curIndex = filesOrder.indexOf(cur);
                if (curIndex !== -1) {
                    const nextIndex = filesOrder.indexOf(next);
                    if (nextIndex !== -1) {
                        return compare(curIndex, nextIndex);
                    }
                }
            }
            cur = files[cur];
            next = files[next];
            return compare(cur.index, next.index);
        });
        this._cache.properties['filesOrder'] = filesOrder;
        fs.readdirSync(backupDir).forEach((file) => {
            if (fileNames[file]) {
                return;
            }
            try {
                fs.unlinkSync(path.join(backupDir, file));
            }
            catch (e) { }
        });
    }
}
function copyFile(src, dest, callback, retry) {
    const execCb = function (e) {
        if (e && !retry) {
            copyFile(src, dest, callback, true);
        }
        else {
            callback(e);
        }
    };
    if (typeof fs.copyFile === 'function') {
        fs.copyFile(src, dest, execCb);
    }
    else {
        fse.copy(src, dest, execCb);
    }
}
