import { STATUS_CODES } from 'http';
import { Transform } from 'pipestream';
import config from '../config';
function getRawData(source, req, isReq) {
    let firstLine;
    if (req) {
        const message = source.statusMessage || STATUS_CODES[source.statusCode] || '';
        firstLine = ['HTTP/' + (req.httpVersion || '1.1'), source.statusCode, message].join(' ');
    }
    else {
        firstLine = [source.method, source.url, 'HTTP/' + (source.httpVersion || '1.1')].join(' ');
    }
    const headers = [];
    const rawHeaderNames = source.rawHeaderNames || {};
    Object.keys(source.headers).forEach(function (key) {
        const val = source.headers[key];
        if (!isReq || (key !== config.HTTPS_FIELD && key !== 'content-encoding')) {
            key = rawHeaderNames[key] || key;
            headers.push(Array.isArray(val)
                ? val
                    .map(function (item) {
                    return key + ': ' + item;
                })
                    .join('\r\n')
                : key + ': ' + val);
        }
    });
    return firstLine + '\r\n' + headers.join('\r\n') + '\r\n\r\n';
}
export default class FileWriterTransform extends Transform {
    constructor(writer, source, isRaw, req, isReq) {
        super();
        this._writer = writer;
        source.on('error', function () {
            writer.end();
        });
        isRaw && writer.write(getRawData(source, req, isReq));
    }
    _transform(chunk, _encoding, callback) {
        if (chunk) {
            this._writer.write(chunk);
        }
        else {
            this._writer.end();
        }
        callback(null, chunk);
    }
}
