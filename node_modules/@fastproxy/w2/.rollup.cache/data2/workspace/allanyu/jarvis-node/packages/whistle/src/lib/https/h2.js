import { LRU, PassThrough, http2, https, socks, tls } from '../import-pkg';
import * as util from '../util';
import config from '../config';
const SUPPORTED_PROTOS = ['h2', 'http/1.1', 'http/1.0'];
const H2_SETTINGS = { enablePush: false };
const H2_SVR_SETTINGS = { enablePush: false, enableConnectProtocol: false };
const CACHE_TIMEOUT = 1000 * 60;
const INTERVAL = 1000 * 60;
const clients = {};
const notH2 = new LRU({ max: 2560 });
const pendingH2 = {};
const pendingList = {};
const TIMEOUT = 36000;
const REQ_TIMEOUT = 16000;
const CONCURRENT = 3;
setInterval(function () {
    const now = Date.now();
    Object.keys(clients).forEach(function (name) {
        const client = clients[name];
        if (now - client._updateTime > CACHE_TIMEOUT) {
            client.close();
            delete clients[name];
        }
    });
}, INTERVAL);
function getKey(options) {
    const proxyOpts = options._proxyOptions;
    let proxyType = '';
    if (proxyOpts) {
        const auth = (proxyOpts.headers && proxyOpts.headers['proxy-authorization']) || '';
        proxyType = [
            proxyOpts.proxyType,
            proxyOpts.proxyHost,
            proxyOpts.proxyPort,
            proxyOpts.headers.host,
            proxyOpts.proxyTunnelPath || '',
            auth
        ].join(':');
    }
    return [
        options.servername,
        options.host,
        options.port || '',
        proxyType,
        options.cacheKey || ''
    ].join('/');
}
function getSocksSocket(options, callback) {
    let done;
    const handleCallback = function (err, socket) {
        if (!done) {
            done = true;
            callback(err, socket);
        }
    };
    const proxyOpts = options._proxyOptions;
    const client = socks.connect({
        localDNS: false,
        proxyHost: proxyOpts.proxyHost,
        proxyPort: proxyOpts.proxyPort,
        auths: config.getAuths(proxyOpts),
        host: options.host,
        port: options.port || 443
    }, function (socket) {
        handleCallback(null, socket);
    });
    client.on('error', handleCallback);
}
function getTunnelSocket(options, callback) {
    let done;
    const handleCallback = function (err, socket) {
        if (!done) {
            done = true;
            callback(err, socket);
        }
    };
    const connReq = config.connect(options._proxyOptions, function (socket) {
        handleCallback(null, socket);
    });
    connReq.on('error', handleCallback);
}
function addCert(opts, options) {
    if (options.cert) {
        opts.key = options.key;
        opts.cert = options.cert;
    }
    else if (options.pfx) {
        opts.pfx = options.pfx;
        if (options.passphrase) {
            opts.passphrase = options.passphrase;
        }
    }
    return opts;
}
function getProxySocket(options, callback, ciphers, isHttp) {
    const handleConnect = function (err, socket) {
        if (err) {
            return callback(err);
        }
        if (isHttp) {
            return callback(null, socket);
        }
        let timer = setTimeout(function () {
            if (timer) {
                timer = undefined;
                socket.destroy();
            }
        }, REQ_TIMEOUT);
        const handleCallback = function (err) {
            if (timer) {
                clearTimeout(timer);
                timer = undefined;
                callback(err, err ? null : socket);
            }
        };
        try {
            socket = tls.connect(addCert({
                servername: options.servername,
                socket: socket,
                rejectUnauthorized: config.rejectUnauthorized,
                ALPNProtocols: SUPPORTED_PROTOS,
                NPNProtocols: SUPPORTED_PROTOS,
                ciphers: ciphers
            }, options), handleCallback);
            socket.on('error', function (e) {
                if (!ciphers && util.isCiphersError(e)) {
                    return getProxySocket(options, callback, util.getCipher(options._rules));
                }
                else {
                    handleCallback(e);
                }
            });
        }
        catch (e) {
            handleCallback(e);
        }
    };
    const proxyOpts = options._proxyOptions;
    proxyOpts.proxyType === 'socks'
        ? getSocksSocket(options, handleConnect)
        : getTunnelSocket(options, handleConnect);
}
function getSocket(options, callback, isHttp) {
    const handleCallback = function (err, socket) {
        if (err) {
            return callback(false, null, err);
        }
        const proto = socket.alpnProtocol || socket.npnProtocol;
        callback(isHttp || proto === 'h2', socket);
    };
    options._proxyOptions
        ? getProxySocket(options, handleCallback, null, isHttp)
        : util.connect(isHttp
            ? {
                host: options.host,
                port: options.port || 80
            }
            : addCert({
                servername: options.servername,
                host: options.host,
                port: options.port || 443,
                rejectUnauthorized: config.rejectUnauthorized,
                ALPNProtocols: SUPPORTED_PROTOS,
                NPNProtocols: SUPPORTED_PROTOS,
                _rules: options._rules
            }, options), handleCallback);
}
function getClient(req, socket, name, callback) {
    const origin = (req.useHttpH2 ? 'http' : 'https') + '://' + req.headers.host;
    const client = http2.connect(origin, {
        settings: H2_SETTINGS,
        maxSessionMemory: 128,
        rejectUnauthorized: config.rejectUnauthorized,
        createConnection: function () {
            return socket;
        }
    }, function () {
        callback && callback(client);
        callback = null;
    });
    clients[name] = client;
    client._updateTime = Date.now();
    let closed;
    const handleClose = function () {
        if (!closed) {
            closed = true;
            delete clients[name];
            client.close();
            socket.destroy();
            callback && callback(client);
            callback = null;
        }
    };
    socket.on('error', handleClose);
    client.on('error', handleClose);
    socket.once('close', handleClose);
    client.once('close', handleClose);
    return client;
}
function requestH2(client, req, res, callback) {
    if (req._hasError) {
        return;
    }
    const headers = util.formatH2Headers(req.headers);
    delete req.headers.connection;
    delete req.headers['keep-alive'];
    delete req.headers['http2-settings'];
    delete req.headers['proxy-connection'];
    delete req.headers['transfer-encoding'];
    const options = req.options;
    let responsed;
    headers[':path'] = options.path;
    headers[':method'] = options.method;
    headers[':authority'] = req.headers.host;
    try {
        const h2Session = client.request(headers);
        if (req.noReqBody) {
            const errorHandler = function () {
                if (!responsed) {
                    responsed = true;
                    h2Session.destroy();
                    callback();
                }
            };
            h2Session.on('error', errorHandler);
            h2Session.once('close', errorHandler);
        }
        h2Session.on('response', function (h2Headers) {
            if (responsed) {
                return;
            }
            client._updateTime = Date.now();
            responsed = true;
            const newHeaders = {};
            const statusCode = h2Headers[':status'];
            let svrRes = h2Session;
            svrRes.on('trailers', function (trailers) {
                svrRes.trailers = trailers;
            });
            svrRes.statusCode = statusCode;
            // HTTP2 对响应内容格式要求太严格（NGHTTP2_PROTOCOL_ERROR）
            if (!util.hasBody(svrRes, req)) {
                h2Session.destroy();
                svrRes = new PassThrough();
                svrRes.statusCode = statusCode;
                svrRes.push(null);
            }
            svrRes.httpVersion = '1.1';
            svrRes.headers = newHeaders;
            Object.keys(h2Headers).forEach(function (name) {
                if (name[0] !== ':' &&
                    name !== 'content-length' &&
                    name !== 'transfer-encoding') {
                    newHeaders[name] = h2Headers[name];
                }
            });
            if (req.isPluginReq && !req._isProxyReq) {
                newHeaders[config.PROXY_ID_HEADER] = 'h2';
            }
            res.response(svrRes);
        });
        req.pipe(h2Session);
    }
    catch (e) {
        !responsed && callback();
        responsed = true;
    }
}
function bindListner(server, listener) {
    server.timeout = config.timeout;
    if (typeof listener === 'function') {
        server.on('request', listener);
    }
    else if (listener) {
        Object.keys(listener).forEach(function (name) {
            server.on(name, listener[name]);
        });
    }
    return server;
}
export const getServer = function (options, listener) {
    let server;
    if (options.allowHTTP1 && http2) {
        options.maxSessionMemory = 128;
        options.settings = H2_SVR_SETTINGS;
        server = http2.createSecureServer(options);
    }
    else {
        server = https.createServer(options);
    }
    return bindListner(server, listener);
};
export const getHttpServer = function (_, listener) {
    const server = http2.createServer({
        maxSessionMemory: 128,
        settings: H2_SVR_SETTINGS,
        allowHTTP1: true
    });
    return bindListner(server, listener);
};
function checkTlsError(err) {
    if (!err) {
        return true;
    }
    const code = err.code;
    if (typeof code !== 'string') {
        return false;
    }
    return code.indexOf('ERR_TLS_') === 0 || code.indexOf('ERR_SSL_') === 0;
}
export const request = function (req, res, callback) {
    const options = req.useH2 && req.options;
    if (!options || options.isPlugin || req._isInternalProxy) {
        return callback();
    }
    const key = getKey(options);
    let name = req.clientIp + '\n' + key;
    let client = clients[name];
    if (client) {
        if (client.curIndex) {
            name = name + '\n' + client.curIndex;
            client.curIndex = ++client.curIndex % CONCURRENT;
            client = clients[name];
        }
        else {
            client.curIndex = 1;
        }
        if (client) {
            client._updateTime = Date.now();
            return requestH2(client, req, res, callback);
        }
    }
    const time = notH2.peek(key);
    if (time && (Date.now() - time < TIMEOUT || pendingH2[key])) {
        return callback();
    }
    pendingH2[key] = 1;
    let pendingItem = pendingList[name];
    if (pendingItem) {
        return pendingItem.push([req, res, callback]);
    }
    pendingItem = [[req, res, callback]];
    pendingList[name] = pendingItem;
    options._rules = req.rules;
    const proxyOpts = options._proxyOptions;
    if (proxyOpts) {
        proxyOpts.enableIntercept = true;
        proxyOpts.proxyTunnelPath = util.getProxyTunnelPath(req, true);
    }
    getSocket(options, function (isH2, socket, err) {
        if (socket) {
            socket.secureConnecting = false; // fix: node bug
        }
        const handleH2 = function (clt) {
            delete pendingList[name];
            delete pendingH2[key];
            if (clt) {
                notH2.del(key);
                pendingItem.forEach(function (list) {
                    requestH2(clt, list[0], list[1], list[2]);
                });
            }
            else {
                checkTlsError(err) && notH2.set(key, Date.now());
                if (req.useHttpH2) {
                    socket = null;
                }
                pendingItem.forEach(function (list) {
                    list[2](socket);
                    socket = null;
                });
            }
        };
        if (isH2) {
            getClient(req, socket, name, handleH2);
        }
        else {
            handleH2();
        }
    }, req.useHttpH2);
};
