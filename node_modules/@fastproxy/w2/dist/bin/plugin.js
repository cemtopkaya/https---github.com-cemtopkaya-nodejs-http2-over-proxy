"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.run = exports.uninstall = exports.install = exports.getWhistlePath = void 0;
const tslib_1 = require("tslib");
const os_1 = tslib_1.__importDefault(require("os"));
const child_process_1 = tslib_1.__importDefault(require("child_process"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const fs_extra2_1 = tslib_1.__importDefault(require("fs-extra2"));
const commonUtil = tslib_1.__importStar(require("../lib/util/common"));
const util_1 = require("./util");
exports.getWhistlePath = commonUtil.getWhistlePath;
const REMOTE_URL_RE = commonUtil.REMOTE_URL_RE;
const CMD_SUFFIX = process.platform === 'win32' ? '.cmd' : '';
const CUSTOM_PLUGIN_PATH = path_1.default.join((0, exports.getWhistlePath)(), 'custom_plugins');
const PACKAGE_JSON = '{"repository":"https://github.com/avwo/whistle","license":"MIT"}';
const LICENSE = 'Copyright (c) 2019 avwo';
const RESP_URL = 'https://github.com/avwo/whistle';
const WHISTLE_PLUGIN_RE = /^((?:@[\w-]+\/)?whistle\.[a-z\d_-]+)(?:\@([\w.^~*-]*))?$/;
function getInstallPath(name, dir) {
    return path_1.default.join(dir || CUSTOM_PLUGIN_PATH, name);
}
function getPlugins(argv, isInstall) {
    return argv.filter(function (name, i) {
        if (WHISTLE_PLUGIN_RE.test(name)) {
            return true;
        }
        if (argv[i - 1] === '--registry') {
            return false;
        }
        return isInstall && REMOTE_URL_RE.test(name);
    });
}
function removeDir(installPath) {
    if (fs_1.default.existsSync(installPath)) {
        fs_extra2_1.default.removeSync(installPath);
    }
}
function getTempName(name) {
    if (name.indexOf('/') === -1) {
        return '.' + name;
    }
    name = name.split('/');
    const lastIndex = name.length - 1;
    name[lastIndex] = '.' + name[lastIndex];
    return name.join('/');
}
function getInstallDir(argv) {
    argv = argv.slice();
    const result = { argv: argv };
    for (let i = 0, len = argv.length; i < len; i++) {
        const option = argv[i];
        if (option && option.indexOf('--dir=') === 0) {
            const dir = option.substring(option.indexOf('=') + 1);
            result.dir = dir && path_1.default.resolve(dir);
            argv.splice(i, 1);
            return result;
        }
    }
    return result;
}
function getPluginNameFormDeps(deps) {
    const keys = Object.keys(deps);
    for (let i = 0, len = keys.length; i < len; i++) {
        if (WHISTLE_PLUGIN_RE.test(keys[i])) {
            return RegExp.$1;
        }
    }
    return;
}
function getPkgName(name) {
    if (/[/\\](whistle\.[a-z\d_-]+)(?:\.git)?$/.test(name)) {
        return RegExp.$1;
    }
    return (0, util_1.getHash)(name);
}
function installFn(cmd, name, argv, ver, pluginsCache, callback) {
    const result = getInstallDir(argv.slice());
    const isPkg = WHISTLE_PLUGIN_RE.test(name);
    const pkgName = isPkg ? name : getPkgName(name);
    const installPath = getInstallPath(getTempName(pkgName), result.dir);
    argv = result.argv;
    fs_extra2_1.default.ensureDirSync(installPath);
    fs_extra2_1.default.emptyDirSync(installPath);
    let pkgJson = PACKAGE_JSON;
    if (ver) {
        pkgJson = pkgJson.replace(',', ',"dependencies":{"' + name + '":"' + ver + '"},');
    }
    fs_1.default.writeFileSync(path_1.default.join(installPath, 'package.json'), pkgJson);
    fs_1.default.writeFileSync(path_1.default.join(installPath, 'LICENSE'), LICENSE);
    fs_1.default.writeFileSync(path_1.default.join(installPath, 'README.md'), RESP_URL);
    argv.unshift('install', name);
    pluginsCache[pkgName] = 1;
    child_process_1.default.spawn(cmd, argv, {
        stdio: 'inherit',
        cwd: installPath
    }).once('exit', function (code) {
        if (code) {
            removeDir(installPath);
            callback();
        }
        else {
            if (!isPkg) {
                const deps = fs_extra2_1.default.readJsonSync(path_1.default.join(installPath, 'package.json')).dependencies;
                name = deps && getPluginNameFormDeps(deps);
            }
            if (!name) {
                try {
                    removeDir(installPath);
                }
                catch (e) { }
                return callback();
            }
            const realPath = getInstallPath(name, result.dir);
            removeDir(realPath);
            try {
                fs_1.default.renameSync(installPath, realPath);
            }
            catch (e) {
                fs_extra2_1.default.ensureDirSync(realPath);
                fs_extra2_1.default.copySync(installPath, realPath);
                try {
                    removeDir(installPath);
                }
                catch (e) { }
            }
            const pkgPath = path_1.default.join(realPath, 'node_modules', name, 'package.json');
            try {
                if (fs_1.default.statSync(pkgPath).mtime.getFullYear() < 2010) {
                    const now = new Date();
                    fs_1.default.utimesSync(pkgPath, now, now);
                }
            }
            catch (e) { }
            callback(pkgPath);
        }
    });
}
function readJson(pkgPath) {
    try {
        return fs_extra2_1.default.readJsonSync(pkgPath);
    }
    catch (e) {
        try {
            return fs_extra2_1.default.readJsonSync(pkgPath);
        }
        catch (e) { }
    }
}
function installPlugins(cmd, plugins, argv, pluginsCache, deep = 0) {
    let count = 0;
    let peerPlugins = [];
    const callback = function (pkgPath) {
        if (pkgPath) {
            const pkg = readJson(pkgPath) || {};
            const list = pkg.whistleConfig &&
                (pkg.whistleConfig.peerPluginList || pkg.whistleConfig.peerPlugins);
            if (Array.isArray(list) && list.length < 16) {
                list.forEach(function (name) {
                    name = typeof name === 'string' ? name.trim() : null;
                    if (name &&
                        (WHISTLE_PLUGIN_RE.test(name) || REMOTE_URL_RE.test(name))) {
                        name = RegExp.$1;
                        if (peerPlugins.indexOf(name) === -1) {
                            peerPlugins.push(name);
                        }
                    }
                });
            }
        }
        if (--count <= 0 && deep < 16) {
            peerPlugins = peerPlugins.filter(function (name) {
                return !pluginsCache[name];
            });
            peerPlugins.length &&
                installPlugins(cmd, peerPlugins, argv, pluginsCache, ++deep);
        }
    };
    plugins.forEach(function (name) {
        const isPkg = WHISTLE_PLUGIN_RE.test(name);
        if (isPkg || REMOTE_URL_RE.test(name)) {
            ++count;
            name = RegExp.$1;
            const ver = RegExp.$2;
            installFn(cmd, name, argv, ver, pluginsCache, callback);
        }
    });
}
const install = function (cmd, argv) {
    const plugins = getPlugins(argv, true);
    if (!plugins.length) {
        return;
    }
    argv = argv.filter(function (name) {
        return plugins.indexOf(name) === -1;
    });
    cmd += CMD_SUFFIX;
    argv.push('--no-package-lock');
    installPlugins(cmd, plugins, argv, {});
};
exports.install = install;
const uninstall = function (plugins) {
    const result = getInstallDir(plugins);
    plugins = result.argv;
    getPlugins(plugins).forEach(function (name) {
        if (WHISTLE_PLUGIN_RE.test(name)) {
            name = RegExp.$1;
            removeDir(getInstallPath(name, result.dir));
        }
    });
};
exports.uninstall = uninstall;
const run = function (cmd, argv) {
    const newPath = [];
    fs_extra2_1.default.ensureDirSync(CUSTOM_PLUGIN_PATH);
    fs_1.default.readdirSync(CUSTOM_PLUGIN_PATH).forEach(function (name) {
        if (!name.indexOf('whistle.')) {
            newPath.push(path_1.default.join(CUSTOM_PLUGIN_PATH, name, 'node_modules/.bin'));
        }
        else if (name[0] === '@') {
            try {
                fs_1.default.readdirSync(path_1.default.join(CUSTOM_PLUGIN_PATH, name)).forEach(function (modName) {
                    newPath.push(path_1.default.join(CUSTOM_PLUGIN_PATH, name, modName, 'node_modules/.bin'));
                });
            }
            catch (e) { }
        }
    });
    process.env.PATH && newPath.push(process.env.PATH);
    process.env.PATH = newPath.join(os_1.default.platform() === 'win32' ? ';' : ':');
    child_process_1.default.spawn(cmd + CMD_SUFFIX, argv, {
        stdio: 'inherit',
        env: process.env
    });
};
exports.run = run;
