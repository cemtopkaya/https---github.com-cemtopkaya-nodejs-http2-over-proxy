"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useRules = void 0;
const tslib_1 = require("tslib");
const debug_1 = tslib_1.__importDefault(require("debug"));
const import_pkg_1 = require("../lib/import-pkg");
const module_paths_1 = require("../lib/plugins/module-paths");
const config_1 = tslib_1.__importDefault(require("../lib/config"));
const util = tslib_1.__importStar(require("./util"));
const debug = (0, debug_1.default)('@w2.bin.use');
const isRunning = util.isRunning;
const error = util.error;
const warn = util.warn;
const info = util.info;
const readConfig = util.readConfig;
const MAX_RULES_LEN = 1024 * 256;
const DEFAULT_OPTIONS = { host: '127.0.0.1', port: 8899 };
let options;
function showStartWhistleTips(storage) {
    error('No running whistle, execute `w2 start' + (storage ? ' -S ' + storage : '') + '` to start whistle on the cli.');
}
function handleRules(filepath, callback, port) {
    debug('handleRules, ', { filepath, port });
    const getRules = require(filepath);
    if (typeof getRules !== 'function') {
        return callback(getRules);
    }
    getRules(callback, {
        port: port,
        existsPlugin: existsPlugin
    });
}
function getString(str) {
    return typeof str !== 'string' ? '' : str.trim();
}
function existsPlugin(name) {
    if (!name || typeof name !== 'string') {
        return false;
    }
    const pluginPaths = (0, module_paths_1.getPaths)();
    for (let i = 0, len = pluginPaths.length; i < len; i++) {
        try {
            if (import_pkg_1.fs.statSync(import_pkg_1.path.join(pluginPaths[i], name)).isDirectory()) {
                return true;
            }
        }
        catch (e) { }
    }
    return false;
}
function getBody(res, callback) {
    let resBody = '';
    res.setEncoding('utf8');
    res.on('data', function (data) {
        resBody += data;
    });
    res.on('end', function () {
        if (res.statusCode != 200) {
            callback(resBody || 'response ' + res.statusCode + ' error');
        }
        else {
            callback(null, JSON.parse(resBody));
        }
    });
}
let reqOptions;
function request(body, callback) {
    if (!reqOptions) {
        reqOptions = import_pkg_1.url.parse('http://' + (options.host || '127.0.0.1') + ':' + options.port + '/cgi-bin/rules/project');
        reqOptions.headers = {
            'content-type': 'application/x-www-form-urlencoded'
        };
        reqOptions.method = 'POST';
        if (options.username || options.password) {
            const auth = [options.username || '', options.password || ''].join(':');
            reqOptions.headers.authorization = 'Basic ' + new Buffer(auth).toString('base64');
        }
    }
    const req = import_pkg_1.http.request(reqOptions, function (res) {
        getBody(res, function (err, data) {
            if (err) {
                throw err;
            }
            callback(data);
        });
    });
    // 不处理错误，直接抛出终止进程
    req.end(body);
}
function checkDefault(running, storage, callback) {
    if (running) {
        return callback();
    }
    const execCallback = function (err) {
        callback && callback(err);
        callback = null;
    };
    const req = import_pkg_1.http.get('http://' + DEFAULT_OPTIONS.host + ':' + DEFAULT_OPTIONS.port + '/cgi-bin/status', function (res) {
        res.on('error', execCallback);
        getBody(res, function (err, data) {
            if (err || !data || data.name !== import_pkg_1.pkgInfo.name || data.storage !== storage) {
                return execCallback(true);
            }
            callback(null, DEFAULT_OPTIONS.port);
        });
    });
    req.on('error', execCallback);
    req.end();
}
function useRules(filepath, storage, force) {
    storage = storage || '';
    const config = readConfig(storage) || '';
    options = config.options;
    const pid = options && config.pid;
    const addon = options && options.addon;
    config_1.default.addon = addon && typeof addon === 'string' ? addon.split(/[|,]/) : [];
    config_1.default.noGlobalPlugins = options && options.noGlobalPlugins;
    isRunning(pid, function (running) {
        checkDefault(running, storage, function (err, port) {
            if (err) {
                return showStartWhistleTips(storage);
            }
            filepath = import_pkg_1.path.resolve(filepath || '.whistle.js');
            if (port) {
                options = DEFAULT_OPTIONS;
            }
            else {
                port = options.port = options.port > 0 ? options.port : import_pkg_1.pkgInfo.port;
            }
            handleRules(filepath, function (result) {
                if (!result) {
                    error('The name and rules cannot be empty.');
                    return;
                }
                const name = getString(result.name);
                if (!name || name.length > 64) {
                    error('The name cannot be empty and the length cannot exceed 64 characters.');
                    return;
                }
                const rules = getString(result.rules);
                if (rules.length > MAX_RULES_LEN) {
                    error('The rules cannot be empty and the size cannot exceed 256k.');
                    return;
                }
                const setRules = function () {
                    const body = ['name=' + encodeURIComponent(name), 'rules=' + encodeURIComponent(rules)].join('&');
                    request(body, function () {
                        info('Setting whistle[' + (options.host || '127.0.0.1') + ':' + port + '] rules successful.');
                    });
                };
                if (force) {
                    return setRules();
                }
                request('name=' + encodeURIComponent(name) + '&enable=1&top=1', function (data) {
                    if (data.rules) {
                        info('Successfully enabled.');
                        warn('Warning: The rule already exists, to override the content, add CLI option --force.');
                        return;
                    }
                    setRules();
                });
            }, port);
        });
    });
}
exports.useRules = useRules;
