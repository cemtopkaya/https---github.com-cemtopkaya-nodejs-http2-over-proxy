"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getHash = exports.readConfigList = exports.readConfig = exports.formatOptions = exports.showUsage = exports.showKillError = exports.info = exports.warn = exports.error = exports.isRunning = void 0;
const tslib_1 = require("tslib");
const util_1 = tslib_1.__importDefault(require("util"));
const safe_1 = tslib_1.__importDefault(require("colors/safe"));
const import_pkg_1 = require("../lib/import-pkg");
const config_1 = tslib_1.__importDefault(require("../lib/config"));
const CHECK_RUNNING_CMD = process.platform === 'win32'
    ? 'tasklist /fi "PID eq %s" | findstr /i "node.exe"'
    : 'ps -f -p %s | grep "node"';
const isWin = process.platform === 'win32';
function isRunning(pid, callback) {
    pid
        ? import_pkg_1.cp.exec(util_1.default.format(CHECK_RUNNING_CMD, pid), function (err, stdout, _stderr) {
            callback(!err && !!stdout.toString().trim());
        })
        : callback();
}
exports.isRunning = isRunning;
function getIpList() {
    const ipList = [];
    const ifaces = import_pkg_1.os.networkInterfaces();
    Object.keys(ifaces).forEach(function (ifname) {
        ifaces[ifname]?.forEach(function (iface) {
            if (iface.family == 'IPv4' || iface.family === 4) {
                ipList.push(iface.address);
            }
        });
    });
    const index = ipList.indexOf('127.0.0.1');
    if (index !== -1) {
        ipList.splice(index, 1);
    }
    ipList.unshift('127.0.0.1');
    return ipList;
}
function error(msg) {
    console.log(safe_1.default.red(msg));
}
exports.error = error;
function warn(msg) {
    console.log(safe_1.default.yellow(msg));
}
exports.warn = warn;
function info(msg) {
    console.log(safe_1.default.green(msg));
}
exports.info = info;
function showKillError() {
    error('[!] Cannot kill ' + config_1.default.name + ' owned by root');
    info('[i] Try to run command ' + (isWin ? 'as an administrator' : 'with `sudo`'));
}
exports.showKillError = showKillError;
function showUsage(isRunning, options, restart) {
    options = formatOptions(options);
    if (isRunning) {
        if (restart) {
            showKillError();
        }
        else {
            warn('[!] ' + config_1.default.name + '@' + config_1.default.version + ' is running');
        }
    }
    else {
        info('[i] ' +
            config_1.default.name +
            '@' +
            config_1.default.version +
            (restart ? ' restarted' : ' started'));
    }
    const port = /^\d+$/.test(options.port) && options.port > 0 ? options.port : config_1.default.port;
    const list = options.host ? [options.host] : getIpList();
    info('[i] 1. use your device to visit the following URL list, gets the ' +
        safe_1.default.bold('IP') +
        ' of the URL you can access:');
    info(list
        .map(function (ip) {
        return ('       http://' +
            safe_1.default.bold(ip) +
            (port && port != 80 ? ':' + port : '') +
            '/');
    })
        .join('\n'));
    warn('       Note: If all the above URLs are unable to access, check the firewall settings');
    warn('             For help see ' +
        safe_1.default.bold('https://github.com/avwo/whistle'));
    info('[i] 2. set the HTTP proxy on your device with ' +
        safe_1.default.bold((list.length === 1 ? 'IP(' + list[0] + ')' : 'the above IP') +
            ' & PORT(' +
            port +
            ')'));
    info('[i] 3. use ' +
        safe_1.default.bold('Chrome') +
        ' to visit ' +
        safe_1.default.bold('http://' + (options.localUIHost || config_1.default.localUIHost) + '/') +
        ' to get started');
    if (parseInt(process.version.slice(1), 10) < 6) {
        warn(safe_1.default.bold('\nWarning: The current Node version is too low, access https://nodejs.org to install the latest version, or may not be able to Capture HTTPS CONNECTs\n'));
    }
}
exports.showUsage = showUsage;
function getDataDir() {
    return import_pkg_1.path.resolve(config_1.default.getHomedir(), '.startingAppData');
}
function formatOptions(options) {
    if (!options || !/^(?:([\w.-]+):)?([1-9]\d{0,4})$/.test(options.port)) {
        return options;
    }
    options.host = options.host || RegExp.$1;
    options.port = parseInt(RegExp.$2, 10);
    return options;
}
exports.formatOptions = formatOptions;
function readConfig(storage) {
    const dataDir = getDataDir();
    const configFile = import_pkg_1.path.join(dataDir, encodeURIComponent('#' + (storage ? storage + '#' : '')));
    if (!import_pkg_1.fs.existsSync(configFile)) {
        return;
    }
    try {
        const conf = import_pkg_1.fse.readJsonSync(configFile);
        conf && formatOptions(conf.options);
        return conf;
    }
    catch (e) { }
}
exports.readConfig = readConfig;
function readConfigList() {
    const dataDir = getDataDir();
    const result = [];
    try {
        import_pkg_1.fs.readdirSync(dataDir).forEach(function (dir) {
            try {
                dir = decodeURIComponent(dir);
                const lastIndex = dir.length - 1;
                if (dir[0] === '#' && dir[lastIndex] === '#') {
                    dir = dir.substring(1, lastIndex || 1);
                    const config = readConfig(dir);
                    if (config && config.pid && config.options) {
                        result.push(config);
                    }
                }
            }
            catch (e) { }
        });
    }
    catch (e) { }
    return result;
}
exports.readConfigList = readConfigList;
const getHash = function (str) {
    const hmac = (0, import_pkg_1.createHmac)('sha256', 'a secret');
    return hmac.update(str).digest('hex');
};
exports.getHash = getHash;
