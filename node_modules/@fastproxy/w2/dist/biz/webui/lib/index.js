"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleRequest = exports.setupServer = exports.getProxy = exports.init = void 0;
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const url_1 = tslib_1.__importDefault(require("url"));
const http_1 = tslib_1.__importDefault(require("http"));
const https_1 = tslib_1.__importDefault(require("https"));
const crypto_1 = tslib_1.__importDefault(require("crypto"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const zlib_1 = tslib_1.__importDefault(require("zlib"));
const parseurl_1 = tslib_1.__importDefault(require("parseurl"));
const body_parser_1 = tslib_1.__importDefault(require("body-parser"));
const cookie_1 = tslib_1.__importDefault(require("cookie"));
const basic_auth_1 = tslib_1.__importDefault(require("basic-auth"));
const express_1 = tslib_1.__importDefault(require("express"));
const extend_1 = tslib_1.__importDefault(require("extend"));
const ca_1 = require("../../../lib/https/ca");
const config_1 = tslib_1.__importDefault(require("../../../lib/config"));
const plugins_1 = require("../../../lib/plugins");
const weinre_1 = tslib_1.__importDefault(require("../../weinre"));
const htdocs = tslib_1.__importStar(require("../htdocs"));
const app = (0, express_1.default)();
const PARSE_CONF = { extended: true, limit: '3mb' };
const UPLOAD_PARSE_CONF = { extended: true, limit: '30mb' };
const urlencodedParser = body_parser_1.default.urlencoded(PARSE_CONF);
const jsonParser = body_parser_1.default.json(PARSE_CONF);
const uploadUrlencodedParser = body_parser_1.default.urlencoded(UPLOAD_PARSE_CONF);
const uploadJsonParser = body_parser_1.default.json(UPLOAD_PARSE_CONF);
const GET_METHOD_RE = /^get$/i;
const WEINRE_RE = /^\/weinre\/.*/;
const ALLOW_PLUGIN_PATHS = ['/cgi-bin/rules/list2', '/cgi-bin/values/list2', '/cgi-bin/get-custom-certs-info'];
const DONT_CHECK_PATHS = [
    '/cgi-bin/server-info',
    '/cgi-bin/plugins/is-enable',
    '/cgi-bin/plugins/get-plugins',
    '/preview.html',
    '/cgi-bin/rootca',
    '/cgi-bin/log/set',
    '/cgi-bin/status'
];
const GUEST_PATHS = [
    '/cgi-bin/composer',
    '/cgi-bin/socket/data',
    '/cgi-bin/abort',
    '/cgi-bin/socket/abort',
    '/cgi-bin/socket/change-status',
    '/cgi-bin/sessions/export'
];
const PLUGIN_PATH_RE = /^\/(whistle|plugin)\.([^/?#]+)(\/)?/;
const STATIC_SRC_RE = /\.(?:ico|js|css|png)$/i;
const UPLOAD_URLS = ['/cgi-bin/values/upload', '/cgi-bin/composer'];
let proxyEvent;
let util;
let pluginMgr;
const MAX_AGE = 60 * 60 * 24 * 3;
const assetsDir = (file) => path_1.default.resolve(__dirname, '../../../../assets', file);
const MENU_HTML = assetsDir('menu.html');
const INSPECTOR_HTML = assetsDir('tab.html');
const MENU_URL = '???_WHISTLE_PLUGIN_EXT_CONTEXT_MENU_' + config_1.default.port + '???';
const INSPECTOR_URL = '???_WHISTLE_PLUGIN_INSPECTOR_TAB_' + config_1.default.port + '???';
const UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
function doNotCheckLogin(req) {
    const path = req.path;
    return STATIC_SRC_RE.test(path) || DONT_CHECK_PATHS.indexOf(path) !== -1;
}
function getUsername() {
    return config_1.default.username || '';
}
function getPassword() {
    return config_1.default.password || '';
}
function shasum(str) {
    const shasum = crypto_1.default.createHash('sha1');
    shasum.update(str || '');
    return shasum.digest('hex');
}
function getLoginKey(req, res, auth) {
    const ip = util.getClientIp(req);
    let password = auth.password;
    if (config_1.default.encrypted) {
        password = shasum(password);
    }
    return shasum([auth.username, password, ip].join('\n'));
}
function requireLogin(res, msg) {
    res.setHeader('WWW-Authenticate', ' Basic realm=User Login');
    res.setHeader('Content-Type', 'text/html; charset=utf8');
    res.status(401).end(msg || 'Access denied, please <a href="javascript:;" onclick="location.reload()">try again</a>.');
}
function verifyLogin(req, res, auth) {
    const isGuest = !auth;
    if (isGuest) {
        auth = config_1.default.guest;
        if (!auth) {
            return false;
        }
        if (!auth.authKey) {
            auth.authKey = 'whistle_v_lk_' + encodeURIComponent(auth.username);
        }
    }
    const username = auth.username;
    const password = auth.password;
    if (!username && !password) {
        return true;
    }
    const authKey = auth.authKey;
    const cookies = cookie_1.default.parse(req.headers.cookie || '');
    const lkey = cookies[authKey];
    const correctKey = getLoginKey(req, res, auth);
    if (correctKey === lkey) {
        return true;
    }
    auth = (0, basic_auth_1.default)(req) || {};
    if (!isGuest && config_1.default.encrypted) {
        auth.pass = shasum(auth.pass);
    }
    if (auth.name === username && auth.pass === password) {
        const options = {
            expires: new Date(Date.now() + MAX_AGE * 1000),
            maxAge: MAX_AGE,
            path: '/'
        };
        res.setHeader('Set-Cookie', cookie_1.default.serialize(authKey, correctKey, options));
        return true;
    }
    return false;
}
function checkAuth(req, res) {
    const username = getUsername();
    const auth = {
        authKey: 'whistle_lk_' + encodeURIComponent(username),
        username: username,
        password: getPassword()
    };
    if (verifyLogin(req, res, auth)) {
        return true;
    }
    requireLogin(res);
    return false;
}
app.disable('x-powered-by');
function readRemoteStream(req, res, authUrl) {
    let client;
    const handleError = function (err) {
        res.emit('error', err);
        client && client.destroy();
    };
    if (authUrl[0] === 'f') {
        const stream = fs_1.default.createReadStream(authUrl.substring(7));
        stream.on('error', handleError);
        return stream.pipe(res);
    }
    const options = url_1.default.parse(authUrl);
    options.rejectUnauthorized = false;
    const httpModule = options.protocol === 'https:' ? https_1.default : http_1.default;
    const headers = (0, extend_1.default)({}, req.headers);
    delete headers.host;
    options.headers = headers;
    client = httpModule.request(options, function (svrRes) {
        svrRes.on('error', handleError);
        res.writeHead(svrRes.statusCode, svrRes.headers);
        svrRes.pipe(res);
    });
    client.on('error', handleError);
    client.end();
}
app.use(function (req, res, next) {
    proxyEvent.emit('_request', req.url);
    let aborted = false;
    const abort = function () {
        if (!aborted) {
            aborted = true;
            res.destroy();
        }
    };
    req.on('error', abort);
    res.on('error', abort).on('close', abort);
    plugins_1.pluginMgr.loadAuthPlugins(req, function (status, msg, authUrl) {
        if (!status && !authUrl) {
            return next();
        }
        res.set('x-server', 'whistle');
        res.set('x-module', 'webui');
        if (!msg && !authUrl) {
            return res.redirect(status);
        }
        if (status === 401) {
            return requireLogin(res, msg);
        }
        res.set('Content-Type', 'text/html; charset=utf8');
        if (authUrl) {
            return readRemoteStream(req, res, authUrl);
        }
        if (status === 502) {
            return res.status(502).end(msg || 'Error');
        }
        res.status(403).end(msg || 'Forbidden');
    });
});
if (typeof config_1.default.uiMiddleware === 'function') {
    app.use(config_1.default.uiMiddleware);
}
app.use(function (req, res, next) {
    const referer = req.headers.referer;
    const options = (0, parseurl_1.default)(req);
    const path = options.path;
    const index = path.indexOf('/whistle/');
    req.url = path;
    let pluginName;
    if (index === 0) {
        delete req.headers.referer;
        req.url = path.substring(8);
    }
    else if (PLUGIN_PATH_RE.test(options.pathname)) {
        pluginName = RegExp['$&'];
        const len = pluginName.length - 1;
        if (len === index) {
            delete req.headers.referer;
            req.url = path.substring(len + 8);
        }
    }
    else {
        pluginName = config_1.default.getPluginNameByHost(req.headers.host);
        if (!pluginName && referer) {
            const refOpts = url_1.default.parse(referer);
            const pathname = refOpts.pathname;
            if (PLUGIN_PATH_RE.test(pathname) && RegExp.$3) {
                req.url = '/' + RegExp.$1 + '.' + RegExp.$2 + path;
            }
            else {
                pluginName = config_1.default.getPluginNameByHost(refOpts.hostname);
            }
        }
        if (pluginName) {
            req.url = '/whistle.' + pluginName + path;
        }
    }
    next();
});
app.use(function (req, res, next) {
    if (req.headers.host !== 'rootca.pro') {
        return next();
    }
    res.download((0, ca_1.getRootCAFile)(), 'rootCA.' + (req.path.indexOf('/cer') ? 'crt' : 'cer'));
});
async function cgiHandler(req, res) {
    if (UP_PATH_REGEXP.test(req.path)) {
        return res.status(403).end('Forbidden');
    }
    if (req.headers.origin) {
        res.setHeader('access-control-allow-origin', req.headers.origin);
        res.setHeader('access-control-allow-credentials', true);
    }
    const filepath = path_1.default.join(__dirname, '../' + req.path) + '.js';
    // debug(`:cgiHandler filepath=${filepath}`);
    const handleResponse = async function () {
        var _a;
        try {
            const middle = filepath.endsWith('.ts') ? await (_a = filepath, Promise.resolve().then(() => tslib_1.__importStar(require(_a)))) : require(filepath);
            (middle.default || middle)(req, res);
        }
        catch (err) {
            const msg = config_1.default.debugMode ? '<pre>' + util.getErrorStack(err) + '</pre>' : 'Internal Server Error';
            res.status(500).send(msg);
        }
    };
    if (require.cache[filepath]) {
        return handleResponse();
    }
    fs_1.default.stat(filepath, function (err, stat) {
        if (err || !stat.isFile()) {
            const notFound = err ? err.code === 'ENOENT' : !stat.isFile();
            let msg;
            if (config_1.default.debugMode) {
                msg = '<pre>' + (err ? util.getErrorStack(err) : 'Not File') + '</pre>';
            }
            else {
                msg = notFound ? 'Not Found' : 'Internal Server Error';
            }
            return res.status(notFound ? 404 : 500).send(msg);
        }
        handleResponse();
    });
}
app.all('/cgi-bin/sessions/*', cgiHandler);
app.all('/favicon.ico', function (req, res) {
    res.sendFile(htdocs.getImgFile('favicon.ico'));
});
function readPluginPage(req, res, plugin, html, config) {
    res.type('html');
    res.write(config);
    res.write(html);
    const index = req.path.indexOf('/', 1);
    if (index === -1) {
        res.end();
    }
    else {
        const filepath = req.path.substring(index + 1);
        let reader = fs_1.default.createReadStream(path_1.default.join(plugin.path, filepath));
        reader.on('error', function () {
            if (reader) {
                reader = null;
                res.end();
            }
        });
        reader.pipe(res);
    }
}
app.all(PLUGIN_PATH_RE, function (req, res) {
    const result = PLUGIN_PATH_RE.exec(req.url) || [];
    const type = result[1];
    const name = result[2];
    const slash = result[3];
    const plugin = type === 'whistle' ? pluginMgr.getPlugin(name + ':') : pluginMgr.getPluginByName(name);
    if (!plugin) {
        return res.status(404).send('Not Found');
    }
    if (req.url.indexOf(MENU_URL) !== -1) {
        return readPluginPage(req, res, plugin, MENU_HTML, plugin[util.PLUGIN_MENU_CONFIG]);
    }
    if (req.url.indexOf(INSPECTOR_URL) !== -1) {
        return readPluginPage(req, res, plugin, INSPECTOR_HTML, plugin[util.PLUGIN_INSPECTOR_CONFIG]);
    }
    const internalId = req.headers['x-whistle-internal-id'];
    if (internalId === util.INTERNAL_ID) {
        delete req.headers['x-whistle-internal-id'];
    }
    else if (plugin.inheritAuth && !checkAuth(req, res)) {
        return;
    }
    if (!slash) {
        return res.redirect(type + '.' + name + '/');
    }
    pluginMgr.loadPlugin(plugin, function (err, ports) {
        if (err || !ports.uiPort) {
            if (err) {
                res.status(500).send('<pre>' + err + '</pre>');
            }
            else {
                res.status(404).send('Not Found');
            }
            return;
        }
        const options = (0, parseurl_1.default)(req);
        const headers = req.headers;
        headers[config_1.default.PLUGIN_HOOK_NAME_HEADER] = config_1.default.PLUGIN_HOOKS.UI;
        headers['x-whistle-remote-address'] = req._remoteAddr || util.getRemoteAddr(req);
        headers['x-whistle-remote-port'] = req._remotePort || util.getRemotePort(req);
        req.url = options?.path?.replace(result[0].slice(0, -1), '');
        util.transformReq(req, res, ports.uiPort);
    });
});
app.use(function (req, res, next) {
    if (ALLOW_PLUGIN_PATHS.indexOf(req.path) !== -1) {
        const name = req.headers[config_1.default.PROXY_ID_HEADER];
        if (name) {
            return pluginMgr.getPlugin(name + ':') ? next() : res.sendStatus(403);
        }
    }
    if (doNotCheckLogin(req)) {
        return next();
    }
    if (config_1.default.disableWebUI && !config_1.default.debugMode) {
        return res.status(404).end('Not Found');
    }
    if (config_1.default.authKey && config_1.default.authKey === req.headers['x-whistle-auth-key']) {
        return next();
    }
    const guestAuthKey = config_1.default.guestAuthKey;
    if (((guestAuthKey && guestAuthKey === req.headers['x-whistle-guest-auth-key']) || verifyLogin(req, res)) &&
        (!req.method || GET_METHOD_RE.test(req.method) || WEINRE_RE.test(req.path) || GUEST_PATHS.indexOf(req.path) !== -1)) {
        return next();
    }
    if (checkAuth(req, res)) {
        next();
    }
});
app.all('/cgi-bin/*', function (req, res, next) {
    req.isUploadReq = UPLOAD_URLS.indexOf(req.path) !== -1;
    return req.isUploadReq ? uploadUrlencodedParser(req, res, next) : urlencodedParser(req, res, next);
}, function (req, res, next) {
    return req.isUploadReq ? uploadJsonParser(req, res, next) : jsonParser(req, res, next);
}, cgiHandler);
app.use('/preview.html', function (req, res, next) {
    if (req.headers[config_1.default.INTERNAL_ID_HEADER] !== config_1.default.INTERNAL_ID) {
        return res.status(404).end('Not Found');
    }
    next();
    const index = req.path.indexOf('=') + 1;
    if (index) {
        const charset = req.path.substring(index);
        res.set('content-type', 'text/html;charset=' + charset);
    }
});
if (!config_1.default.debugMode) {
    const indexHtml = fs_1.default.readFileSync(htdocs.getHtmlFile('index.html'));
    const indexJs = fs_1.default.readFileSync(htdocs.getJsFile('index.js'));
    const jsETag = shasum(indexJs);
    const gzipIndexJs = zlib_1.default.gzipSync(indexJs);
    app.use('/js/index.js', function (req, res) {
        if (req.headers['if-none-match'] === jsETag) {
            return res.sendStatus(304);
        }
        const headers = {
            'Content-Type': 'application/javascript; charset=utf-8',
            'Cache-Control': 'public, max-age=300',
            ETag: jsETag
        };
        if (util.canGzip(req)) {
            headers['Content-Encoding'] = 'gzip';
            res.writeHead(200, headers);
            res.end(gzipIndexJs);
        }
        else {
            res.writeHead(200, headers);
            res.end(indexJs);
        }
    });
    const sendIndex = function (req, res) {
        res.writeHead(200, {
            'Content-Type': 'text/html; charset=utf-8'
        });
        res.end(indexHtml);
    };
    app.get('/', sendIndex);
    app.get('/index.html', sendIndex);
}
app.get('/', function (req, res) {
    res.sendFile(htdocs.getHtmlFile('index.html'));
});
app.all(WEINRE_RE, function (req, res) {
    const options = (0, parseurl_1.default)(req);
    if (options?.pathname === '/weinre/client') {
        return res.redirect('client/' + (options.search || ''));
    }
    req.url = options?.path?.replace('/weinre', '');
    (0, weinre_1.default)(req, res);
});
function init(proxy) {
    if (proxyEvent) {
        return;
    }
    proxyEvent = proxy;
    pluginMgr = proxy.pluginMgr;
    util = proxy.util;
}
exports.init = init;
const getProxy = () => proxyEvent;
exports.getProxy = getProxy;
app.use(express_1.default.static(htdocs.htdocsRoot(), { maxAge: 300000 }));
const setupServer = function (server) {
    server.on('request', app);
};
exports.setupServer = setupServer;
exports.handleRequest = app;
