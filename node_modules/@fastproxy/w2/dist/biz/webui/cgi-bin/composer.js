"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const http_1 = tslib_1.__importDefault(require("http"));
const zlib_1 = require("zlib");
const tls_1 = tslib_1.__importDefault(require("tls"));
const crypto_1 = tslib_1.__importDefault(require("crypto"));
const safe_buffer_1 = require("safe-buffer");
const extend_1 = tslib_1.__importDefault(require("extend"));
const ws_parser_1 = tslib_1.__importDefault(require("ws-parser"));
const hparser_1 = tslib_1.__importDefault(require("hparser"));
const common = tslib_1.__importStar(require("../../../lib/util/common"));
const config_1 = tslib_1.__importDefault(require("../../../lib/config"));
const util = tslib_1.__importStar(require("../../../lib/util"));
const zlib = tslib_1.__importStar(require("../../../lib/util/zlib"));
const util_1 = require("../../../lib/rules/util");
const formatHeaders = hparser_1.default.formatHeaders;
const getRawHeaders = hparser_1.default.getRawHeaders;
const getRawHeaderNames = hparser_1.default.getRawHeaderNames;
const parseReq = hparser_1.default.parse;
const MAX_LENGTH = 1024 * 512;
const MAX_REQ_COUNT = 100;
const TLS_PROTOS = 'https:,wss:,tls:'.split(',');
const PROXY_OPTS = {
    host: config_1.default.host || '127.0.0.1',
    port: config_1.default.port
};
function parseHeaders(headers, rawHeaderNames, clientId) {
    const type = headers && typeof headers;
    if (type != 'string' && type !== 'object') {
        return {};
    }
    let reqHeaders = type === 'object' ? headers : util.parseRawJson(headers);
    if (reqHeaders) {
        reqHeaders = util.lowerCaseify(reqHeaders, rawHeaderNames);
    }
    else {
        reqHeaders = util.parseHeaders(headers, rawHeaderNames);
    }
    if (clientId && reqHeaders[config_1.default.CLIENT_ID_HEADER] !== clientId) {
        reqHeaders[config_1.default.COMPOSER_CLIENT_ID_HEADER] = clientId;
    }
    return reqHeaders;
}
function drain(socket) {
    socket.on('error', util.noop);
    socket.on('data', util.noop);
}
function getReqCount(count) {
    return count > 0 ? Math.min(count, MAX_REQ_COUNT) : 1;
}
function handleConnect(options, cb, count) {
    count = getReqCount(count);
    options.headers['x-whistle-policy'] = 'tunnel';
    const origOpts = options;
    const lastIndex = count - 1;
    for (let i = 0; i < count; i++) {
        let execCb;
        if (i === lastIndex) {
            execCb = cb;
        }
        else {
            options = (0, extend_1.default)({}, origOpts);
        }
        config_1.default
            .connect({
            host: options.hostname,
            port: options.port || 443,
            proxyHost: PROXY_OPTS.host,
            proxyPort: PROXY_OPTS.port,
            headers: options.headers
        }, function (socket, svrRes, err) {
            if (err) {
                return execCb && execCb(err);
            }
            if (!err) {
                if (TLS_PROTOS.indexOf(options.protocol) !== -1) {
                    socket = tls_1.default.connect({
                        rejectUnauthorized: config_1.default.rejectUnauthorized,
                        socket: socket,
                        servername: options.hostname
                    });
                }
                drain(socket);
                let data = options.body;
                if (data && data.length) {
                    socket.write(data);
                    options.body = data = null;
                }
            }
            execCb &&
                execCb(null, {
                    statusCode: svrRes.statusCode,
                    headers: svrRes.headers
                });
        })
            .on('error', execCb || util.noop);
    }
}
function getReqRaw(options) {
    const headers = options.headers;
    const statusLine = options.method + ' ' + (options.path || '/') + ' ' + 'HTTP/1.1';
    const raw = [statusLine, getRawHeaders(headers)];
    return raw.join('\r\n') + '\r\n\r\n';
}
function handleWebSocket(options, cb, count) {
    count = getReqCount(count);
    if (options.protocol === 'https:' || options.protocol === 'wss:') {
        options.headers[config_1.default.HTTPS_FIELD] = 1;
    }
    const binary = !!options.headers['x-whistle-frame-binary'];
    delete options.headers['x-whistle-frame-binary'];
    const origOpts = options;
    const lastIndex = count - 1;
    for (let i = 0; i < count; i++) {
        let execCb;
        if (i === lastIndex) {
            execCb = cb;
        }
        else {
            options = (0, extend_1.default)({}, origOpts);
        }
        util.connect(PROXY_OPTS, function (err, socket) {
            if (err) {
                execCb && execCb(err);
            }
            else {
                socket.write(getReqRaw(options));
                let data = options.body;
                if ((!data || !data.length) && !cb) {
                    return drain(socket);
                }
                parseReq(socket, function (e) {
                    if (e) {
                        socket.destroy();
                        return execCb && execCb(e);
                    }
                    const statusCode = socket.statusCode;
                    if (statusCode == 101) {
                        if (data) {
                            if (common.isWebSocket(socket.headers)) {
                                ws_parser_1.default.getSender(socket).send(data, {
                                    mask: true,
                                    binary: binary
                                }, util.noop);
                            }
                            else {
                                socket.write(data);
                            }
                            options.body = data = null;
                        }
                        socket.body = '';
                        drain(socket);
                    }
                    else {
                        socket.destroy();
                    }
                    execCb &&
                        execCb(null, {
                            statusCode: statusCode,
                            headers: socket.headers || {},
                            body: socket.body || ''
                        });
                }, true);
            }
        });
    }
}
function handleHttp(options, cb, count) {
    count = getReqCount(count);
    if (options.protocol === 'https:') {
        options.headers[config_1.default.HTTPS_FIELD] = 1;
    }
    options.protocol = null;
    options.hostname = null;
    options.host = PROXY_OPTS.host;
    options.port = PROXY_OPTS.port;
    const origOpts = options;
    const lastIndex = count - 1;
    for (let i = 0; i < count; i++) {
        let execCb;
        if (i === lastIndex) {
            execCb = cb;
        }
        else {
            options = (0, extend_1.default)({}, origOpts);
        }
        const client = http_1.default.request(options, function (res) {
            if (execCb) {
                res.on('error', execCb);
                let buffer;
                res.on('data', function (data) {
                    if (buffer !== null) {
                        buffer = buffer ? safe_buffer_1.Buffer.concat([buffer, data]) : data;
                        if (buffer.length > MAX_LENGTH) {
                            buffer = null;
                        }
                    }
                });
                res.on('end', function () {
                    zlib.unzip(res.headers['content-encoding'], buffer, function (err, body) {
                        const headers = res.headers;
                        if (typeof headers.trailer === 'string' &&
                            headers.trailer.indexOf(',') !== -1) {
                            headers.trailer = headers.trailer.split(',');
                        }
                        const result = {
                            statusCode: res.statusCode,
                            headers: headers,
                            trailers: res.trailers,
                            rawHeaderNames: getRawHeaderNames(res.rawHeaders),
                            rawTrailerNames: getRawHeaderNames(res.rawTrailers)
                        };
                        if (err) {
                            result.body = err.stack;
                        }
                        else if (body) {
                            result.base64 = body.toString('base64');
                        }
                        execCb(null, result);
                    });
                });
            }
            else {
                drain(res);
            }
        });
        client.on('error', execCb || util.noop);
        client.end(options.body);
        options.body = null;
    }
}
function getCharset(headers) {
    const charset = headers && headers['x-whistle-charset'];
    return charset || util.getCharset(headers['content-type']);
}
function default_1(req, res) {
    let fullUrl = req.body.url;
    if (!fullUrl || typeof fullUrl !== 'string') {
        return res.json({ ec: 0 });
    }
    fullUrl = util.encodeNonLatin1Char(fullUrl.replace(/#.*$/, ''));
    const options = util.parseUrl(util.setProtocol(fullUrl));
    if (!options.host) {
        return res.json({ ec: 0 });
    }
    let protocol = options.protocol;
    if (protocol) {
        options.protocol = protocol = protocol.toLowerCase();
    }
    const rawHeaderNames = {};
    const clientId = req.headers[config_1.default.CLIENT_ID_HEADER];
    const headers = parseHeaders(req.body.headers, rawHeaderNames, clientId);
    const method = util.getMethod(req.body.method);
    const isWebSocket = method === 'WEBSOCKET';
    delete headers[config_1.default.WEBUI_HEAD];
    headers[config_1.default.REQ_FROM_HEADER] = 'W2COMPOSER';
    headers.host = options.host;
    options.clientId = clientId;
    const clientIp = util.getClientIp(req);
    if (!util.isLocalAddress(clientIp)) {
        headers[config_1.default.CLIENT_IP_HEAD] = clientIp;
    }
    headers[config_1.default.CLIENT_PORT_HEAD] = util.getClientPort(req);
    options.method = method;
    const isConn = common.isConnect(options);
    const isWs = !isConn && (isWebSocket || common.isUpgrade(options, headers));
    const useH2 = req.body.useH2 || req.body.isH2;
    req.body.useH2 = false;
    if (isWs) {
        headers.connection = 'Upgrade';
        headers.upgrade = (!isWebSocket && headers.upgrade) || 'websocket';
        headers['sec-websocket-version'] = 13;
        if (isWebSocket || common.isWebSocket(headers)) {
            headers['sec-websocket-key'] = crypto_1.default
                .randomBytes(16)
                .toString('base64');
        }
    }
    else {
        headers.connection = 'close';
        delete headers.upgrade;
        if (!isConn &&
            ((useH2 && (protocol === 'https:' || protocol === 'http:')) ||
                protocol === 'h2:' ||
                protocol === 'http2:')) {
            req.body.useH2 = true;
            const isHttp = protocol === 'http:';
            options.protocol = isHttp ? 'http:' : 'https:';
            headers[config_1.default.ALPN_PROTOCOL_HEADER] = isHttp ? 'httpH2' : 'h2';
        }
    }
    !req.body.noStore && util_1.properties.addHistory(req.body);
    const getBody = function (cb) {
        const base64 = req.body.base64;
        let body = base64 || req.body.body;
        if (!isWs) {
            delete headers.trailer;
        }
        if (isWs || isConn || util.hasRequestBody(options)) {
            body =
                body && util.toBuffer(body, base64 ? 'base64' : getCharset(headers));
            options.body = body;
            if (!isWs && !isConn && body && req.body.isGzip) {
                (0, zlib_1.gzip)(body, function (err, gzipData) {
                    if (err) {
                        return cb(err);
                    }
                    headers['content-encoding'] = 'gzip';
                    if ('content-length' in headers) {
                        headers['content-length'] = gzipData.length;
                    }
                    else {
                        delete headers['content-length'];
                    }
                    options.body = gzipData;
                    cb();
                });
                return;
            }
            if ('content-length' in headers) {
                if (isWs || isConn) {
                    delete headers['content-length'];
                }
                else {
                    headers['content-length'] = body ? body.length : '0';
                }
            }
        }
        else {
            delete headers['content-length'];
        }
        delete headers['content-encoding'];
        cb();
    };
    getBody(function (err) {
        options.headers = formatHeaders(headers, rawHeaderNames);
        let done = false;
        const needResponse = req.query.needResponse || req.body.needResponse;
        const handleResponse = needResponse
            ? function (err, data) {
                if (done) {
                    return;
                }
                done = true;
                if (err) {
                    res.json({
                        ec: 0,
                        res: {
                            statusCode: err.statusCode ? parseInt(err.statusCode, 10) : 502,
                            headers: '',
                            body: err.stack
                        }
                    });
                    return;
                }
                res.json({ ec: 0, em: 'success', res: data || '' });
            }
            : null;
        if (err) {
            return handleResponse?.(err);
        }
        let count = req.body.repeatCount;
        count = count > 0 ? count : req.body.repeatTimes;
        if (isWs) {
            options.method = 'GET';
            handleWebSocket(options, handleResponse, count);
        }
        else if (isConn) {
            handleConnect(options, handleResponse, count);
        }
        else {
            handleHttp(options, handleResponse, count);
        }
        if (!handleResponse) {
            res.json({ ec: 0, em: 'success' });
        }
    });
}
exports.default = default_1;
