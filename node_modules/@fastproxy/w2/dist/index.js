"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWhistlePath = void 0;
const tslib_1 = require("tslib");
require("./lib/util/patch");
const debug_1 = tslib_1.__importDefault(require("debug"));
const import_pkg_1 = require("./lib/import-pkg");
const config_1 = tslib_1.__importDefault(require("./lib/config"));
const common = tslib_1.__importStar(require("./lib/util/common"));
const index_1 = tslib_1.__importDefault(require("./lib/index"));
const debug = (0, debug_1.default)('@w2.index');
exports.getWhistlePath = common.getWhistlePath;
const ver = process.version.substring(1).split('.');
const PROD_RE = /(^|\|)prod(uction)?($|\|)/;
const noop = function (..._args) { };
const state = {};
const INTERVAL = 1000;
const TIMEOUT = 10000;
const MASTER_TIMEOUT = 12000;
if (parseInt(ver[0], 10) >= 7 && parseInt(ver[1], 10) >= 7) {
    const connect = import_pkg_1.net.Socket.prototype.connect;
    if (typeof connect === 'function') {
        //fix: Node v7.7.0+引入的 `"listener" argument must be a function` 问题
        import_pkg_1.net.Socket.prototype.connect = function (options, cb) {
            if (options && typeof options === 'object' && typeof cb !== 'function') {
                return connect.call(this, options);
            }
            return connect.apply(this, [options, cb]);
        };
    }
}
const env = process.env || '';
env.WHISTLE_ROOT = __dirname;
if (typeof import_pkg_1.tls.checkServerIdentity === 'function') {
    const checkServerIdentity = import_pkg_1.tls.checkServerIdentity;
    import_pkg_1.tls.checkServerIdentity = function (...args) {
        try {
            return checkServerIdentity.apply(this, args);
        }
        catch (err) {
            return err;
        }
    };
}
if (env.WHISTLE_PLUGIN_EXEC_PATH) {
    env.PFORK_EXEC_PATH = env.WHISTLE_PLUGIN_EXEC_PATH;
}
function isPipeName(s) {
    return typeof s === 'string' && toNumber(s) === false;
}
function toNumber(x) {
    return (x = Number(x)) >= 0 ? x : false;
}
if (!import_pkg_1.net._normalizeConnectArgs) {
    //Returns an array [options] or [options, cb]
    //It is the same as the argument of Socket.prototype.connect().
    import_pkg_1.net._normalizeConnectArgs = function (...args) {
        let options = {};
        if (args[0] !== null && typeof args[0] === 'object') {
            // connect(options, [cb])
            options = args[0];
        }
        else if (isPipeName(args[0])) {
            // connect(path, [cb]);
            options.path = args[0];
        }
        else {
            // connect(port, [host], [cb])
            options.port = args[0];
            if (typeof args[1] === 'string') {
                options.host = args[1];
            }
        }
        const cb = args[args.length - 1];
        return typeof cb === 'function' ? [options, cb] : [options];
    };
}
function loadConfig(options) {
    const config = options.config;
    if (config) {
        delete options.config;
        debug(`loadConfig file: ${import_pkg_1.path.resolve(config)}`);
        return require(import_pkg_1.path.resolve(config));
    }
}
function likePromise(p) {
    return p && typeof p.then === 'function' && typeof p.catch === 'function';
}
function killWorker(worker) {
    try {
        worker.removeAllListeners();
        worker.on('error', noop);
        worker.kill('SIGTERM');
    }
    catch (err) { }
}
function forkWorker(index) {
    const worker = import_pkg_1.cluster.fork({ workerIndex: index });
    let reforked;
    const refork = () => {
        if (!state[index]) {
            setTimeout(function () {
                process.exit(1);
            }, INTERVAL);
            return;
        }
        if (reforked) {
            return;
        }
        reforked = true;
        killWorker(worker);
        clearInterval(worker.timer);
        clearTimeout(worker.activeTimer);
        setTimeout(function () {
            forkWorker(index);
        }, 600);
    };
    worker.once('disconnect', refork);
    worker.once('exit', refork);
    worker.on('error', noop);
    worker.on('message', (msg) => {
        if (msg !== '1') {
            return;
        }
        state[index] = true;
        if (!worker.timer) {
            worker.timer = setInterval(() => {
                try {
                    worker.send('1', noop);
                }
                catch (e) {
                    clearInterval(worker.timer);
                }
            }, INTERVAL);
        }
        else {
            clearTimeout(worker.activeTimer);
        }
        worker.activeTimer = setTimeout(refork, MASTER_TIMEOUT);
    });
}
function default_1(options, callback) {
    debug('defaut:: invoke');
    if (typeof options === 'function') {
        callback = options;
        options = undefined;
    }
    const startWhistle = function () {
        debug('startWhistle:: invoke');
        const server = options?.server;
        if (server) {
            (0, import_pkg_1.assert)(options?.port && options?.port > 0, 'options.port of the custom server is required');
            if (!options?.storage && options?.storage !== false) {
                options.storage = '__custom_server_5b6af7b9884e1165__' + options.port;
            }
        }
        const workerIndex = env.workerIndex;
        if (options && options.cluster && workerIndex && parseInt(workerIndex, 10) >= 0) {
            options.storage = '.' + (options.storage || '') + '__cluster_worker.' + workerIndex + '_5b6af7b9884e1165__';
        }
        const conf = config_1.default.extend(options);
        // debug('default:: conf=', conf);
        if (!conf.cluster) {
            return (0, index_1.default)(callback, server);
        }
        let timer;
        const activeTimeout = function () {
            clearTimeout(timer);
            timer = setTimeout(function () {
                process.exit(1);
            }, TIMEOUT);
        };
        process.once('SIGTERM', function () {
            process.exit(0);
        });
        (0, index_1.default)(function () {
            activeTimeout();
            process.on('message', activeTimeout);
            process.send?.('1', noop);
            setInterval(() => {
                try {
                    process.send?.('1', noop);
                }
                catch (e) { }
            }, INTERVAL);
        });
    };
    if (options) {
        if (options.cluster && /^\d+$/.test(`${options.cluster}`)) {
            options.cluster = Math.min(parseInt(`${options.cluster}`, 10), 999);
        }
        else if (options.cluster) {
            options.cluster = Math.min(import_pkg_1.os.cpus().length, 999);
        }
        if (options.cluster && import_pkg_1.cluster.isMaster) {
            (0, import_pkg_1.assert)(!options.server, 'cannot exist options.server in cluster mode');
            for (let i = 0; i < options.cluster; i++) {
                forkWorker(i);
            }
            return;
        }
        if (options.debugMode) {
            if (options.mode && PROD_RE.test(options.mode)) {
                options.debugMode = false;
            }
            else {
                env.PFORK_MODE = 'bind';
            }
        }
        let config = loadConfig(options);
        if (typeof config === 'function') {
            const handleCallback = function (opts) {
                opts && (0, import_pkg_1.extend)(options, opts);
                return startWhistle();
            };
            if (config.length < 2) {
                config = config(options);
                if (likePromise(config)) {
                    return config.then(handleCallback).catch(function (err) {
                        process.nextTick(function () {
                            throw err;
                        });
                    });
                }
            }
            else {
                config(options, handleCallback);
            }
        }
        config && (0, import_pkg_1.extend)(options, config);
    }
    return startWhistle();
}
exports.default = default_1;
