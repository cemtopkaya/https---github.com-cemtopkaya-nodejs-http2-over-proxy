"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const pipestream_1 = require("pipestream");
const import_pkg_1 = require("../import-pkg");
const LT_RE = /^\s*</;
const JSON_RE = /^\s*[\[\{]/;
function getBuffer(options, name, charset) {
    const buf = options[name];
    return buf == null || Buffer.isBuffer(buf) ? buf : import_pkg_1.iconv.encode(buf + '', charset);
}
class WhistleTransform extends pipestream_1.Transform {
    constructor(options) {
        super();
        this.allowInject = (chunk) => {
            if (!chunk || (!this._strictHtml && !this._safeHtml)) {
                return true;
            }
            return this._strictHtml ? LT_RE.test(chunk.toString()) : !JSON_RE.test(chunk.toString());
        };
        this._transform = (chunk, _encoding, callback) => {
            const cb = () => {
                if (this._allowInject && this._ended && this._bottom) {
                    chunk = chunk ? Buffer.concat([chunk, this._bottom]) : this._bottom;
                    this._bottom = null;
                }
                if (chunk && this._speed) {
                    setTimeout(function () {
                        callback(null, chunk);
                    }, Math.round((chunk.length * 1000) / this._speed));
                }
                else {
                    callback(null, chunk);
                }
            };
            if (!this._ended) {
                this._ended = !chunk;
            }
            if (!this._inited) {
                this._allowInject = this.allowInject(chunk);
                this._inited = true;
                if (this._allowInject) {
                    if (this._body) {
                        this._ended = true;
                        chunk = this._body;
                    }
                    if (this._top) {
                        chunk = chunk ? Buffer.concat([this._top, chunk]) : this._top;
                        this._top = null;
                    }
                }
                return this._delay ? setTimeout(cb, this._delay) : cb();
            }
            if (this._ended) {
                chunk = null;
            }
            cb();
        };
        options = options || {
            speed: '0',
            delay: '0'
        };
        let value = (parseInt(options.speed) * 1000) / 8;
        if (value > 0) {
            this._speed = value;
        }
        if ((value = parseInt(options.delay)) > 0) {
            this._delay = value;
        }
        let charset = options.charset && String(options.charset);
        if (!charset || !import_pkg_1.iconv.encodingExists(charset)) {
            charset = 'utf8';
        }
        this._body = getBuffer(options, 'body', charset);
        this._top = getBuffer(options, 'top', charset);
        this._bottom = getBuffer(options, 'bottom', charset);
        if (this._body || this._top || this._bottom) {
            if (options.strictHtml) {
                this._strictHtml = true;
            }
            else if (options.safeHtml) {
                this._safeHtml = true;
            }
        }
    }
}
exports.default = WhistleTransform;
