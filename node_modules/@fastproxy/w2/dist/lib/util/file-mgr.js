"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readFileText = exports.readFilesText = exports.readFile = exports.readFileList = exports.joinData = exports.decode = exports.convertSlash = exports.toBuffer = void 0;
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const iconv_lite_1 = tslib_1.__importDefault(require("iconv-lite"));
const safe_buffer_1 = require("safe-buffer");
const config_1 = tslib_1.__importDefault(require("../config"));
const is_utf8_1 = tslib_1.__importDefault(require("./is-utf8"));
const UTF8_RE = /^utf-?8$/i;
const isWin32 = process.platform === 'win32';
const MAX_SIZE = 1024 * 1024 * 64;
const LOCAL_FILE_PATH_RE = /^(\/*\$(?:whistle|w2)\/)/i;
const CRLF = safe_buffer_1.Buffer.from('\r\n');
const RSLASH_RE = /\\/g;
const noop = function (_) {
    return _;
};
function toBuffer(buf, charset) {
    if (buf == null || safe_buffer_1.Buffer.isBuffer(buf)) {
        return buf;
    }
    buf += '';
    if (charset && typeof charset === 'string' && !UTF8_RE.test(charset)) {
        try {
            charset = charset.toLowerCase();
            if (charset === 'base64') {
                return safe_buffer_1.Buffer.from(buf, 'base64');
            }
            return iconv_lite_1.default.encode(buf, charset);
        }
        catch (e) { }
    }
    return safe_buffer_1.Buffer.from(buf);
}
exports.toBuffer = toBuffer;
function convertSlash(filePath) {
    if (LOCAL_FILE_PATH_RE.test(filePath)) {
        filePath = config_1.default.LOCAL_FILES + '/' + filePath.substring(RegExp.$1.length);
    }
    else {
        filePath = config_1.default.getHomePath(filePath);
    }
    return isWin32 ? filePath : filePath.replace(RSLASH_RE, '/');
}
exports.convertSlash = convertSlash;
function decode(buf) {
    if (!safe_buffer_1.Buffer.isBuffer(buf)) {
        return buf ? String(buf) : '';
    }
    if (!(0, is_utf8_1.default)(buf)) {
        try {
            return iconv_lite_1.default.decode(buf, 'GB18030');
        }
        catch (e) { }
    }
    return String(buf);
}
exports.decode = decode;
function isString(path) {
    return path && typeof path === 'string';
}
function readSingleFile(path, callback) {
    if (!isString(path)) {
        return callback();
    }
    const stream = fs_1.default.createReadStream(convertSlash(path));
    let done;
    let buf;
    const execCallback = function (err) {
        if (done) {
            return;
        }
        done = true;
        stream.close();
        callback(err ? null : buf);
    };
    stream.on('data', function (data) {
        if (done) {
            return;
        }
        buf = buf ? safe_buffer_1.Buffer.concat([buf, data]) : data;
        if (buf.length > MAX_SIZE) {
            execCallback();
        }
    });
    stream.on('error', execCallback);
    stream.on('end', execCallback);
}
function getFileMap(list) {
    if (Array.isArray(list)) {
        list = list.join('|');
    }
    if (!isString(list)) {
        return undefined;
    }
    const fileMap = {};
    list = list.split('|');
    list.forEach(function (file) {
        fileMap[file || ''] = 1;
    });
    return fileMap;
}
function readFileMap(list, callback, isText) {
    const fileMap = getFileMap(list);
    if (fileMap === undefined) {
        return callback('');
    }
    const files = Object.keys(fileMap);
    let len = files.length;
    files.forEach(function (file) {
        readSingleFile(file, function (data) {
            fileMap[file || ''] = isText ? decode(data) : data;
            if (--len <= 0) {
                callback(fileMap);
            }
        });
    });
}
function joinData(list, isText, charset) {
    if (!list || !list.length) {
        return '';
    }
    if (isText) {
        return list.filter(noop).join('\r\n');
    }
    const result = [];
    list.forEach(function (buf) {
        if (buf) {
            buf = toBuffer(buf, charset);
            result.push(buf, CRLF);
        }
    });
    result.pop();
    return result.length ? safe_buffer_1.Buffer.concat(result) : '';
}
exports.joinData = joinData;
function readFileFromMap(path, fileMap, isText) {
    if (!isString(path)) {
        return '';
    }
    path = path.split('|');
    return joinData(path.map(function (file) {
        return fileMap[file || ''];
    }), isText);
}
function readFileList(list, callback, isText) {
    readFileMap(list, function (fileMap) {
        if (!fileMap) {
            return callback('');
        }
        const result = [];
        list.forEach(function (file) {
            result.push(readFileFromMap(file, fileMap, isText));
        });
        callback(result);
    }, isText);
}
exports.readFileList = readFileList;
function readFile(path, callback) {
    if (!isString(path)) {
        return callback();
    }
    readFileList(path.split('|'), function (result) {
        callback(joinData(result));
    });
}
exports.readFile = readFile;
function readFilesText(list, callback) {
    readFileList(list, callback, true);
}
exports.readFilesText = readFilesText;
function readFileText(path, callback) {
    if (!isString(path)) {
        return callback();
    }
    readFilesText(path.split('|'), function (result) {
        callback(joinData(result, true));
    });
}
exports.readFileText = readFileText;
