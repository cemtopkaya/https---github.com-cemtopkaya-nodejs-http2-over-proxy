"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unzip = exports.inflateRaw = exports.gunzip = exports.inflate = void 0;
const tslib_1 = require("tslib");
const zlib_1 = tslib_1.__importDefault(require("zlib"));
const async_limiter_1 = tslib_1.__importDefault(require("async-limiter"));
const limiter = new async_limiter_1.default({ concurrency: 10 });
function createConvenienceMethod(ctor) {
    return function (buffer, opts, callback) {
        if (typeof opts === 'function') {
            callback = opts;
            opts = {};
        }
        return zlibBuffer(new ctor(opts), buffer, callback);
    };
}
function zlibBuffer(engine, buffer, callback) {
    engine.buffers = [];
    engine.nread = 0;
    engine.cb = callback;
    engine.on('data', zlibBufferOnData);
    engine.on('error', zlibBufferOnError);
    engine.on('end', zlibBufferOnEnd);
    engine.end(buffer);
}
function zlibBufferOnData(chunk) {
    if (!this.buffers)
        this.buffers = [chunk];
    else
        this.buffers.push(chunk);
    this.nread += chunk.length;
}
function zlibBufferOnError(err) {
    this.removeAllListeners('end');
    this.cb(err);
}
function zlibBufferOnEnd() {
    let buf;
    let err;
    const bufs = this.buffers;
    buf = bufs.length === 1 ? bufs[0] : Buffer.concat(bufs, this.nread);
    this.close();
    if (err)
        this.cb(err);
    else if (this._info)
        this.cb(null, { buffer: buf, engine: this });
    else
        this.cb(null, buf);
}
// FIXME: zlib.Inflate等三个类型不存在?
exports.inflate = createConvenienceMethod(zlib_1.default.Inflate);
exports.gunzip = createConvenienceMethod(zlib_1.default.Gunzip);
exports.inflateRaw = createConvenienceMethod(zlib_1.default.InflateRaw);
function unzip(encoding, body, callback) {
    if (body && typeof encoding === 'string') {
        encoding = encoding.trim().toLowerCase();
        if (encoding === 'gzip') {
            if (body[0] !== 31 || body[1] !== 139) {
                callback(null, body);
                return true;
            }
            limiter.push(function (done) {
                (0, exports.gunzip)(body, function (err, data) {
                    done();
                    callback(err, data);
                });
            });
            return;
        }
        if (encoding === 'deflate') {
            limiter.push(function (done) {
                (0, exports.inflate)(body, function (err, data) {
                    if (!err) {
                        done();
                        return callback(null, data);
                    }
                    (0, exports.inflateRaw)(body, function (e2, data2) {
                        done();
                        callback(e2, data2);
                    });
                });
            });
            return;
        }
    }
    callback(null, body);
}
exports.unzip = unzip;
