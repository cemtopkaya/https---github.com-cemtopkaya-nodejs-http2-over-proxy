"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.execScriptSync = exports.compare = exports.getStatusCode = exports.handleStatusCode = exports.changePort = exports.setEstablished = exports.getLatestVersion = exports.getRegistry = exports.parseRawJson = exports.isCiphersError = exports.isUrl = exports.noop = exports.isWin = exports.PLUGIN_INSPECTOR_CONFIG = exports.PLUGIN_MENU_CONFIG = exports.PLUGIN_VALUES = exports.replacePattern = exports.localIpCache = exports.parseUrl = exports.parseQuery = exports.isUtf8 = exports.INTERNAL_ID = exports.proc = exports.WhistleTransform = exports.ReplaceStringTransform = exports.ReplacePatternTransform = exports.workerIndex = exports.EMPTY_BUFFER = exports.toBuffer = exports.encodeHtml = exports.onResEnd = exports.getUpdateUrl = exports.removeIllegalTrailers = exports.addTrailerNames = exports.isEmptyObject = exports.isHead = exports.hasBody = exports.removeIPV6Prefix = exports.lowerCaseify = exports.replaceProtocol = exports.getProtocol = exports.setProtocol = exports.removeProtocol = exports.hasProtocol = exports.indexOfList = exports.request = exports.listenerCount = exports.getServer = exports.FileWriterTransform = exports.SpeedTransform = void 0;
exports.getUrlValue = exports.getMatcherValue = exports.rule = exports.getRuleFile = exports.getRuleFiles = exports.getRuleValue = exports.parseRuleJson = exports.parseHeaders = exports.readInjectFiles = exports.trim = exports.readFileSync = exports.parseJSON = exports.getQueryValue = exports.sendStatusCodeError = exports.wrapGatewayError = exports.wrapResponse = exports.parsePathReplace = exports.disableResStore = exports.disableReqCache = exports.getFilename = exports.getPath = exports.encodeURIComponent = exports.encodeNonLatin1Char = exports.parseHost = exports.isLocalHost = exports.isLocalAddress = exports.getProxyTunnelPath = exports.getHostname = exports.networkInterfaces = exports.removeClientId = exports.getComposerClientId = exports.getTunnelKey = exports.getClientId = exports.setClientId = exports.disableCSP = exports.getFullUrl = exports.isString = exports.toRegExp = exports.isAuthCapture = exports.getInternalHost = exports.isEnable = exports.endWithList = exports.startWithList = exports.emitError = exports.toOriginalRegExp = exports.isOriginalRegExp = exports.isRegExp = exports.formatDate = exports.getErrorStack = exports.getFileWriters = void 0;
exports.getPluginVarsConf = exports.getHintList = exports.getPluginMenu = exports.getString = exports.getCustomTab = exports.getCgiUrl = exports.checkIfAddInterceptPolicy = exports.trimStr = exports.transformReq = exports.handleHeaderReplace = exports.parseHeaderReplace = exports.mergeRules = exports.filterRepeatPlugin = exports.ignoreRules = exports.checkSkip = exports.exactIgnore = exports.isIgnored = exports.resolveFilter = exports.parseLineProps = exports.resolveProperties = exports.join = exports.setHeader = exports.setHeaders = exports.decodeBuffer = exports.replaceUrlQueryString = exports.replaceQueryString = exports.getQueryString = exports.isMultipart = exports.isLocalPHost = exports.isProxyPort = exports.isJSONContent = exports.isUrlEncoded = exports.getClientPort = exports.getRemotePort = exports.getClientIp = exports.getRemoteAddr = exports.getForwardedFor = exports.getCharset = exports.toUpperCase = exports.toLowerCase = exports.getPipeIconvStream = exports.isWhistleTransformData = exports.getUnzipStream = exports.getZipStream = exports.getContentEncoding = exports.hasRequestBody = exports.removeUnsupportsHeaders = exports.supportHtmlTransform = exports.getContentType = exports.getRawType = void 0;
exports.handleForwardedProps = exports.delay = exports.getAuthBasic = exports.getAuthByRules = exports.readOneChunk = exports.removeResBody = exports.removeReqBody = exports.canGzip = exports.getStatusCodeFromRule = exports.setClientCert = exports.renderPluginRules = exports.formatH2Headers = exports.isDisableH2 = exports.isEnableH2 = exports.getPluginInspectorConfig = exports.getPluginMenuConfig = exports.getBoundIp = exports.checkPort = exports.showPluginReq = exports.checkPluginReqOnce = exports.connect = exports.getCipher = exports.parseClientInfo = exports.parseRange = exports.isInspect = exports.getParserStatus = exports.isCustomParser = exports.getRemoteRules = exports.getNoPluginServerMsg = exports.setResponseFor = exports.isRulesContent = exports.getMethod = exports.getHostIp = exports.setProxyHost = exports.checkAuto2Http = exports.checkTlsError = exports.escapeRegExp = exports.setResCookies = exports.setReqCookies = exports.disableResProps = exports.disableReqProps = exports.setResCors = exports.setReqCors = exports.deleteReqHeaders = exports.parseDeleteProperties = exports.getEmptyRes = exports.onSocketEnd = exports.getReqId = exports.toString = exports.getStaticDir = void 0;
exports.checkProxyHost = exports.isInternalProxy = exports.addTunnelData = exports.setTunnelHeaders = exports.setPluginMgr = exports.filterWeakRule = void 0;
const tslib_1 = require("tslib");
const http_1 = tslib_1.__importDefault(require("http"));
const path_1 = tslib_1.__importDefault(require("path"));
const os_1 = tslib_1.__importDefault(require("os"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const vm_1 = tslib_1.__importDefault(require("vm"));
const net_1 = tslib_1.__importDefault(require("net"));
const tls_1 = tslib_1.__importDefault(require("tls"));
const crypto_1 = tslib_1.__importDefault(require("crypto"));
const querystring_1 = tslib_1.__importDefault(require("querystring"));
const stream_1 = require("stream");
const zlib_1 = tslib_1.__importDefault(require("zlib"));
const dns_1 = tslib_1.__importDefault(require("dns"));
const http2_1 = require("http2");
const fs_extra2_1 = tslib_1.__importDefault(require("fs-extra2"));
const extend_1 = tslib_1.__importDefault(require("extend"));
const lru_cache_1 = tslib_1.__importDefault(require("lru-cache"));
const json5_1 = tslib_1.__importDefault(require("json5"));
const iconv_lite_1 = tslib_1.__importDefault(require("iconv-lite"));
const pipestream_1 = tslib_1.__importDefault(require("pipestream"));
const q_1 = tslib_1.__importDefault(require("q"));
const safe_buffer_1 = require("safe-buffer");
const protocols_1 = require("../rules/protocols");
const config_1 = tslib_1.__importDefault(require("../config"));
const logger_1 = tslib_1.__importDefault(require("./logger"));
const is_utf8_1 = tslib_1.__importDefault(require("./is-utf8"));
exports.isUtf8 = is_utf8_1.default;
const fileMgr = tslib_1.__importStar(require("./file-mgr"));
const httpMgr = tslib_1.__importStar(require("./http-mgr"));
const replace_pattern_transform_1 = tslib_1.__importDefault(require("./replace-pattern-transform"));
const parse_query_1 = tslib_1.__importDefault(require("./parse-query"));
exports.parseQuery = parse_query_1.default;
const common = tslib_1.__importStar(require("./common"));
const process_1 = tslib_1.__importDefault(require("./process"));
exports.proc = process_1.default;
const parse_url_1 = tslib_1.__importDefault(require("./parse-url"));
exports.parseUrl = parse_url_1.default;
var speed_transform_1 = require("./speed-transform");
Object.defineProperty(exports, "SpeedTransform", { enumerable: true, get: function () { return tslib_1.__importDefault(speed_transform_1).default; } });
var file_writer_transform_1 = require("./file-writer-transform");
Object.defineProperty(exports, "FileWriterTransform", { enumerable: true, get: function () { return tslib_1.__importDefault(file_writer_transform_1).default; } });
var hagent_1 = require("hagent");
Object.defineProperty(exports, "getServer", { enumerable: true, get: function () { return hagent_1.getServer; } });
var patch_1 = require("./patch");
Object.defineProperty(exports, "listenerCount", { enumerable: true, get: function () { return patch_1.listenerCount; } });
exports.request = httpMgr.request;
var buf_util_1 = require("./buf-util");
Object.defineProperty(exports, "indexOfList", { enumerable: true, get: function () { return buf_util_1.indexOf; } });
var common_1 = require("./common");
Object.defineProperty(exports, "hasProtocol", { enumerable: true, get: function () { return common_1.hasProtocol; } });
Object.defineProperty(exports, "removeProtocol", { enumerable: true, get: function () { return common_1.removeProtocol; } });
Object.defineProperty(exports, "setProtocol", { enumerable: true, get: function () { return common_1.setProtocol; } });
Object.defineProperty(exports, "getProtocol", { enumerable: true, get: function () { return common_1.getProtocol; } });
Object.defineProperty(exports, "replaceProtocol", { enumerable: true, get: function () { return common_1.replaceProtocol; } });
Object.defineProperty(exports, "lowerCaseify", { enumerable: true, get: function () { return common_1.lowerCaseify; } });
Object.defineProperty(exports, "removeIPV6Prefix", { enumerable: true, get: function () { return common_1.removeIPV6Prefix; } });
Object.defineProperty(exports, "hasBody", { enumerable: true, get: function () { return common_1.hasBody; } });
Object.defineProperty(exports, "isHead", { enumerable: true, get: function () { return common_1.isHead; } });
Object.defineProperty(exports, "isEmptyObject", { enumerable: true, get: function () { return common_1.isEmptyObject; } });
Object.defineProperty(exports, "addTrailerNames", { enumerable: true, get: function () { return common_1.addTrailerNames; } });
Object.defineProperty(exports, "removeIllegalTrailers", { enumerable: true, get: function () { return common_1.removeIllegalTrailers; } });
Object.defineProperty(exports, "getUpdateUrl", { enumerable: true, get: function () { return common_1.getUpdateUrl; } });
Object.defineProperty(exports, "onResEnd", { enumerable: true, get: function () { return common_1.onResEnd; } });
Object.defineProperty(exports, "encodeHtml", { enumerable: true, get: function () { return common_1.encodeHtml; } });
exports.toBuffer = fileMgr.toBuffer;
const pendingFiles = {};
const localIpCache = new lru_cache_1.default({ max: 120 });
exports.localIpCache = localIpCache;
const CRLF_RE = /\r\n|\r|\n/g;
const SEARCH_RE = /[?#].*$/;
const UTF8_OPTIONS = { encoding: 'utf8' };
const LOCALHOST = '127.0.0.1';
let CONTEXT = vm_1.default.createContext();
const END_WIDTH_SEP_RE = /[/\\]$/;
const GEN_URL_RE = /^\s*(?:https?:)?\/\/\w[^\s]*\s*$/i;
const G_NON_LATIN1_RE = /\s|[^\x00-\xFF]/gu;
const NON_LATIN1_RE = /[^\x00-\xFF]/;
const SCRIPT_START = (0, exports.toBuffer)('<script>');
const SCRIPT_END = (0, exports.toBuffer)('</script>');
const STYLE_START = (0, exports.toBuffer)('<style>');
const STYLE_END = (0, exports.toBuffer)('</style>');
const RAW_CRLF_RE = /\\n|\\r/g;
const NUM_RE = /^\d+$/;
const DIG_RE = /^[+-]?[1-9]\d*$/;
const INDEX_RE = /^\[(\d+)\]$/;
const ARR_FILED_RE = /(.)?(?:\[(\d+)\])$/;
const PROXY_RE = /^x?(?:socks|https?-proxy|proxy|internal(?:-https)?-proxy)$/;
const DEFAULT_REGISTRY = 'https://registry.npmjs.org';
const HTTP_RE = /^https?:\/\/[^/?]/;
const SEP_RE = /[|&]/;
let ctxTimer;
const END_RE = /[/\\]$/;
const resetContext = function () {
    ctxTimer = undefined;
    CONTEXT = vm_1.default.createContext();
};
const SUB_MATCH_RE = /\$[&\d]/;
const HTTP_URL_RE = /^https?:\/\//;
const PROTO_NAME_RE = /^([\w.-]+):\/\//;
const replacePattern = replace_pattern_transform_1.default.replacePattern;
exports.replacePattern = replacePattern;
const CIPHER_OPTIONS = [
    'NULL-SHA256',
    'AES128-SHA256',
    'AES256-SHA256',
    'AES128-GCM-SHA256',
    'AES256-GCM-SHA384',
    'DH-RSA-AES128-SHA256',
    'DH-RSA-AES256-SHA256',
    'DH-RSA-AES128-GCM-SHA256',
    'DH-RSA-AES256-GCM-SHA384',
    'DH-DSS-AES128-SHA256',
    'DH-DSS-AES256-SHA256',
    'DH-DSS-AES128-GCM-SHA256',
    'DH-DSS-AES256-GCM-SHA384',
    'DHE-RSA-AES128-SHA256',
    'DHE-RSA-AES256-SHA256',
    'DHE-RSA-AES128-GCM-SHA256',
    'DHE-RSA-AES256-GCM-SHA384',
    'DHE-DSS-AES128-SHA256',
    'DHE-DSS-AES256-SHA256',
    'DHE-DSS-AES128-GCM-SHA256',
    'DHE-DSS-AES256-GCM-SHA384',
    'ECDHE-RSA-AES128-SHA256',
    'ECDHE-RSA-AES256-SHA384',
    'ECDHE-RSA-AES128-GCM-SHA256',
    'ECDHE-RSA-AES256-GCM-SHA384',
    'ECDHE-ECDSA-AES128-SHA256',
    'ECDHE-ECDSA-AES256-SHA384',
    'ECDHE-ECDSA-AES128-GCM-SHA256',
    'ECDHE-ECDSA-AES256-GCM-SHA384',
    'ADH-AES128-SHA256',
    'ADH-AES256-SHA256',
    'ADH-AES128-GCM-SHA256',
    'ADH-AES256-GCM-SHA384',
    'AES128-CCM',
    'AES256-CCM',
    'DHE-RSA-AES128-CCM',
    'DHE-RSA-AES256-CCM',
    'AES128-CCM8',
    'AES256-CCM8',
    'DHE-RSA-AES128-CCM8',
    'DHE-RSA-AES256-CCM8',
    'ECDHE-ECDSA-AES128-CCM',
    'ECDHE-ECDSA-AES256-CCM',
    'ECDHE-ECDSA-AES128-CCM8',
    'ECDHE-ECDSA-AES256-CCM8'
];
const TLSV2_CIPHERS = 'ECDHE-ECDSA-AES256-GCM-SHA384';
exports.EMPTY_BUFFER = (0, exports.toBuffer)('');
const lowerCaseify = common.lowerCaseify;
const removeIPV6Prefix = common.removeIPV6Prefix;
const hasBody = common.hasBody;
const hasProtocol = common.hasProtocol;
const removeProtocol = common.removeProtocol;
const INTERNAL_ID = process.pid + '-' + Math.random();
exports.INTERNAL_ID = INTERNAL_ID;
let pluginMgr;
const _workerIndex = process.env && process.env.workerIndex;
exports.workerIndex = _workerIndex && parseInt(_workerIndex, 10) >= 0 ? padReqId(config_1.default.workerIndex) : '';
var replace_pattern_transform_2 = require("./replace-pattern-transform");
Object.defineProperty(exports, "ReplacePatternTransform", { enumerable: true, get: function () { return tslib_1.__importDefault(replace_pattern_transform_2).default; } });
var replace_string_transform_1 = require("./replace-string-transform");
Object.defineProperty(exports, "ReplaceStringTransform", { enumerable: true, get: function () { return tslib_1.__importDefault(replace_string_transform_1).default; } });
var whistle_transform_1 = require("./whistle-transform");
Object.defineProperty(exports, "WhistleTransform", { enumerable: true, get: function () { return tslib_1.__importDefault(whistle_transform_1).default; } });
// 避免属性被 stringify ，减少冗余数据传给前端
exports.PLUGIN_VALUES = Symbol('_values');
exports.PLUGIN_MENU_CONFIG = Symbol('_menuConfig');
exports.PLUGIN_INSPECTOR_CONFIG = Symbol('_inspectorConfig');
tslib_1.__exportStar(require("./drain"), exports);
exports.isWin = process.platform === 'win32';
function noop(_) {
    return _;
}
exports.noop = noop;
function isUrl(str) {
    return HTTP_URL_RE.test(str);
}
exports.isUrl = isUrl;
function isCiphersError(e) {
    return (e.code === 'EPROTO' || String(e.message).indexOf('disconnected before secure TLS connection was established') !== -1);
}
exports.isCiphersError = isCiphersError;
function wrapJs(js, charset, isUrl) {
    if (!js) {
        return '';
    }
    if (isUrl) {
        return (0, exports.toBuffer)('<script src="' + js + '"></script>', charset);
    }
    return safe_buffer_1.Buffer.concat([SCRIPT_START, (0, exports.toBuffer)(js, charset), SCRIPT_END]);
}
function wrapCss(css, charset, isUrl) {
    if (!css) {
        return '';
    }
    if (isUrl) {
        return (0, exports.toBuffer)('<link rel="stylesheet" href="' + css + '" />', charset);
    }
    return safe_buffer_1.Buffer.concat([STYLE_START, (0, exports.toBuffer)(css, charset), STYLE_END]);
}
function evalJson(str) {
    try {
        return json5_1.default.parse(str);
    }
    catch (e) { }
}
const parseRawJson = function (str) {
    try {
        return JSON.parse(str);
    }
    catch (e) {
        return evalJson(str);
    }
};
exports.parseRawJson = parseRawJson;
function getRegistry(pkg) {
    const registry = pkg.whistleConfig && pkg.whistleConfig.registry;
    if (!registry || !HTTP_RE.test(registry)) {
        return;
    }
    return registry === DEFAULT_REGISTRY ? undefined : registry;
}
exports.getRegistry = getRegistry;
const MAX_LEN = 1024 * 1024 * 5;
function getLatestVersion(registry, cb) {
    if (registry && typeof registry !== 'string') {
        const name = registry.moduleName;
        registry = registry.registry;
        if (registry) {
            registry += '/' + name;
        }
    }
    if (!registry) {
        return cb();
    }
    httpMgr.request({
        url: registry,
        maxLength: MAX_LEN
    }, function (err, body, res) {
        if (err || res.statusCode !== 200) {
            body = null;
        }
        else if (body) {
            body = parseJSON(body);
        }
        body = body && body['dist-tags'];
        cb(body && body['latest']);
    });
}
exports.getLatestVersion = getLatestVersion;
const ESTABLISHED_CTN = 'HTTP/1.1 200 Connection Established\r\nProxy-Agent: ' + config_1.default.name + '\r\n\r\n';
const setEstablished = function (socket) {
    socket.write(ESTABLISHED_CTN);
};
exports.setEstablished = setEstablished;
function changePort(url, port) {
    const index = url.indexOf('/', url.indexOf('://') + 3);
    if (index != -1) {
        const host = url.substring(0, index).replace(/:\d*$/, '');
        url = host + ':' + port + url.substring(index);
    }
    return url;
}
exports.changePort = changePort;
function handleStatusCode(statusCode, headers) {
    if (statusCode == 401) {
        headers['www-authenticate'] = 'Basic realm=User Login';
    }
    return headers;
}
exports.handleStatusCode = handleStatusCode;
function getStatusCode(statusCode) {
    statusCode |= 0;
    return statusCode < 100 || statusCode > 999 ? 0 : statusCode;
}
exports.getStatusCode = getStatusCode;
function compare(v1, v2) {
    return v1 == v2 ? 0 : v1 > v2 ? -1 : 1;
}
exports.compare = compare;
let scriptCache = {};
const VM_OPTIONS = {
    displayErrors: false,
    timeout: 60
};
const MAX_SCRIPT_SIZE = 1024 * 256;
const MAX_SCRIPT_CACHE_COUNT = 64;
const MIN_SCRIPT_CACHE_COUNT = 32;
function getScript(content) {
    content = content.trim();
    const len = content.length;
    if (!len || len > MAX_SCRIPT_SIZE) {
        return;
    }
    let script = scriptCache[content];
    delete scriptCache[content];
    let list = Object.keys(scriptCache);
    if (list.length > MAX_SCRIPT_CACHE_COUNT) {
        list = list
            .map(function (content) {
            const script = scriptCache[content];
            script.content = content;
            return script;
        })
            .sort(function (a, b) {
            return compare(a.time, b.time);
        })
            .splice(0, MIN_SCRIPT_CACHE_COUNT);
        scriptCache = {};
        list.forEach(function (script) {
            scriptCache[script.content] = {
                script: script.script,
                time: script.time
            };
        });
    }
    script = scriptCache[content] = script || {
        script: new vm_1.default.Script('(function(){\n' + content + '\n})()')
    };
    script.time = Date.now();
    return script.script;
}
function clearContext() {
    Object.keys(CONTEXT).forEach(function (key) {
        delete CONTEXT[key];
    });
    if (!ctxTimer) {
        ctxTimer = setTimeout(resetContext, 30000);
    }
}
function execScriptSync(script, context) {
    try {
        if ((script = getScript(script))) {
            CONTEXT.console = {};
            ['fatal', 'error', 'warn', 'info', 'log', 'debug'].forEach(level => {
                CONTEXT.console[level] = logger_1.default[level];
            });
            Object.keys(context).forEach(function (key) {
                CONTEXT[key] = context[key];
            });
            script.runInContext(CONTEXT, VM_OPTIONS);
        }
        return true;
    }
    catch (e) {
        logger_1.default.error(e);
        return false;
    }
    finally {
        clearContext();
    }
}
exports.execScriptSync = execScriptSync;
function stat(file, callback, force) {
    if (force) {
        return callback(true);
    }
    fs_1.default.stat(file, function (err) {
        if (!err || err.code === 'ENOTDIR') {
            return callback();
        }
        if (err.code === 'ENOENT') {
            return callback(true);
        }
        fs_1.default.stat(file, callback);
    });
}
function getFileWriter(file, callback, force) {
    if (!file) {
        return callback();
    }
    if (END_RE.test(file)) {
        file = path_1.default.join(file, 'index.html');
    }
    if (!force && pendingFiles[file]) {
        return callback();
    }
    const execCb = function (writer) {
        delete pendingFiles[file];
        callback(writer);
    };
    pendingFiles[file] = 1;
    stat(file, function (notExists) {
        if (!notExists) {
            return execCb();
        }
        fs_extra2_1.default.ensureFile(file, function (err) {
            if (err) {
                logger_1.default.error(err);
                return execCb();
            }
            execCb(fs_1.default.createWriteStream(file).on('error', logger_1.default.error));
        });
    }, force);
}
function getFileWriters(files, callback, force) {
    if (!Array.isArray(files)) {
        files = [files];
    }
    q_1.default.all(files.map(function (file) {
        const defer = q_1.default.defer();
        getFileWriter(file, function (writer) {
            defer.resolve(writer);
        }, force);
        return defer.promise;
    })).spread(callback);
}
exports.getFileWriters = getFileWriters;
function getErrorStack(err) {
    if (!err) {
        return '';
    }
    let stack;
    try {
        stack = err.stack;
    }
    catch (e) { }
    stack = stack || err.message || err;
    const result = [
        'From: ' + config_1.default.name + '@' + config_1.default.version,
        'Node: ' + process.version,
        'Date: ' + formatDate(),
        stack
    ];
    return result.join('\r\n');
}
exports.getErrorStack = getErrorStack;
function formatDate(now) {
    now = now || new Date();
    return now.toLocaleString();
}
exports.formatDate = formatDate;
const REG_EXP_RE = /^\/(.+)\/(i?u?|ui)$/;
const isRegExp = function isRegExp(regExp) {
    return REG_EXP_RE.test(regExp);
};
exports.isRegExp = isRegExp;
const ORIG_REG_EXP = /^\/(.+)\/([igmu]{0,4})$/;
function isOriginalRegExp(regExp) {
    if (!ORIG_REG_EXP.test(regExp) || /[igmu]{2}/.test(regExp.$2)) {
        return false;
    }
    return true;
}
exports.isOriginalRegExp = isOriginalRegExp;
function toOriginalRegExp(regExp) {
    regExp = ORIG_REG_EXP.test(regExp);
    try {
        regExp = regExp && new RegExp(RegExp.$1, RegExp.$2);
    }
    catch (e) {
        regExp = null;
    }
    return regExp;
}
exports.toOriginalRegExp = toOriginalRegExp;
const emitError = function (obj, err) {
    if (obj) {
        obj.once('error', noop);
        obj.emit('error', err || new Error('Unknown'));
    }
};
exports.emitError = emitError;
const startWithList = function (buf, subBuf, start = 0) {
    const len = subBuf.length;
    if (!len) {
        return false;
    }
    for (let i = 0; i < len; i++) {
        if (buf[i + start] != subBuf[i]) {
            return false;
        }
    }
    return true;
};
exports.startWithList = startWithList;
const endWithList = function (buf, subBuf, end) {
    const subLen = subBuf.length;
    if (!subLen) {
        return false;
    }
    if (!(end >= 0)) {
        end = buf.length - 1;
    }
    for (let i = 0; i < subLen; i++) {
        if (subBuf[subLen - i - 1] != buf[end - i]) {
            return false;
        }
    }
    return true;
};
exports.endWithList = endWithList;
function isEnable(req, name) {
    return req.enable[name] && !req.disable[name];
}
exports.isEnable = isEnable;
const getInternalHost = function (req, host) {
    if (isEnable(req, 'useLocalHost')) {
        return 'local.wproxy.org';
    }
    if (host && isEnable(req, 'useSafePort')) {
        const index = host.indexOf(':');
        if (index !== -1) {
            host = host.substring(0, index);
        }
        host += ':8899';
    }
    return host;
};
exports.getInternalHost = getInternalHost;
function isAuthCapture(req) {
    const e = req.enable || '';
    const d = req.disable || '';
    return (e.authCapture || e.authIntercept) && !d.authCapture && !d.authIntercept;
}
exports.isAuthCapture = isAuthCapture;
const toRegExp = function toRegExp(regExp, ignoreCase) {
    regExp = REG_EXP_RE.test(regExp);
    try {
        regExp = regExp && new RegExp(RegExp.$1, ignoreCase ? 'i' : RegExp.$2);
    }
    catch (e) {
        regExp = null;
    }
    return regExp;
};
exports.toRegExp = toRegExp;
const HTTP_PORT_RE = /:80$/;
const HTTPS_PORT_RE = /:443$/;
function removeDefaultPort(host, isHttps) {
    return host && host.replace(isHttps ? HTTPS_PORT_RE : HTTP_PORT_RE, '');
}
function isString(str) {
    return str && typeof str === 'string';
}
exports.isString = isString;
function getFullUrl(req) {
    const headers = req.headers;
    let host = headers[config_1.default.REAL_HOST_HEADER];
    if (hasProtocol(req.url)) {
        const options = (0, parse_url_1.default)(req.url);
        if (options.protocol === 'https:' || (req.isWs && options.protocol === 'wss:')) {
            req.isHttps = true;
        }
        req.url = options.path;
        if (options.host) {
            headers.host = options.host;
        }
    }
    else {
        req.url = req.url || '/';
        if (req.url[0] !== '/') {
            req.url = '/' + req.url;
        }
    }
    if (host) {
        delete headers[config_1.default.REAL_HOST_HEADER];
    }
    if (!isString(host)) {
        host = headers.host;
        if (typeof host !== 'string') {
            host = headers.host = '';
        }
    }
    else if (headers.host !== host) {
        if (isString(headers.host)) {
            req._fwdHost = headers.host;
        }
        headers.host = host;
    }
    host = removeDefaultPort(host, req.isHttps);
    const fullUrl = host + req.url;
    if (req.isWs) {
        return (req.isHttps ? 'wss://' : 'ws://') + fullUrl;
    }
    return (req.isHttps ? 'https://' : 'http://') + fullUrl;
}
exports.getFullUrl = getFullUrl;
function disableCSP(headers) {
    delete headers['content-security-policy'];
    delete headers['content-security-policy-report-only'];
    delete headers['x-content-security-policy'];
    delete headers['x-content-security-policy-report-only'];
    delete headers['x-webkit-csp'];
}
exports.disableCSP = disableCSP;
let interfaces = os_1.default.networkInterfaces();
let hostname = os_1.default.hostname();
let simpleHostname = '';
const cpus = os_1.default.cpus();
let addressList = [];
(function updateSystyemInfo() {
    interfaces = os_1.default.networkInterfaces();
    hostname = os_1.default.hostname();
    addressList = [];
    for (const i in interfaces) {
        const list = interfaces[i];
        if (Array.isArray(list)) {
            list.forEach(function (info) {
                addressList.push(info.address.toLowerCase());
            });
        }
    }
    setTimeout(updateSystyemInfo, 30000);
})();
if (isString(hostname)) {
    simpleHostname = hostname.replace(/[^\w.-]+/g, '').substring(0, 20);
    simpleHostname = simpleHostname ? simpleHostname + '.' : '';
}
let clientId = [
    hostname,
    os_1.default.platform(),
    os_1.default.release(),
    os_1.default.arch(),
    cpus.length,
    cpus[0] && cpus[0].model,
    config_1.default.clientId
];
clientId = config_1.default.clientId =
    simpleHostname + crypto_1.default.createHmac('sha256', config_1.default.CLIENT_ID_HEADER).update(clientId.join('\r\n')).digest('base64');
config_1.default.runtimeId =
    simpleHostname +
        crypto_1.default
            .createHmac('sha256', config_1.default.CLIENT_ID_HEADER)
            .update(clientId + '\r\n' + Math.random() + '\r\n' + Date.now())
            .digest('base64') +
        '/' +
        config_1.default.port;
config_1.default.runtimeHeaders = { 'x-whistle-runtime-id': config_1.default.runtimeId };
config_1.default.pluginHeaders = {
    'x-whistle-runtime-id': config_1.default.runtimeId,
    'x-whistle-internal-id': INTERNAL_ID,
    [config_1.default.PLUGIN_HOOK_NAME_HEADER]: config_1.default.PLUGIN_HOOKS.UI
};
const setClientId = function (headers, enable, disable, clientIp, isInternalProxy) {
    if (disable && (disable.clientId || disable.clientID || disable.clientid)) {
        return;
    }
    enable = enable || '';
    if (enable.clientId || enable.clientID || enable.clientid || isInternalProxy) {
        let id = getClientId(headers);
        if ((enable.multiClient || isInternalProxy) && !enable.singleClient && !disable.multiClient) {
            if (headers[config_1.default.CLIENT_ID_HEADER]) {
                return;
            }
            if (!isLocalAddress(clientIp)) {
                id += '/' + clientIp;
            }
        }
        headers[config_1.default.CLIENT_ID_HEADER] = id;
    }
};
exports.setClientId = setClientId;
function getClientId(headers) {
    const id = headers[config_1.default.CLIENT_ID_HEADER];
    const idKey = config_1.default.cidKey;
    if (!idKey || (id && !config_1.default.overCidKey)) {
        return id || clientId;
    }
    return headers[idKey] || id || clientId;
}
exports.getClientId = getClientId;
const getTunnelKey = function (conf) {
    let tunnelKey = conf.tunnelKey || conf.tunnelKeys;
    if (tunnelKey && typeof tunnelKey === 'string') {
        tunnelKey = tunnelKey.toLowerCase().split(/[:,|]/);
        tunnelKey = tunnelKey.map(trim).filter(noop);
        return tunnelKey.slice(0, 10);
    }
};
exports.getTunnelKey = getTunnelKey;
function getComposerClientId(headers) {
    const clientId = headers[config_1.default.COMPOSER_CLIENT_ID_HEADER];
    if (clientId) {
        delete headers[config_1.default.COMPOSER_CLIENT_ID_HEADER];
        return clientId;
    }
}
exports.getComposerClientId = getComposerClientId;
const removeClientId = function (headers) {
    delete headers[config_1.default.CLIENT_ID_HEADER];
};
exports.removeClientId = removeClientId;
function networkInterfaces() {
    return interfaces;
}
exports.networkInterfaces = networkInterfaces;
/**
 * FIXME: 之前是提供hostname别名的, 但会和块作用域里的变量冲突
 * export const hostname = getHostname;
 */
function getHostname() {
    return hostname;
}
exports.getHostname = getHostname;
function getProxyTunnelPath(req, isHttps) {
    const host = req._phost && req._proxyTunnel && req.headers.host;
    if (isString(host)) {
        return host.indexOf(':') !== -1 ? host : host + ':' + (isHttps ? 443 : 80);
    }
}
exports.getProxyTunnelPath = getProxyTunnelPath;
function isLocalAddress(address) {
    if (isLocalIp(address)) {
        return true;
    }
    address = address.toLowerCase();
    if (address[0] === '[') {
        address = address.slice(1, -1);
    }
    if (address == '0:0:0:0:0:0:0:1') {
        return true;
    }
    return !!(localIpCache.get(address) || addressList.indexOf(address) !== -1);
}
exports.isLocalAddress = isLocalAddress;
function isLocalHost(host) {
    return host === 'localhost' || isLocalAddress(host);
}
exports.isLocalHost = isLocalHost;
function parseHost(host) {
    if (host[0] === '[') {
        const index = host.indexOf(']');
        host = [host.substring(1, index), host.substring(index + 2)];
    }
    else {
        host = host.split(':');
    }
    return host;
}
exports.parseHost = parseHost;
/**
 * 解析一些字符时，encodeURIComponent可能会抛异常，对这种字符不做任何处理
 * see: http://stackoverflow.com/questions/16868415/encodeuricomponent-throws-an-exception
 * @param ch
 * @returns
 */
function safeEncodeURIComponent(ch) {
    try {
        return (0, exports.encodeURIComponent)(ch);
    }
    catch (e) { }
    return ch;
}
const encodeNonLatin1Char = function (str) {
    if (!isString(str)) {
        return '';
    }
    return str.replace(G_NON_LATIN1_RE, safeEncodeURIComponent);
};
exports.encodeNonLatin1Char = encodeNonLatin1Char;
exports.encodeURIComponent = safeEncodeURIComponent;
function getPath(url, noProtocol) {
    if (url) {
        url = url.replace(SEARCH_RE, '');
        const index = noProtocol ? -1 : url.indexOf('://');
        url = index > -1 ? url.substring(index + 3) : url;
    }
    return url;
}
exports.getPath = getPath;
function getFilename(url) {
    if (typeof url === 'string' && (url = getPath(url)?.trim())) {
        const index = url.lastIndexOf('/');
        if (index != -1) {
            url = url.substring(index + 1);
        }
        else {
            url = null;
        }
    }
    else {
        url = null;
    }
    return url || 'index.html';
}
exports.getFilename = getFilename;
function disableReqCache(headers) {
    delete headers['if-modified-since'];
    delete headers['if-none-match'];
    delete headers['last-modified'];
    delete headers.etag;
    headers['pragma'] = 'no-cache';
    headers['cache-control'] = 'no-cache';
}
exports.disableReqCache = disableReqCache;
function disableResStore(headers) {
    headers['cache-control'] = 'no-store';
    headers['expires'] = new Date(Date.now() - 60000000).toUTCString();
    headers['pragma'] = 'no-cache';
    delete headers.tag;
}
exports.disableResStore = disableResStore;
function parsePathReplace(urlPath, params) {
    if (!params || !/^(?:ws|http)s?:/.test(urlPath)) {
        return;
    }
    let index = urlPath.indexOf('://');
    if (index == -1) {
        return;
    }
    index = urlPath.indexOf('/', index + 3) + 1;
    if (index <= 0) {
        return;
    }
    let root = urlPath.substring(0, index);
    urlPath = urlPath.substring(index);
    Object.keys(params).forEach(function (pattern) {
        let value = params[pattern];
        value = value == null ? '' : value + '';
        if (isOriginalRegExp(pattern) && (pattern = toOriginalRegExp(pattern))) {
            urlPath = urlPath.replace(pattern, value);
        }
        else if (pattern) {
            urlPath = urlPath.split(pattern).join(value);
        }
    });
    root += urlPath;
    return root !== urlPath ? root : null;
}
exports.parsePathReplace = parsePathReplace;
function wrapResponse(res) {
    const passThrough = new stream_1.PassThrough();
    passThrough.statusCode = res.statusCode;
    passThrough.rawHeaderNames = res.rawHeaderNames;
    passThrough.headers = lowerCaseify(res.headers);
    passThrough.headers['x-server'] = config_1.default.name;
    res.body != null && passThrough.push(safe_buffer_1.Buffer.isBuffer(res.body) ? res.body : String(res.body));
    passThrough.push(null);
    passThrough.isCustomRes = true;
    return passThrough;
}
exports.wrapResponse = wrapResponse;
function wrapGatewayError(body) {
    return wrapResponse({
        statusCode: 502,
        headers: {
            'content-type': 'text/html; charset=utf8'
        },
        body: body
            ? '<pre>\n' + body + '\n\n\n<a href="javascript:;" onclick="location.reload()"' + '>Reload this page</a>\n</pre>'
            : ''
    });
}
exports.wrapGatewayError = wrapGatewayError;
function sendStatusCodeError(cltRes, svrRes) {
    delete svrRes.headers['content-length'];
    cltRes.writeHead(502, svrRes.headers);
    cltRes.src(wrapGatewayError('Invalid status code: ' + svrRes.statusCode));
}
exports.sendStatusCodeError = sendStatusCodeError;
const getQueryValue = function (value) {
    if (value && typeof value === 'object') {
        try {
            return JSON.stringify(value);
        }
        catch (e) { }
    }
    return value || '';
};
exports.getQueryValue = getQueryValue;
const KV_RE = /^([^:=&]+):([^=&]*)$/;
function parseInlineJSON(text, isValue) {
    if (/\s/.test(text) || (!isValue && /\\|\//.test(text) && text[0] !== '&')) {
        return;
    }
    if (KV_RE.test(text)) {
        const data = {};
        data[RegExp.$1] = RegExp.$2;
        return data;
    }
    return (0, parse_query_1.default)(text, null, null, true);
}
function replaceCrLf(char) {
    return char === '\\r' ? '\r' : '\n';
}
function parseLinesJSON(text) {
    if (!isString(text) || !(text = text.trim())) {
        return null;
    }
    let first = text[0];
    let last = text[text.length - 1];
    if ((first === '[' && last === ']') || (first === '{' && last === '}')) {
        return null;
    }
    let result;
    text.split(/\r\n|\n|\r/g).forEach(function (line) {
        if (!(line = line.trim())) {
            return;
        }
        let index = line.indexOf(': ');
        if (index === -1) {
            index = line.indexOf(':');
            if (index === -1) {
                index = line.indexOf('=');
            }
        }
        let name;
        let value;
        let arrIndex;
        if (index != -1) {
            name = line.substring(0, index).trim();
            value = line.substring(index + 1).trim();
            if (value) {
                const fv = value[0];
                const lv = value[value.length - 1];
                if (fv === lv) {
                    if (fv === '"' || fv === "'" || fv === '`') {
                        value = value.slice(1, -1);
                    }
                    if (value && fv === '`' && (value.indexOf('\\n') !== -1 || value.indexOf('\\r') !== -1)) {
                        value = value.replace(RAW_CRLF_RE, replaceCrLf);
                    }
                }
                else if (value === '0') {
                    value = 0;
                }
                else if (value.length < 16 && DIG_RE.test(value)) {
                    try {
                        value = parseInt(value, 10);
                    }
                    catch (e) { }
                }
            }
        }
        else {
            name = line.trim();
            value = '';
        }
        first = name[0];
        last = name[name.length - 1];
        if (first === last && last === '"') {
            name = name.slice(1, -1);
        }
        else if (first === '[' && last === ']') {
            name = name.slice(1, -1).trim();
            if (NUM_RE.test(name) || INDEX_RE.test(name)) {
                name = RegExp.$1 || RegExp['$&'];
                result = result || [];
            }
            else {
                const keys = name.split(/\s*\.\s*/);
                name = keys.shift().trim();
                if (ARR_FILED_RE.test(name)) {
                    const idx = RegExp.$2;
                    if (RegExp.$1) {
                        name = name.slice(0, -idx.length - 2);
                        arrIndex = parseInt(idx, 10);
                    }
                    else {
                        name = idx;
                        result = result || [];
                    }
                }
                if (keys.length) {
                    keys.reverse().forEach(function (key) {
                        let obj;
                        if (ARR_FILED_RE.test(key)) {
                            const idx2 = RegExp.$2;
                            const arr = [];
                            if (RegExp.$1) {
                                obj = {};
                                obj[key.slice(0, -idx2.length - 2)] = arr;
                                arr[idx2] = value;
                                value = obj;
                            }
                            else {
                                arr[idx2] = value;
                                value = arr;
                            }
                        }
                        else {
                            obj = {};
                            obj[key] = value;
                            value = obj;
                        }
                    });
                }
            }
        }
        result = result || {};
        const list = result[name];
        if (list == null) {
            if (arrIndex) {
                const arr = [];
                arr[arrIndex] = value;
                result[name] = arr;
            }
            else {
                result[name] = value;
            }
        }
        else if (typeof list === 'object') {
            if (arrIndex) {
                list[arrIndex] = value;
            }
            else if (typeof value === 'object') {
                (0, extend_1.default)(true, list, value);
            }
        }
    });
    return result || {};
}
function parseJSON(data) {
    if (typeof data === 'object') {
        return data;
    }
    return parsePureJSON(data, true) || parseLinesJSON(data);
}
exports.parseJSON = parseJSON;
function parsePureJSON(data, isValue) {
    if (typeof data !== 'string' || !(data = data.trim())) {
        return null;
    }
    try {
        return JSON.parse(data);
    }
    catch (e) {
        const result = evalJson(data);
        if (result) {
            return result;
        }
    }
    return parseInlineJSON(data, isValue);
}
function readFileSync(file) {
    try {
        return fs_1.default.readFileSync(file, UTF8_OPTIONS);
    }
    catch (e) {
        return undefined;
    }
}
exports.readFileSync = readFileSync;
function trim(text) {
    return text && text.trim();
}
exports.trim = trim;
function readInjectFiles(data, callback) {
    if (!data) {
        return callback();
    }
    fileMgr.readFilesText([data.prepend, data.replace, data.append], function (result) {
        if (result[0]) {
            data.top = result[0];
        }
        if (result[1]) {
            data.body = result[1];
        }
        if (result[2]) {
            data.bottom = result[2];
        }
        callback(data);
    });
}
exports.readInjectFiles = readInjectFiles;
function parseHeaders(headers, rawNames) {
    if (typeof headers === 'string') {
        headers = headers.split(CRLF_RE);
    }
    const _headers = {};
    headers.forEach(function (line) {
        const index = line.indexOf(':');
        let value;
        if (index != -1) {
            value = line.substring(index + 1).trim();
            const rawName = line.substring(0, index).trim();
            const name = rawName.toLowerCase();
            let list = _headers[name];
            if (rawNames) {
                rawNames[name] = rawName;
            }
            if (list) {
                if (!Array.isArray(list)) {
                    _headers[name] = list = [list];
                }
                list.push(value);
            }
            else {
                _headers[name] = value;
            }
        }
    });
    return lowerCaseify(_headers);
}
exports.parseHeaders = parseHeaders;
const QUERY_PARAM_RE = /^[^\/&=]+=/;
const parseRuleJson = function (rules, callback, req) {
    if (!Array.isArray(rules)) {
        rules = [rules];
    }
    q_1.default.all(rules.map(function (rule) {
        const defer = q_1.default.defer();
        readRuleList(rule, function (data) {
            defer.resolve(data);
        }, true, null, null, req);
        return defer.promise;
    })).spread(callback);
};
exports.parseRuleJson = parseRuleJson;
function readRuleValue(rule, callback, checkUrl, needRawData, req, isJson) {
    if (!rule) {
        return callback();
    }
    if (rule.value) {
        return callback(removeProtocol(rule.value, true));
    }
    let filePath = getMatcherValue(rule);
    if (checkUrl && GEN_URL_RE.test(filePath)) {
        return callback(filePath);
    }
    const opts = pluginMgr.resolveKey(filePath, rule, req);
    let readFile;
    if (opts) {
        readFile = pluginMgr[needRawData ? 'requestBin' : 'requestText'];
        filePath = opts;
        isJson = false;
    }
    else {
        readFile = fileMgr[needRawData ? 'readFile' : 'readFileText'];
        filePath = decodePath(filePath);
        if (rule.root) {
            filePath = join(rule.root, filePath);
        }
    }
    if (isJson && filePath.indexOf('=') !== -1) {
        try {
            const handleStat = function (err, stat) {
                if (err || !stat || !stat.isFile()) {
                    callback(filePath);
                }
                else {
                    readFile(filePath, callback);
                }
            };
            return fs_1.default.stat(filePath, function (err, stat) {
                if (err && err.code !== 'ENOENT') {
                    return fs_1.default.stat(filePath, handleStat);
                }
                else {
                    handleStat(err, stat);
                }
            });
        }
        catch (e) { }
    }
    readFile(filePath, callback);
}
function wrapTag(result, isBin, charset, wrap) {
    const list = [];
    let temp;
    result.forEach(function (data) {
        if (!data) {
            return;
        }
        if (typeof data !== 'string' || !GEN_URL_RE.test(data)) {
            temp = temp || [];
            temp.push(data);
            return;
        }
        temp && list.push(wrap(fileMgr.joinData(temp, !isBin, charset), charset));
        list.push(wrap(data.trim(), charset, true));
        temp = null;
    });
    temp && list.push(wrap(fileMgr.joinData(temp, !isBin, charset), charset));
    return list;
}
const CORS_RE = /^re[qs]Cors:\/\//;
function isDeep(result) {
    for (let i = 0, len = result.length; i < len; i++) {
        if (result[i] === true) {
            return true;
        }
    }
    return false;
}
function readRuleList(rule, callback, isJson, charset, isHtml, req) {
    if (!rule) {
        return callback();
    }
    let len = rule.list && rule.list.length;
    const isBin = (0, protocols_1.isBinProtocol)(rule.name);
    const needRawData = isBin && !isJson;
    if (!len) {
        return readRuleValue(rule, isJson
            ? function (value) {
                callback(parseJSON(value));
            }
            : callback, false, needRawData, req, isJson);
    }
    let result = [];
    const isJsHtml = isHtml && isBin === 2;
    const isCssHtml = isHtml && isBin === 3;
    const execCallback = function () {
        if (--len > 0) {
            return;
        }
        if (isJson) {
            const deepMerge = isDeep(result);
            result = result.map(parseJSON).filter(noop);
            if (result.length > 1) {
                result.reverse();
                if (typeof result[0] !== 'object') {
                    result[0] = {};
                }
                deepMerge && result.unshift(true);
                callback(extend_1.default.apply(null, result));
            }
            else {
                callback(result[0]);
            }
        }
        else {
            if (isJsHtml) {
                result = wrapTag(result, isBin, charset, wrapJs);
            }
            else if (isCssHtml) {
                result = wrapTag(result, isBin, charset, wrapCss);
            }
            if (rule.isRawList) {
                callback(result);
            }
            else {
                callback(fileMgr.joinData(result, !isBin, charset));
            }
        }
    };
    const isCors = CORS_RE.test(rule.matcher);
    const checkUrl = isJsHtml || isCssHtml;
    rule.list.forEach(function (r, i) {
        if (isJson) {
            const value = removeProtocol(getMatcher(r), true);
            if (value) {
                const json = isCors && GEN_URL_RE.test(value) ? { origin: value.trim() } : parsePureJSON(value, QUERY_PARAM_RE.test(value));
                if (json) {
                    result[i] = json;
                    return execCallback();
                }
            }
        }
        readRuleValue(r, function (value) {
            result[i] = value;
            execCallback();
        }, checkUrl, needRawData, req, isJson);
    });
}
const getRuleValue = function (rules, callback, noBody, charset, isHtml, req) {
    if (noBody || !rules) {
        return callback();
    }
    if (!Array.isArray(rules)) {
        rules = [rules];
    }
    q_1.default.all(rules.map(function (rule) {
        const defer = q_1.default.defer();
        readRuleList(rule, function (data) {
            defer.resolve(data);
        }, false, charset, isHtml, req);
        return defer.promise;
    })).spread(callback);
};
exports.getRuleValue = getRuleValue;
function decodePath(path) {
    path = getPath(path, true);
    try {
        return decodeURIComponent(path);
    }
    catch (e) {
        logger_1.default.error(e);
    }
    try {
        return querystring_1.default.unescape(path);
    }
    catch (e) {
        logger_1.default.error(e);
    }
    return path;
}
const getRuleFiles = function (rule, req) {
    const files = rule.files || [getPath(getUrl(rule))];
    const root = rule.root;
    const rawFiles = rule.rawFiles || files;
    const result = [];
    files.map(function (file, i) {
        const opts = pluginMgr.resolveKey(rawFiles[i], rule, req);
        if (opts) {
            result.push(opts);
        }
        else {
            file = decodePath(file);
            file = fileMgr.convertSlash(root ? join(root, file) : file);
            if (END_WIDTH_SEP_RE.test(file)) {
                result.push(file.slice(0, -1));
                result.push(join(file, 'index.html'));
            }
            else {
                result.push(file);
            }
        }
    });
    return result;
};
exports.getRuleFiles = getRuleFiles;
const getRuleFile = function (rule) {
    const filePath = getPath(getUrl(rule));
    if (!filePath) {
        return filePath;
    }
    return rule.root ? join(rule.root, decodePath(filePath)) : decodePath(filePath);
};
exports.getRuleFile = getRuleFile;
function getValue(rule) {
    return rule.value || rule.path;
}
function getMatcher(rule, raw) {
    let _rule = rule && (getValue(rule) || rule.matcher);
    if (_rule && raw !== true) {
        _rule = _rule.trim();
    }
    return _rule;
}
function getUrl(rule) {
    return rule && (getValue(rule) || rule.url);
}
exports.rule = {
    getMatcher: getMatcher,
    getUrl: getUrl
};
function getMatcherValue(rule) {
    rule = getMatcher(rule);
    return rule && removeProtocol(rule, true);
}
exports.getMatcherValue = getMatcherValue;
function getUrlValue(rule, raw) {
    rule = getUrl(rule);
    if (rule && raw !== true) {
        rule = rule.trim();
    }
    return rule && removeProtocol(rule, true);
}
exports.getUrlValue = getUrlValue;
function _getRawType(type) {
    return typeof type === 'string' ? type.split(';')[0].toLowerCase() : '';
}
function getRawType(data) {
    return _getRawType(data.headers && data.headers['content-type']);
}
exports.getRawType = getRawType;
function getContentType(contentType) {
    if (contentType && typeof contentType !== 'string') {
        contentType = contentType['content-type'] || contentType.contentType;
    }
    contentType = _getRawType(contentType);
    if (!contentType) {
        return undefined;
    }
    if (contentType.indexOf('javascript') != -1) {
        return 'JS';
    }
    if (contentType.indexOf('css') != -1) {
        return 'CSS';
    }
    if (contentType.indexOf('html') != -1) {
        return 'HTML';
    }
    if (contentType.indexOf('json') != -1) {
        return 'JSON';
    }
    if (contentType.indexOf('xml') != -1) {
        return 'XML';
    }
    if (contentType.indexOf('text/') != -1) {
        return 'TEXT';
    }
    if (contentType.indexOf('image/') != -1) {
        return 'IMG';
    }
    return undefined;
}
exports.getContentType = getContentType;
function supportHtmlTransform(res, req) {
    const headers = res.headers;
    if (getContentType(headers) != 'HTML' || !hasBody(res, req)) {
        return false;
    }
    const contentEncoding = getContentEncoding(headers);
    //chrome新增了sdch压缩算法，对此类响应无法解码，deflate无法区分deflate还是deflateRaw
    return !contentEncoding || contentEncoding == 'gzip';
}
exports.supportHtmlTransform = supportHtmlTransform;
function removeUnsupportsHeaders(headers, supportsDeflate) {
    //只保留支持的zip格式：gzip、deflate
    if (!headers || !headers['accept-encoding']) {
        return;
    }
    if (config_1.default.noGzip) {
        delete headers['accept-encoding'];
        return;
    }
    const list = headers['accept-encoding'].split(/\s*,\s*/g);
    const acceptEncoding = [];
    for (let i = 0, len = list.length; i < len; i++) {
        const ae = list[i].toLowerCase();
        if (ae && ((supportsDeflate && ae == 'deflate') || ae == 'gzip')) {
            acceptEncoding.push(ae);
        }
    }
    if (acceptEncoding.length > 0) {
        headers['accept-encoding'] = acceptEncoding.join(', ');
    }
    else {
        delete headers['accept-encoding'];
    }
}
exports.removeUnsupportsHeaders = removeUnsupportsHeaders;
function hasRequestBody(req) {
    req = typeof req === 'string' ? req : req.method;
    if (typeof req !== 'string') {
        return false;
    }
    req = req.toUpperCase();
    return !(req === 'GET' || req === 'HEAD' || req === 'OPTIONS' || req === 'CONNECT');
}
exports.hasRequestBody = hasRequestBody;
function getContentEncoding(headers) {
    const encoding = toLowerCase((headers && headers['content-encoding']) || headers);
    return encoding === 'gzip' || encoding === 'deflate' ? encoding : null;
}
exports.getContentEncoding = getContentEncoding;
function getZipStream(headers) {
    const encoding = getContentEncoding(headers);
    switch (encoding) {
        case 'gzip':
            return zlib_1.default.createGzip();
        case 'deflate':
            return zlib_1.default.createDeflate();
        default:
            return null;
    }
}
exports.getZipStream = getZipStream;
function getUnzipStream(headers) {
    switch (getContentEncoding(headers)) {
        case 'gzip':
            return zlib_1.default.createGunzip();
        case 'deflate':
            return zlib_1.default.createInflate();
        default:
            return null;
    }
}
exports.getUnzipStream = getUnzipStream;
const isWhistleTransformData = function (obj) {
    if (!obj) {
        return false;
    }
    if (obj.speed > 0 || obj.delay > 0) {
        return true;
    }
    return !!(obj.top || obj.body || obj.bottom);
};
exports.isWhistleTransformData = isWhistleTransformData;
function getPipeIconvStream(headers) {
    const pipeStream = new pipestream_1.default();
    let charset = getCharset(headers['content-type']);
    if (charset) {
        pipeStream.addHead(iconv_lite_1.default.decodeStream(charset));
        pipeStream.addTail(iconv_lite_1.default.encodeStream(charset));
    }
    else {
        pipeStream.addHead(function (res, next) {
            let buffer, iconvDecoder;
            res.on('data', function (chunk) {
                buffer = buffer ? safe_buffer_1.Buffer.concat([buffer, chunk]) : chunk;
                resolveCharset(buffer);
            });
            res.on('end', resolveCharset);
            function resolveCharset(chunk) {
                if (!charset) {
                    if (chunk && buffer.length < 25600) {
                        return;
                    }
                    charset = !buffer || (0, is_utf8_1.default)(buffer) ? 'utf8' : 'GB18030';
                }
                if (!iconvDecoder) {
                    iconvDecoder = iconv_lite_1.default.decodeStream(charset);
                    next(iconvDecoder);
                }
                if (buffer) {
                    iconvDecoder.write(buffer);
                    buffer = null;
                }
                !chunk && iconvDecoder.end();
            }
        });
        pipeStream.addTail(function (src, next) {
            next(src.pipe(iconv_lite_1.default.encodeStream(charset || '')));
        });
    }
    return pipeStream;
}
exports.getPipeIconvStream = getPipeIconvStream;
function toLowerCase(str) {
    return typeof str === 'string' ? str.trim().toLowerCase() : str;
}
exports.toLowerCase = toLowerCase;
function toUpperCase(str) {
    return typeof str === 'string' ? str.trim().toUpperCase() : str;
}
exports.toUpperCase = toUpperCase;
const CHARSET_RE = /charset=([\w-]+)/i;
function getCharset(str) {
    let charset;
    if (CHARSET_RE.test(str)) {
        charset = RegExp.$1;
        if (!iconv_lite_1.default.encodingExists(charset)) {
            return;
        }
    }
    return charset;
}
exports.getCharset = getCharset;
function getClientIpFH(headers, name) {
    let val = headers[name];
    if (!isString(val)) {
        return '';
    }
    const index = val.indexOf(',');
    if (index !== -1) {
        val = val.substring(0, index);
    }
    val = removeIPV6Prefix(val.trim());
    return net_1.default.isIP(val) && !isLocalAddress(val) ? val : '';
}
function getForwardedFor(headers) {
    let ip = getClientIpFH(headers, config_1.default.CLIENT_IP_HEAD);
    const cipKey = config_1.default.cipKey;
    if (cipKey && (!ip || config_1.default.overCipKey)) {
        ip = getClientIpFH(headers, cipKey) || ip;
    }
    return ip;
}
exports.getForwardedFor = getForwardedFor;
function isLocalIp(ip) {
    if (!isString(ip)) {
        return true;
    }
    return ip.length < 7 || ip === LOCALHOST;
}
function getRemoteAddr(req) {
    try {
        const socket = req.socket || req;
        if (!socket._remoteAddr) {
            const ip = req.headers && req.headers[config_1.default.REMOTE_ADDR_HEAD];
            if (ip) {
                socket._remoteAddr = ip;
                delete req.headers[config_1.default.REMOTE_ADDR_HEAD];
            }
            else {
                socket._remoteAddr = removeIPV6Prefix(socket.remoteAddress) || LOCALHOST;
            }
        }
        return socket._remoteAddr;
    }
    catch (e) { }
    return LOCALHOST;
}
exports.getRemoteAddr = getRemoteAddr;
function getClientIp(req) {
    const ip = getForwardedFor(req.headers || {}) || getRemoteAddr(req);
    return isLocalIp(ip) ? LOCALHOST : ip;
}
exports.getClientIp = getClientIp;
function getRemotePort(req) {
    try {
        const socket = req.socket || req;
        if (socket._remotePort == null) {
            let port = req.headers && req.headers[config_1.default.REMOTE_PORT_HEAD];
            if (port) {
                delete req.headers[config_1.default.REMOTE_PORT_HEAD];
            }
            else {
                port = socket.remotePort;
            }
            socket._remotePort = port > 0 ? port : '0';
        }
        return socket._remotePort;
    }
    catch (e) { }
    return 0;
}
exports.getRemotePort = getRemotePort;
const getClientPort = function (req) {
    const headers = req.headers || {};
    const port = headers[config_1.default.CLIENT_PORT_HEAD];
    if (port > 0) {
        return port;
    }
    return getRemotePort(req);
};
exports.getClientPort = getClientPort;
function isUrlEncoded(req) {
    return /^post$/i.test(req.method) && /urlencoded/i.test(req.headers && req.headers['content-type']);
}
exports.isUrlEncoded = isUrlEncoded;
function isJSONContent(req) {
    if (!hasRequestBody(req)) {
        return false;
    }
    return getContentType(req.headers) === 'JSON';
}
exports.isJSONContent = isJSONContent;
function isProxyPort(proxyPort) {
    return (proxyPort == config_1.default.port ||
        proxyPort == config_1.default.httpsPort ||
        proxyPort == config_1.default.httpPort ||
        proxyPort == config_1.default.socksPort ||
        proxyPort == config_1.default.realPort);
}
exports.isProxyPort = isProxyPort;
const isLocalPHost = function (req, isHttps) {
    const phost = req._phost;
    const hostname = phost && phost.hostname;
    if (!hostname || !isProxyPort(phost.port || (isHttps ? 443 : 80))) {
        return false;
    }
    return isLocalHost(hostname);
};
exports.isLocalPHost = isLocalPHost;
function isMultipart(req) {
    return /multipart/i.test(req.headers['content-type']);
}
exports.isMultipart = isMultipart;
function getQueryString(url) {
    const index = url.indexOf('?');
    return index == -1 ? '' : url.substring(index + 1);
}
exports.getQueryString = getQueryString;
function replaceQueryString(query, replaceQuery) {
    if (replaceQuery && typeof replaceQuery !== 'string') {
        replaceQuery = querystring_1.default.stringify(replaceQuery);
    }
    if (!query || !replaceQuery) {
        return query || replaceQuery;
    }
    const queryList = [];
    const params = {};
    const filterName = function (param) {
        const index = param.indexOf('=');
        let name, value;
        if (index == -1) {
            name = param;
            value = null;
        }
        else {
            name = param.substring(0, index);
            value = param.substring(index + 1);
        }
        const exists = name in params;
        params[name] = value;
        return exists ? null : name;
    };
    query = query.split('&').map(filterName);
    replaceQuery = replaceQuery.split('&').map(filterName);
    query.concat(replaceQuery).forEach(function (name) {
        const value = name ? params[name] : null;
        if (value != null) {
            queryList.push(name + '=' + value);
        }
    });
    return queryList.join('&');
}
exports.replaceQueryString = replaceQueryString;
function replaceUrlQueryString(url, queryString) {
    if (!queryString) {
        return url;
    }
    url = url || '';
    const hashIndex = url.indexOf('#');
    let hashString = '';
    if (hashIndex != -1) {
        hashString = url.substring(hashIndex);
        url = url.substring(0, hashIndex);
    }
    queryString = replaceQueryString(getQueryString(url), queryString);
    return url.replace(/\?.*$/, '') + (queryString ? '?' + queryString : '') + hashString;
}
exports.replaceUrlQueryString = replaceUrlQueryString;
exports.decodeBuffer = fileMgr.decode;
function setHeaders(data, obj) {
    data.headers = data.headers || {};
    for (const i in obj) {
        data.headers[i] = obj[i];
    }
    return data;
}
exports.setHeaders = setHeaders;
function setHeader(data, name, value) {
    data.headers = data.headers || {};
    data.headers[name] = value;
    return data;
}
exports.setHeader = setHeader;
function join(root, dir) {
    return root ? path_1.default.resolve(root, dir) : dir;
}
exports.join = join;
function resolveProperties(list, result) {
    result = result || {};
    if (list) {
        list
            .map(getMatcherValue)
            .join('|')
            .split(SEP_RE)
            .forEach(function (action) {
            if (action) {
                result[action] = true;
            }
        });
    }
    return result;
}
exports.resolveProperties = resolveProperties;
const parseLineProps = function (str) {
    str = str && removeProtocol(str, true);
    if (!str) {
        return;
    }
    const result = {};
    str.split(SEP_RE).forEach(function (action) {
        if (action) {
            result[action] = true;
        }
    });
    return result;
};
exports.parseLineProps = parseLineProps;
function resolveIgnore(ignore) {
    const exclude = {};
    let keys = Object.keys(ignore);
    let ignoreAll, disableIgnoreAll;
    ignore = {};
    keys.forEach(name => {
        if (name.indexOf('ignore.') === 0 || name.indexOf('ignore:') === 0) {
            exclude[name.substring(7)] = 1;
            return;
        }
        if (name.indexOf('-') === 0 || name.indexOf('!') === 0) {
            name = name.substring(1);
            if (name === '*') {
                disableIgnoreAll = true;
            }
            else {
                exclude[name] = 1;
            }
            return;
        }
        name = name.replace('ignore|', '');
        if (name === 'filter' || name === 'ignore') {
            return;
        }
        if (name === 'allRules' || name === 'allProtocols' || name === 'All' || name === '*') {
            ignoreAll = true;
            return;
        }
        ignore[protocols_1.aliasProtocols[name] || name] = 1;
    });
    if (ignoreAll && !disableIgnoreAll) {
        protocols_1.protocols.forEach(function (name) {
            ignore[name] = 1;
        });
        keys = protocols_1.protocols;
    }
    else {
        keys = Object.keys(ignore);
    }
    keys.forEach(function (name) {
        if (exclude[name]) {
            delete ignore[name];
        }
    });
    return {
        ignoreAll: ignoreAll,
        exclude: exclude,
        ignore: ignore
    };
}
function resolveFilter(ignore, filter) {
    filter = filter || {};
    const result = resolveIgnore(ignore);
    ignore = result.ignore;
    Object.keys(ignore).forEach(function (name) {
        if (protocols_1.protocols.indexOf(name) === -1) {
            filter['ignore|' + name] = true;
        }
        else {
            filter[name] = true;
        }
    });
    Object.keys(result.exclude).forEach(function (name) {
        filter['ignore:' + name] = 1;
    });
    if (result.ignoreAll) {
        filter.allRules = 1;
    }
    return filter;
}
exports.resolveFilter = resolveFilter;
const isIgnored = function (filter, name) {
    return !filter['ignore:' + name] && (filter[name] || filter['ignore|' + name]);
};
exports.isIgnored = isIgnored;
function exactIgnore(filter, rule) {
    if (filter['ignore|' + 'pattern=' + rule.rawPattern]) {
        return true;
    }
    if (filter['ignore|' + 'matcher=' + rule.matcher]) {
        return true;
    }
    return rule.rawMatcher && filter['ignore|' + 'matcher=' + rule.rawMatcher];
}
exports.exactIgnore = exactIgnore;
function notSkip(props, name) {
    return props['-' + name] || props['!' + name];
}
const checkSkip = function (skip, rule, curUrl) {
    if (skip['*'] && !notSkip(skip, '*')) {
        return true;
    }
    const proto = getProtocolName(rule.url || rule.matcher) || getProtocolName(curUrl);
    const name = rule.name;
    if ((skip[name] || skip[proto]) && !notSkip(skip, name) && !notSkip(skip, proto)) {
        return true;
    }
    return false;
};
exports.checkSkip = checkSkip;
function resolveRuleProps(rule, result) {
    result = result || {};
    if (rule) {
        rule.list.forEach(function (rule) {
            getMatcherValue(rule)
                .split(SEP_RE)
                .forEach(function (action) {
                result[action] = true;
            });
        });
    }
    return result;
}
const PLUGIN_RE = /^(?:plugin|whistle)\.[a-z\d_\-]+$/;
const enableRules = ['https', 'intercept', 'capture', 'hide'];
function ignorePlugins(rules, name, exclude) {
    const isPlugin = name === 'plugin';
    if (!isPlugin && !PLUGIN_RE.test(name)) {
        return;
    }
    if (rules.plugin) {
        const list = rules.plugin.list;
        for (let i = list.length - 1; i >= 0; i--) {
            const pName = getProtocolName(list[i].matcher);
            if ((isPlugin || name === pName) && !exclude[pName]) {
                list.splice(i, 1);
            }
        }
        if (!list.length) {
            delete rules.plugin;
        }
    }
    return true;
}
function getProtocolName(url) {
    return PROTO_NAME_RE.test(url) ? RegExp.$1 : '';
}
function ignoreForwardRule(rules, name, exclude) {
    const isRule = name === 'rule';
    if (!isRule && rules[name]) {
        return;
    }
    if (rules.rule) {
        const pName = getProtocolName(rules.rule.url);
        if ((isRule || name === pName) && !exclude[pName]) {
            delete rules.rule;
        }
    }
    return true;
}
function ignoreProxy(rules, name, exclude) {
    if (!rules.proxy) {
        return;
    }
    if (name === 'proxy') {
        delete rules.proxy;
        return true;
    }
    if (!PROXY_RE.test(name)) {
        return;
    }
    const pName = getProtocolName(rules.proxy.url);
    const realName = protocols_1.aliasProtocols[name] || name;
    const realPName = protocols_1.aliasProtocols[pName] || pName;
    if (realName === realPName && !exclude[pName] && !exclude[realPName]) {
        delete rules.proxy;
    }
    return true;
}
const EXACT_IGNORE_RE = /^(?:pattern|matcher)=./;
function ignoreRules(rules, ignore, isResRules) {
    const result = resolveIgnore(ignore);
    const ignoreAll = result.ignoreAll;
    const exclude = result.exclude;
    ignore = result.ignore;
    const keys = Object.keys(ignoreAll ? rules : ignore);
    let filter;
    keys.forEach(function (name) {
        if (EXACT_IGNORE_RE.test(name)) {
            filter = filter || {};
            filter['ignore|' + name] = true;
        }
        if (name === 'filter' || name === 'ignore' || exclude[name]) {
            return;
        }
        if (!isResRules || protocols_1.resProtocols.indexOf(name) !== -1) {
            if (ignorePlugins(rules, name, exclude) ||
                ignoreProxy(rules, name, exclude) ||
                ignoreForwardRule(rules, name, exclude)) {
                return;
            }
            delete rules[name];
        }
    });
    if (filter) {
        Object.keys(rules).forEach(function (name) {
            let rule = rules[name];
            let list = rule.list;
            const matched = exactIgnore(filter, rule);
            if (list) {
                list = list.filter(function (r) {
                    return !exactIgnore(filter, r);
                });
                if (!list.length) {
                    delete rules[name];
                }
                else {
                    if (matched) {
                        rule = (0, extend_1.default)({}, list[0]);
                        rules[name] = rule;
                    }
                    rule.list = list;
                }
            }
            else if (matched) {
                delete rules[name];
            }
        });
    }
}
exports.ignoreRules = ignoreRules;
function filterRepeatPlugin(rule) {
    if (rule.name !== 'plugin') {
        return;
    }
    const exists = {};
    rule.list = rule.list.filter(function (p) {
        const protocol = p.matcher.substring(p.matcher.indexOf('.'), p.matcher.indexOf(':'));
        if (!exists[protocol]) {
            exists[protocol] = 1;
            return true;
        }
        return false;
    });
}
exports.filterRepeatPlugin = filterRepeatPlugin;
function mergeRule(curRule, newRule) {
    if (!curRule || !newRule || !newRule.list) {
        return newRule;
    }
    curRule.list = curRule.list.concat(newRule.list);
    filterRepeatPlugin(curRule);
    return curRule;
}
function mergeRules(req, add, isResRules) {
    const origin = req.rules;
    const origAdd = add;
    add = add || {};
    const merge = function (protocol) {
        const rule = mergeRule(origin[protocol], add[protocol]);
        if (rule) {
            origin[protocol] = rule;
        }
    };
    if (isResRules && origAdd) {
        protocols_1.resProtocols.forEach(merge);
    }
    else if (origAdd) {
        Object.keys(origAdd).forEach(merge);
    }
    req['delete'] = resolveRuleProps(origin['delete'], req['delete']);
    req._filters = resolveRuleProps(origin.filter, req._filters);
    req.disable = resolveRuleProps(origin.disable, req.disable);
    req.ignore = resolveRuleProps(origin.ignore, req.ignore);
    req.enable = resolveRuleProps(origin.enable, req.enable);
    enableRules.forEach(function (rule) {
        if (req.enable[rule]) {
            req._filters[rule] = true;
        }
    });
    ignoreRules(origin, (0, extend_1.default)(req.ignore, req._filters), isResRules);
    return add;
}
exports.mergeRules = mergeRules;
function parseHeaderReplace(rule) {
    const list = rule && rule.list;
    if (!list) {
        return '';
    }
    let result = '';
    list.forEach(function (item) {
        const obj = parseJSON(getMatcherValue(item));
        let prop, name;
        obj &&
            Object.keys(obj).forEach(function (key) {
                const value = obj[key];
                if (!key.indexOf('req.')) {
                    prop = 'req';
                    name = null;
                }
                else if (!key.indexOf('res.')) {
                    prop = 'res';
                    name = null;
                }
                else if (!key.indexOf('trailer.')) {
                    prop = 'trailer';
                    name = null;
                }
                else if (!prop) {
                    return;
                }
                result = result || {};
                const index = key.indexOf(':');
                name = name || key.substring(prop.length + 1, index).trim();
                if (!name) {
                    return;
                }
                key = key.substring(index + 1);
                const pattern = toOriginalRegExp(key);
                let opList = result[prop];
                const op = {
                    regExp: pattern,
                    name: name.toLowerCase(),
                    key: key,
                    value: value
                };
                if (opList) {
                    opList.push(op);
                }
                else {
                    result[prop] = opList = [op];
                }
            });
    });
    return result;
}
exports.parseHeaderReplace = parseHeaderReplace;
function replaceHeader(str, regExp, key, value) {
    if (str == null || str === '') {
        return str;
    }
    str = String(str);
    if (!regExp || !SUB_MATCH_RE.test(value)) {
        return str.replace(regExp || key, value);
    }
    return str.replace(regExp, function () {
        return replacePattern(value, arguments);
    });
}
function handleHeaderReplace(headers, opList) {
    opList &&
        opList.forEach(function (item) {
            const header = headers[item.name];
            if (header == null || header === '') {
                return;
            }
            const regExp = item.regExp;
            const key = item.key;
            const value = item.value;
            if (Array.isArray(header)) {
                headers[item.name] = header.map(function (str) {
                    return replaceHeader(str, regExp, key, value);
                });
            }
            else {
                headers[item.name] = replaceHeader(header, regExp, key, value);
            }
        });
}
exports.handleHeaderReplace = handleHeaderReplace;
function transformReq(req, res, port, host) {
    const options = (0, parse_url_1.default)(getFullUrl(req));
    const headers = req.headers;
    options.headers = headers;
    options.method = req.method;
    options.agent = false;
    options.protocol = null;
    options.host = host || LOCALHOST;
    if (port > 0) {
        options.port = port;
    }
    if (req.clientIp || !net_1.default.isIP(headers[config_1.default.CLIENT_IP_HEAD])) {
        const clientIp = req.clientIp || getClientIp(req);
        if (isLocalAddress(clientIp)) {
            delete headers[config_1.default.CLIENT_IP_HEAD];
        }
        else {
            headers[config_1.default.CLIENT_IP_HEAD] = clientIp;
        }
    }
    options.hostname = null;
    const client = http_1.default.request(options, function (_res) {
        const origin = !_res.headers['access-control-allow-origin'] && req.headers.origin;
        if (origin) {
            _res.headers['access-control-allow-origin'] = origin;
            _res.headers['access-control-allow-credentials'] = true;
        }
        if (getStatusCode(_res.statusCode)) {
            res.writeHead(_res.statusCode, _res.headers);
            _res.pipe(res);
        }
        else {
            sendStatusCodeError(res, _res);
        }
    });
    let destroyed;
    const abort = function () {
        if (!destroyed) {
            destroyed = true;
            client.destroy();
        }
    };
    req.on('error', abort);
    res.on('error', abort);
    res.once('close', abort);
    client.on('error', function (err) {
        abort();
        res.emit('error', err);
    });
    req.pipe(client);
    return client;
}
exports.transformReq = transformReq;
function trimStr(str) {
    if (typeof str !== 'string') {
        return '';
    }
    return str.trim();
}
exports.trimStr = trimStr;
function hasHeaderRules(headers) {
    return headers['x-whistle-rule-key'] || headers['x-whistle-rule-value'] || headers['x-whistle-rule-host'];
}
function checkIfAddInterceptPolicy(proxyHeaders, headers) {
    if (hasHeaderRules(headers)) {
        proxyHeaders['x-whistle-policy'] = 'intercept';
        return true;
    }
    return false;
}
exports.checkIfAddInterceptPolicy = checkIfAddInterceptPolicy;
function getCgiUrl(url) {
    if (!isString(url) || !(url = url.trim())) {
        return;
    }
    return url[0] === '/' ? url.substring(1) : url;
}
exports.getCgiUrl = getCgiUrl;
const getCustomTab = function (tab, pluginName) {
    if (!tab || !isString(tab.name)) {
        return;
    }
    const name = tab.name.trim();
    const page = getPage(tab.page || tab.action);
    if (!name || !page || page.indexOf('#') !== -1) {
        return;
    }
    return {
        action: 'plugin.' + pluginName + '/' + page,
        name: name.substring(0, 32)
    };
};
exports.getCustomTab = getCustomTab;
function getString(str) {
    if (!isString(str)) {
        return;
    }
    return str.trim();
}
exports.getString = getString;
function getPage(page) {
    page = getCgiUrl(page);
    return !page || page.length > 128 || !/\.html?$/i.test(page) ? null : page;
}
const getPluginMenu = function (menus, pluginName) {
    if (!Array.isArray(menus)) {
        return;
    }
    const len = menus.length;
    const map = {};
    let count = 3;
    let result = [];
    let menu, name, page;
    for (let i = 0; i < len; i++) {
        if ((menu = menus[i]) &&
            (name = getString(menu.name)) &&
            !map[name] &&
            (page = getPage(menu.page || menu.action)) &&
            page.indexOf('#') === -1) {
            result = result || [];
            map[name] = 1;
            result.push({
                name: name.substring(0, 20),
                action: 'plugin.' + pluginName + '/' + page,
                required: menu.required ? true : undefined
            });
            if (--count === 0) {
                return result;
            }
        }
    }
    return result;
};
exports.getPluginMenu = getPluginMenu;
const MAX_HINT_LEN = 512;
const MAX_VAR_LEN = 100;
function getHintList(conf, isVar) {
    const hintList = conf.hintList;
    if (!Array.isArray(hintList) || !hintList.length) {
        return;
    }
    let result;
    const maxLen = isVar ? MAX_VAR_LEN : MAX_HINT_LEN;
    hintList.forEach(function (hint) {
        if (typeof hint === 'string') {
            if (hint.length <= maxLen) {
                result = result || [];
                result.push(hint);
            }
        }
        else if (hint) {
            let text = hint.text || hint.value;
            text = typeof text === 'string' ? text.trim() : '';
            if (!text) {
                return;
            }
            let help = hint.help;
            const isKey = hint.isKey ? 1 : undefined;
            let displayText = hint.display || hint.displayText || hint.label;
            if (typeof help !== 'string') {
                help = '';
            }
            if (typeof displayText !== 'string') {
                displayText = '';
            }
            result = result || [];
            if (!isKey && !help && !displayText) {
                result.push(text);
            }
            else {
                result.push({
                    isKey: isKey,
                    text: text,
                    help: help.trim(),
                    displayText: displayText
                });
            }
        }
    });
    return result;
}
exports.getHintList = getHintList;
const getPluginVarsConf = function (conf) {
    const pluginVars = conf.pluginVars;
    if (!pluginVars) {
        return;
    }
    const varHintList = getHintList(pluginVars, true);
    const varHintUrl = varHintList ? undefined : getCgiUrl(pluginVars.hintUrl);
    if (varHintList || varHintUrl) {
        return {
            hintUrl: varHintUrl,
            hintList: varHintList
        };
    }
    return true;
};
exports.getPluginVarsConf = getPluginVarsConf;
const getStaticDir = function (conf) {
    const staticDir = conf.staticDir;
    if (!staticDir || typeof staticDir !== 'string' || !/^[\w./-]+$/.test(staticDir) || staticDir.length > 100) {
        return;
    }
    return staticDir.replace(/^\/+/, '');
};
exports.getStaticDir = getStaticDir;
function toString(str) {
    if (str != null) {
        if (typeof str === 'string') {
            return str;
        }
        try {
            return JSON.stringify(str);
        }
        catch (e) { }
    }
    return '';
}
exports.toString = toString;
let index = 0;
function padReqId(num) {
    if (num > 99) {
        return num;
    }
    if (num > 9) {
        return '0' + num;
    }
    return '00' + num;
}
const getReqId = function () {
    if (index > 999) {
        index = 0;
    }
    return Date.now() + '-' + padReqId(index++) + exports.workerIndex;
};
exports.getReqId = getReqId;
function onSocketEnd(socket, callback) {
    const execCallback = function (err) {
        socket._hasError = true;
        if (callback) {
            callback(err);
            callback = null;
        }
    };
    if (socket.aborted || socket.destroyed || socket._hasError) {
        return execCallback();
    }
    socket.on('error', execCallback);
    socket.once('close', execCallback);
    socket.once('end', execCallback);
    socket.once('timeout', execCallback);
}
exports.onSocketEnd = onSocketEnd;
const getEmptyRes = function getRes() {
    const res = new stream_1.PassThrough();
    res._transform = noop;
    res.on('data', noop);
    res.destroy = noop;
    return res;
};
exports.getEmptyRes = getEmptyRes;
const REQ_HEADER_RE = /^req\.?H(?:eaders?)?\.(.+)$/i;
const RES_HEADER_RE = /^res\.?H(?:eaders?)?\.(.+)$/i;
const TRAILER_RE = /trailer\.(.+)$/;
const HEADER_RE = /^headers\.(.+)$/;
function parseDeleteProperties(req) {
    const deleteRule = req['delete'];
    const reqHeaders = {};
    const resHeaders = {};
    const trailers = {};
    if (deleteRule) {
        Object.keys(deleteRule).forEach(function (prop) {
            if (REQ_HEADER_RE.test(prop)) {
                reqHeaders[RegExp.$1.toLowerCase()] = 1;
            }
            else if (RES_HEADER_RE.test(prop)) {
                resHeaders[RegExp.$1.toLowerCase()] = 1;
            }
            else if (HEADER_RE.test(prop)) {
                prop = RegExp.$1.toLowerCase();
                reqHeaders[prop] = 1;
                resHeaders[prop] = 1;
            }
            else if (TRAILER_RE.test(prop)) {
                trailers[RegExp.$1.toLowerCase()] = 1;
            }
        });
    }
    return {
        reqHeaders: reqHeaders,
        resHeaders: resHeaders,
        trailers: trailers
    };
}
exports.parseDeleteProperties = parseDeleteProperties;
const deleteReqHeaders = function (req) {
    const delReqHeaders = parseDeleteProperties(req).reqHeaders;
    const headers = req.headers;
    Object.keys(delReqHeaders).forEach(function (name) {
        delete headers[name];
    });
};
exports.deleteReqHeaders = deleteReqHeaders;
const URL_RE = /^https?:\/\/./;
function parseOrigin(origin) {
    if (!isString(origin)) {
        return;
    }
    let index = origin.indexOf('//');
    if (index !== -1) {
        index = origin.indexOf('/', index + 2);
        if (index != -1) {
            origin = origin.substring(0, index);
        }
    }
    return origin;
}
const setReqCors = function (data, cors) {
    if (!cors) {
        return;
    }
    cors = lowerCaseify(cors);
    let origin;
    if (cors.origin === '*') {
        origin = cors.origin;
    }
    else if (URL_RE.test(cors.origin)) {
        origin = parseOrigin(cors.origin);
    }
    if (origin !== undefined) {
        setHeader(data, 'origin', origin);
    }
    else if (cors['*'] === '') {
        setHeader(data, 'origin', '*');
    }
    if (cors.method !== undefined) {
        setHeader(data, 'access-control-request-method', cors.method);
    }
    if (cors.headers !== undefined) {
        setHeader(data, 'access-control-request-headers', cors.headers);
    }
};
exports.setReqCors = setReqCors;
function isEnableCors(cors) {
    return cors.enable === '' || cors['use-credentials'] === '' || cors['credentials'] === '';
}
const setResCors = function (data, cors, req) {
    if (!cors) {
        return;
    }
    cors = lowerCaseify(cors);
    let cusOrigin;
    if (cors.origin === '*') {
        cusOrigin = cors.origin;
    }
    else if (URL_RE.test(cors.origin)) {
        cusOrigin = parseOrigin(cors.origin);
    }
    const isEnable = isEnableCors(cors);
    const isOptions = req.method === 'OPTIONS';
    const isStar = cors['*'] === '';
    if (cusOrigin || isEnable) {
        const origin = cusOrigin || req.headers.origin;
        if (origin) {
            setHeaders(data, {
                'access-control-allow-credentials': true,
                'access-control-allow-origin': origin
            });
        }
    }
    else if (isStar) {
        setHeader(data, 'access-control-allow-origin', '*');
    }
    if (cors.methods !== undefined) {
        setHeader(data, 'access-control-allow-methods', cors.methods);
    }
    const autoComp = isOptions && (isStar || isEnable);
    if (cors.headers !== undefined) {
        const operate = isOptions ? 'allow' : 'expose';
        setHeader(data, 'access-control-' + operate + '-headers', cors.headers);
    }
    else if (autoComp) {
        const headers = req.headers['access-control-request-headers'];
        if (headers) {
            setHeader(data, 'access-control-allow-headers', headers);
        }
    }
    if (cors.credentials !== undefined) {
        setHeader(data, 'access-control-allow-credentials', cors.credentials);
    }
    else if (autoComp) {
        const method = req.headers['access-control-request-method'];
        if (method) {
            setHeader(data, 'access-control-allow-method', method);
        }
    }
    if (cors.maxage !== undefined) {
        setHeader(data, 'access-control-max-age', cors.maxage);
    }
};
exports.setResCors = setResCors;
const disableReqProps = function (req) {
    const disable = req.disable;
    const headers = req.headers;
    if (disable.ua) {
        delete headers['user-agent'];
    }
    if (disable.gzip) {
        delete headers['accept-encoding'];
    }
    if (disable.cookie || disable.cookies || disable.reqCookie || disable.reqCookies) {
        delete headers.cookie;
    }
    if (disable.referer || disable.referrer) {
        delete headers.referer;
    }
    if (disable.ajax) {
        delete headers['x-requested-with'];
    }
    if (disable.cache) {
        disableReqCache(headers);
    }
};
exports.disableReqProps = disableReqProps;
const disableResProps = function (req, headers) {
    const disable = req.disable;
    if (disable.cookie || disable.cookies || disable.resCookie || disable.resCookies) {
        delete headers['set-cookie'];
    }
    if (disable.cache) {
        headers['cache-control'] = 'no-cache';
        headers.expires = new Date(Date.now() - 60000000).toUTCString();
        headers.pragma = 'no-cache';
    }
    disable.csp && disableCSP(headers);
};
exports.disableResProps = disableResProps;
const G_INVALID_NAME_CHAR_RE = /[^\x00-\xFF]|[\r\n;=%]/gu;
const INVALID_NAME_CHAR_RE = /[\r\n;=]/;
function escapeName(name) {
    if (!name || (!NON_LATIN1_RE.test(name) && !INVALID_NAME_CHAR_RE.test(name))) {
        return name;
    }
    return name.replace(G_INVALID_NAME_CHAR_RE, safeEncodeURIComponent);
}
const G_INVALID_VALUE_CHAR_RE = /[^\x00-\xFF]|[\r\n;%]/gu;
const INVALID_VALUE_CHAR_RE = /[\r\n;]/;
function escapeValue(value) {
    if (!isString(value)) {
        return (value = value == null ? '' : String(value));
    }
    if (!NON_LATIN1_RE.test(value) && !INVALID_VALUE_CHAR_RE.test(value)) {
        return value;
    }
    return value.replace(G_INVALID_VALUE_CHAR_RE, safeEncodeURIComponent);
}
const setReqCookies = function (data, cookies, curCookies) {
    const list = cookies && Object.keys(cookies);
    if (!list || !list.length) {
        return;
    }
    const result = {};
    if (isString(curCookies)) {
        curCookies.split(/;\s*/g).forEach(function (cookie) {
            const index = cookie.indexOf('=');
            if (index == -1) {
                result[cookie] = null;
            }
            else {
                result[cookie.substring(0, index)] = cookie.substring(index + 1);
            }
        });
    }
    list.forEach(function (name) {
        let value = cookies[name];
        value = value && typeof value === 'object' ? value.value : value;
        result[escapeName(name)] = value ? escapeValue(value) : value;
    });
    const cookiesStr = Object.keys(result)
        .map(function (name) {
        const value = result[name];
        return name + (value == null ? '' : '=' + value);
    })
        .join('; ');
    setHeader(data, 'cookie', cookiesStr);
};
exports.setReqCookies = setReqCookies;
const setResCookies = function (data, cookies) {
    const list = cookies && Object.keys(cookies);
    if (!list || !list.length) {
        return;
    }
    let curCookies = data.headers && data.headers['set-cookie'];
    if (!Array.isArray(curCookies)) {
        curCookies = curCookies ? [curCookies + ''] : [];
    }
    const result = {};
    curCookies.forEach(function (cookie) {
        const index = cookie.indexOf('=');
        if (index == -1) {
            result[cookie] = null;
        }
        else {
            result[cookie.substring(0, index)] = cookie.substring(index + 1);
        }
    });
    list.forEach(function (name) {
        const cookie = cookies?.[name];
        name = escapeName(name);
        if (!cookie || typeof cookie !== 'object') {
            result[name] = cookie ? escapeValue(cookie) : cookie;
        }
        else {
            const attrs = [];
            const value = cookie.value;
            attrs.push(escapeValue(value));
            let maxAge = cookie.maxAge || cookie.maxage || cookie['Max-Age'] || cookie['max-age'];
            maxAge = parseInt(cookie.maxAge, 10);
            if (!Number.isNaN(maxAge)) {
                attrs.push('Expires=' + new Date(Date.now() + maxAge * 1000).toUTCString());
                attrs.push('Max-Age=' + maxAge);
            }
            cookie.secure && attrs.push('Secure');
            cookie.path && attrs.push('Path=' + cookie.path);
            cookie.domain && attrs.push('Domain=' + cookie.domain);
            (cookie.httpOnly || cookie.httponly) && attrs.push('HttpOnly');
            const sameSite = cookie.sameSite || cookie.samesite || cookie.SameSite;
            sameSite && attrs.push('SameSite=' + sameSite);
            result[name] = attrs.join('; ');
        }
    });
    const cookiesStr = Object.keys(result).map(function (name) {
        const value = result[name];
        return name + (value == null ? '' : '=' + value);
    });
    setHeader(data, 'set-cookie', cookiesStr);
};
exports.setResCookies = setResCookies;
const escapeRegExp = function (str) {
    if (!str) {
        return '';
    }
    return str.replace(/[|\\{}()[\]^$+?.]/g, '\\$&');
};
exports.escapeRegExp = escapeRegExp;
const checkTlsError = function (err) {
    if (!err) {
        return false;
    }
    if (err.code === 'EPROTO') {
        return true;
    }
    const stack = err.stack || err.message;
    if (!isString(stack)) {
        return false;
    }
    if (stack.indexOf('TLSSocket.onHangUp') !== -1 || stack.indexOf('statusCode=502') !== -1) {
        return true;
    }
    return stack.toLowerCase().indexOf('openssl') !== -1;
};
exports.checkTlsError = checkTlsError;
const checkAuto2Http = function (req, ip, proxyUrl) {
    return (!req.disable.auto2http && (req.enable.auto2http || req.rules.host || (proxyUrl ? req._phost : isLocalAddress(ip))));
};
exports.checkAuto2Http = checkAuto2Http;
const setProxyHost = function (req, options, reserve) {
    const phost = req._phost || options;
    const opts = reserve ? options : (0, extend_1.default)({}, options);
    opts.host = phost.hostname;
    if (phost.port > 0) {
        opts.port = phost.port;
    }
    opts.headers = opts.headers || {};
    config_1.default.setHeader(opts.headers, 'host', opts.host + ':' + opts.port);
    return opts;
};
exports.setProxyHost = setProxyHost;
const getHostIp = function (ip, port) {
    if (!port) {
        return ip;
    }
    if (net_1.default.isIP(ip) === 6) {
        ip = '[' + ip + ']';
    }
    return ip + ':' + port;
};
exports.getHostIp = getHostIp;
function getMethod(method) {
    if (typeof method !== 'string') {
        return 'GET';
    }
    return method.trim().toUpperCase() || 'GET';
}
exports.getMethod = getMethod;
const COMMENT_RE = /^\s*#/;
const SCRIPT_RE = /\b(?:rules|values)\b/;
function isRulesContent(ctn) {
    return COMMENT_RE.test(ctn) || !SCRIPT_RE.test(ctn);
}
exports.isRulesContent = isRulesContent;
const RESPONSE_FOR_NAME = /^name=(.+)$/;
const setResponseFor = function (rules, headers, req, serverIp) {
    let responseFor = getMatcherValue(rules.responseFor);
    if (!responseFor) {
        if (req.isPluginReq && !isLocalAddress(serverIp)) {
            responseFor = trimStr(headers['x-whistle-response-for']);
            responseFor = responseFor ? responseFor.split(',').map(trim).filter(noop) : [];
            if (responseFor.indexOf(serverIp) === -1) {
                responseFor.push(serverIp);
            }
            headers['x-whistle-response-for'] = responseFor.join(', ');
        }
        return;
    }
    const reqHeaders = req.headers;
    if (RESPONSE_FOR_NAME.test(responseFor)) {
        let result = RegExp.$1.toLowerCase().split(',');
        const reqResult = [];
        result = result
            .map(function (name) {
            if (name.indexOf('req.') === 0) {
                name = reqHeaders[name.substring(4)];
                name && reqResult.push(name);
                return;
            }
            return headers[name];
        })
            .filter(noop);
        result.push(serverIp || '127.0.0.1');
        responseFor = result.concat(reqResult).join(', ');
    }
    headers['x-whistle-response-for'] = responseFor;
};
exports.setResponseFor = setResponseFor;
const getNoPluginServerMsg = function (rule) {
    let msg = 'No implement plugin.server';
    if (rule) {
        msg +=
            '\n       try to set the following rules:\n       <strong>' +
                rule.pattern +
                ' whistle.' +
                rule.matcher +
                '</strong>';
    }
    return msg;
};
exports.getNoPluginServerMsg = getNoPluginServerMsg;
const CONFIG_VAR_RE = /\${(port|version)}/gi;
const PLUGIN_RULES_URL_RE = /^whistle\.([a-z\d_-]+)(?:$|\/)/i;
const PLUGIN_KEY_RE = /^\$(?:whistle\.)?([a-z\d_-]+)[/:]([\S\s]+)$/;
function setConfigVarFn(_, name) {
    return config_1.default[name.toLowerCase()];
}
const getRemoteRules = function (apo, rulesUrl) {
    let headers = config_1.default.runtimeHeaders;
    let pluginName;
    if (PLUGIN_RULES_URL_RE.test(rulesUrl)) {
        pluginName = RegExp.$1;
        rulesUrl = pluginName + '/' + rulesUrl.substring(RegExp['$&'].length);
        headers = config_1.default.pluginHeaders;
    }
    else if (PLUGIN_KEY_RE.test(rulesUrl)) {
        pluginName = RegExp.$1;
        rulesUrl = pluginName + '/api/key/value?key=' + safeEncodeURIComponent(RegExp.$2);
        headers = config_1.default.pluginHeaders;
    }
    if (apo) {
        rulesUrl = rulesUrl.replace(CONFIG_VAR_RE, setConfigVarFn);
    }
    return httpMgr.add(rulesUrl, headers, pluginName);
};
exports.getRemoteRules = getRemoteRules;
function isCustomParser(req) {
    const enable = req.enable;
    return enable && (enable.customParser || enable.customFrames);
}
exports.isCustomParser = isCustomParser;
const getParserStatus = function (req) {
    if (!isCustomParser(req)) {
        return;
    }
    const enable = req.enable;
    const customParser = ['custom'];
    if (enable.pauseSend) {
        customParser.push('pauseSend');
    }
    else if (enable.ignoreSend) {
        customParser.push('ignoreSend');
    }
    if (enable.pauseReceive) {
        customParser.push('pauseReceive');
    }
    else if (enable.ignoreReceive) {
        customParser.push('ignoreReceive');
    }
    return customParser.join();
};
exports.getParserStatus = getParserStatus;
const isInspect = function (enable) {
    return enable.inspect || enable.pauseReceive || enable.pauseSend || enable.ignoreReceive || enable.ignoreSend;
};
exports.isInspect = isInspect;
const BYTES_RANGE_RE = /^\s*bytes=/i;
const parseRange = function (req, size) {
    let range = size && req.headers.range;
    if (!range || !BYTES_RANGE_RE.test(range)) {
        return;
    }
    range = range.substring(range.indexOf('=') + 1).trim();
    if (!range) {
        return;
    }
    let start = size;
    let end = -1;
    range = range.split(',').forEach(function (item) {
        item = item.split('-');
        let s = parseInt(item[0], 10);
        let e = parseInt(item[1], 10);
        if (isNaN(s)) {
            if (isNaN(e)) {
                return;
            }
            s = size - e;
        }
        else if (isNaN(e)) {
            e = size - 1;
        }
        start = Math.min(s, start);
        end = Math.max(end, e);
    });
    if (start < 0 || end < 0 || start > end || end >= size) {
        return;
    }
    return {
        start: start,
        end: end
    };
};
exports.parseRange = parseRange;
const parseClientInfo = function (req) {
    let clientInfo = req.headers[config_1.default.CLIENT_INFO_HEAD] || '';
    if (req.headers[config_1.default.REQ_FROM_HEADER] === 'W2COMPOSER') {
        req.fromComposer = true;
        delete req.headers[config_1.default.REQ_FROM_HEADER];
    }
    const socket = req.socket || '';
    if (socket.fromTunnel) {
        req.fromTunnel = true;
    }
    if (clientInfo) {
        delete req.headers[config_1.default.CLIENT_INFO_HEAD];
        clientInfo = String(clientInfo).split(',');
        if (!net_1.default.isIP(clientInfo[0]) || !(clientInfo[1] > 0)) {
            return '';
        }
        req.fromTunnel = true;
        socket.fromTunnel = true;
    }
    return clientInfo;
};
exports.parseClientInfo = parseClientInfo;
function getCipher(rules) {
    let cipher = rules && getMatcherValue(rules.cipher);
    if (!cipher) {
        return TLSV2_CIPHERS;
    }
    cipher = cipher.toUpperCase();
    return CIPHER_OPTIONS.indexOf(cipher) === -1 ? TLSV2_CIPHERS : cipher;
}
exports.getCipher = getCipher;
const connect = function (options, callback) {
    let socket;
    let timer;
    let done;
    let retry;
    const sockMgr = options.ALPNProtocols ? tls_1.default : net_1.default;
    const execCallback = function (err) {
        clearTimeout(timer);
        timer = null;
        if (!done) {
            done = true;
            err ? callback(err) : callback(null, socket);
        }
    };
    const handleConnect = function () {
        execCallback();
    };
    const handleError = function (err) {
        if (done) {
            return;
        }
        socket.removeAllListeners();
        socket.on('error', noop);
        socket.destroy(err);
        clearTimeout(timer);
        if (retry) {
            return execCallback(err);
        }
        retry = true;
        timer = setTimeout(handleTimeout, 12000);
        try {
            if (options.ALPNProtocols && err && isCiphersError(err)) {
                options.ciphers = getCipher(options._rules);
            }
            socket = sockMgr.connect(options, handleConnect);
        }
        catch (e) {
            return execCallback(e);
        }
        socket.on('error', handleError);
        socket.on('close', function (err) {
            !done && execCallback(err || new Error('closed'));
        });
    };
    const handleTimeout = function () {
        handleError(new Error('Timeout'));
    };
    timer = setTimeout(handleTimeout, 6000);
    try {
        socket = sockMgr.connect(options, handleConnect);
    }
    catch (e) {
        return execCallback(e);
    }
    socket.on('error', handleError);
};
exports.connect = connect;
const checkPluginReqOnce = function (req, raw) {
    const isPluginReq = req.headers[config_1.default.PROXY_ID_HEADER];
    if (raw ? isPluginReq : isPluginReq == 1) {
        delete req.headers[config_1.default.PROXY_ID_HEADER];
    }
    return isPluginReq;
};
exports.checkPluginReqOnce = checkPluginReqOnce;
const showPluginReq = function (req) {
    return !req.isPluginReq || config_1.default.showPluginReq;
};
exports.showPluginReq = showPluginReq;
const checkPort = function (port, host, cb) {
    if (typeof host !== 'string') {
        cb = host;
        host = '127.0.0.1';
    }
    if (!port) {
        return cb?.();
    }
    const server = http_1.default.createServer();
    server.listen(port, host, function () {
        server.close(cb);
    });
};
exports.checkPort = checkPort;
const boundIpDeferMap = {};
const getBoundIp = function (host, cb) {
    if (typeof host === 'function') {
        cb = host;
        host = null;
    }
    host = host || config_1.default.defaultHost;
    if (!host || net_1.default.isIP(host)) {
        return cb(host);
    }
    let boundIpDefer = boundIpDeferMap[host];
    if (boundIpDefer) {
        return boundIpDefer.done(cb);
    }
    const defer = q_1.default.defer();
    boundIpDefer = defer.promise;
    boundIpDeferMap[host] = boundIpDefer;
    boundIpDefer.done(cb);
    dns_1.default.lookup(host, function (err, ip) {
        if (err) {
            throw err;
        }
        defer.resolve(ip);
    });
};
exports.getBoundIp = getBoundIp;
function getPluginConfig(conf, name) {
    let result;
    if (conf != null) {
        try {
            result = JSON.stringify(conf);
        }
        catch (e) { }
    }
    return '<script>window.' + (name || 'whistleMenuConfig') + ' = ' + (result || '{}') + ';</script>';
}
const getPluginMenuConfig = function (conf) {
    return getPluginConfig(conf.menuConfig);
};
exports.getPluginMenuConfig = getPluginMenuConfig;
const getPluginInspectorConfig = function (conf) {
    return getPluginConfig(conf.inspectorConfig, 'whistleInspectorConfig');
};
exports.getPluginInspectorConfig = getPluginInspectorConfig;
const isEnableH2 = function (req) {
    const enable = req.enable || '';
    const disable = req.disable || '';
    return enable.h2 && !disable.h2;
};
exports.isEnableH2 = isEnableH2;
const isDisableH2 = function (req, strict) {
    const enable = req.enable || '';
    const disable = req.disable || '';
    return strict ? disable.http2 && !enable.http2 : disable.h2 && !enable.h2;
};
exports.isDisableH2 = isDisableH2;
function isIllegalcHeader(name, value) {
    switch (name) {
        case http2_1.constants.HTTP2_HEADER_CONNECTION:
        case http2_1.constants.HTTP2_HEADER_UPGRADE:
        case http2_1.constants.HTTP2_HEADER_HOST:
        case http2_1.constants.HTTP2_HEADER_HTTP2_SETTINGS:
        case http2_1.constants.HTTP2_HEADER_KEEP_ALIVE:
        case http2_1.constants.HTTP2_HEADER_PROXY_CONNECTION:
        case http2_1.constants.HTTP2_HEADER_TRANSFER_ENCODING:
            return true;
        case http2_1.constants.HTTP2_HEADER_TE:
            return value !== 'trailers';
        default:
            return false;
    }
}
const formatH2Headers = function (headers) {
    const newHeaders = {};
    Object.keys(headers).forEach(function (name) {
        const value = headers[name];
        if (!isIllegalcHeader(name, value)) {
            newHeaders[name] = value;
        }
    });
    return newHeaders;
};
exports.formatH2Headers = formatH2Headers;
function getProp(obj, key, def) {
    key = key.split('.');
    for (let i = 0; i < key.length; i++) {
        obj = obj ? obj[key[i]] : undefined;
    }
    return obj == null ? def : obj;
}
const PLUGIN_VAR_RE = /\{\{(?:whistlePluginName|whistlePluginPackage\.([^}\s]+))\}\}/g;
const renderPluginRules = function (rules, pkg, simpleName) {
    return (rules &&
        rules.replace(PLUGIN_VAR_RE, function (_, key) {
            return key ? getProp(pkg, key, '') : simpleName;
        }));
};
exports.renderPluginRules = renderPluginRules;
const setClientCert = function (options, key, cert, isPfx, cacheKey) {
    if (!cert) {
        return;
    }
    options.cacheKey = cacheKey;
    if (isPfx) {
        options.pfx = cert;
        if (key) {
            options.passphrase = key;
        }
    }
    else {
        options.key = key;
        options.cert = cert;
    }
};
exports.setClientCert = setClientCert;
const getStatusCodeFromRule = function (rules) {
    let rule = rules.rule;
    const isSpec = rule && rule.isSpec;
    if (!isSpec) {
        return;
    }
    rule = getMatcherValue(rule);
    if (!rule) {
        return;
    }
    const result = {
        statusCode: rule,
        headers: {
            location: undefined
        }
    };
    if (isSpec === 2) {
        result.statusCode = 302;
        result.headers.location = rule;
    }
    else {
        handleStatusCode(rule, result.headers);
    }
    return result;
};
exports.getStatusCodeFromRule = getStatusCodeFromRule;
const GZIP_RE = /\bgzip\b/i;
const canGzip = function (req) {
    return GZIP_RE.test(req.headers['accept-encoding']);
};
exports.canGzip = canGzip;
function removeBody(req, data, isRes) {
    const rule = req['delete'] || '';
    if (rule.body || rule[isRes ? 'res.body' : 'req.body']) {
        delete data.top;
        delete data.bottom;
        data.body = exports.EMPTY_BUFFER;
    }
}
const removeReqBody = function (req, data) {
    removeBody(req, data);
};
exports.removeReqBody = removeReqBody;
const removeResBody = function (req, data) {
    removeBody(req, data, true);
};
exports.removeResBody = removeResBody;
function readOneChunk(stream, callback, timeout) {
    if (!stream) {
        return callback();
    }
    let timer;
    const handler = function (chunk) {
        timer && clearTimeout(timer);
        stream.pause();
        stream.removeListener('data', handler);
        stream.removeListener('end', handler);
        callback(chunk);
    };
    if (timeout !== undefined && timeout > 0) {
        timer = setTimeout(handler, timeout);
    }
    stream.on('data', handler);
    stream.on('end', handler);
}
exports.readOneChunk = readOneChunk;
const getAuthByRules = function (rules) {
    if (!rules.auth) {
        return;
    }
    const auth = getMatcherValue(rules.auth);
    if (/[\\\/]/.test(auth)) {
        return;
    }
    const index = auth.indexOf(':');
    return {
        username: index == -1 ? auth : auth.substring(0, index),
        password: index == -1 ? null : auth.substring(index + 1)
    };
};
exports.getAuthByRules = getAuthByRules;
const getAuthBasic = function (auth) {
    if (!auth) {
        return;
    }
    let basic;
    if (auth.username == null) {
        if (auth.password == null) {
            return;
        }
        basic = [''];
    }
    else {
        basic = [auth.username];
    }
    if (auth.password != null) {
        basic[1] = auth.password;
    }
    return basic && 'Basic ' + (0, exports.toBuffer)(basic.join(':')).toString('base64');
};
exports.getAuthBasic = getAuthBasic;
const delay = function (time, callback) {
    if (time > 0) {
        setTimeout(callback, time);
    }
    else {
        callback();
    }
};
exports.delay = delay;
const F_HOST_RE = /\bhost\b/i;
const F_PROTO_RE = /\bproto\b/i;
const F_IP_RE = /\b(?:clientIp|ip|for)\b/i;
const handleForwardedProps = function (req) {
    const headers = req.headers;
    const props = headers['x-whistle-forwarded-props'];
    let enableFwdHost = config_1.default.enableFwdHost;
    let enableFwdProto = config_1.default.enableFwdProto;
    let enableFwdFor = config_1.default.keepXFF;
    if (props != null) {
        enableFwdHost = enableFwdHost || F_HOST_RE.test(props);
        enableFwdProto = enableFwdProto || F_PROTO_RE.test(props);
        enableFwdFor = enableFwdFor || F_IP_RE.test(props);
        if (config_1.default.master && enableFwdFor) {
            headers['x-whistle-forwarded-props'] = 'ip';
        }
        else {
            delete headers['x-whistle-forwarded-props'];
        }
    }
    req.enableXFF = enableFwdFor;
    if (enableFwdHost) {
        const host = headers[config_1.default.FWD_HOST_HEADER];
        if (host) {
            delete headers[config_1.default.FWD_HOST_HEADER];
            headers[config_1.default.REAL_HOST_HEADER] = headers[config_1.default.REAL_HOST_HEADER] || host;
        }
    }
    if (enableFwdProto) {
        const proto = headers[config_1.default.HTTPS_PROTO_HEADER];
        if (proto) {
            delete headers[config_1.default.HTTPS_PROTO_HEADER];
            req.isHttps = proto === 'https';
        }
    }
};
exports.handleForwardedProps = handleForwardedProps;
const filterWeakRule = function (req) {
    const rule = req.rules && req.rules.rule;
    if (!rule) {
        return;
    }
    const proxy = req.rules.proxy;
    if ((!proxy || proxy.lineProps.proxyHostOnly) && !req.rules.host) {
        return;
    }
    if (rule.lineProps.weakRule || isEnable(req, 'weakRule')) {
        delete req.rules.rule;
    }
};
exports.filterWeakRule = filterWeakRule;
const setPluginMgr = function (p) {
    pluginMgr = p;
};
exports.setPluginMgr = setPluginMgr;
function setTunnelHeaders(headers, remoteData) {
    const tunnelFirst = remoteData.tunnelFirst;
    if (remoteData.clientId) {
        headers[config_1.default.CLIENT_ID_HEADER] = remoteData.clientId;
    }
    if (remoteData.proxyAuth && (tunnelFirst || !headers['proxy-authorization'])) {
        headers['proxy-authorization'] = remoteData.proxyAuth;
    }
    if (remoteData.tunnelData) {
        headers[config_1.default.TUNNEL_DATA_HEADER] = remoteData.tunnelData;
    }
    if (remoteData.sniPlugin) {
        headers[config_1.default.SNI_PLUGIN_HEADER] = remoteData.sniPlugin;
    }
    const tunnelHeaders = remoteData.headers;
    if (tunnelHeaders) {
        Object.keys(tunnelHeaders).forEach(function (key) {
            if (tunnelFirst || !headers[key]) {
                headers[key] = tunnelHeaders[key];
            }
        });
    }
}
exports.setTunnelHeaders = setTunnelHeaders;
const tunnelDataKey = config_1.default.TUNNEL_DATA_HEADER;
const tmplDataKey = config_1.default.TEMP_TUNNEL_DATA_HEADER;
const addTunnelData = function (socket, headers) {
    let data = socket[tunnelDataKey];
    if (!data) {
        data = headers[tmplDataKey];
        if (data) {
            delete headers[tmplDataKey];
            try {
                data = decodeURIComponent(data);
                data = JSON.parse(data);
                socket[tunnelDataKey] = data;
            }
            catch (e) {
                return;
            }
        }
    }
    data && setTunnelHeaders(headers, data);
};
exports.addTunnelData = addTunnelData;
function _isInternalProxy(rule) {
    return rule && rule.lineProps.internalProxy;
}
const isInternalProxy = function (req) {
    if (isEnable(req, 'internalProxy')) {
        return true;
    }
    const rules = req.rules || '';
    return _isInternalProxy(rules.proxy) || _isInternalProxy(rules.host);
};
exports.isInternalProxy = isInternalProxy;
const IP_RE = /^(\d{1,3}(?:\.\d{1,3}){3}|localhost|\[[^\]]+\])(?::\d+)$/;
function checkProxyHostFn(host, filter) {
    let result;
    if (filter.hostPattern) {
        result = filter.hostPattern.test(host);
    }
    else if (filter.host === '<local>') {
        if (IP_RE.test(host)) {
            host = RegExp.$1;
        }
        result = host === 'localhost' || isLocalAddress(host);
    }
    else if (filter.host) {
        if (filter.host.slice(-1) === ':') {
            result = !host.indexOf(filter.host);
        }
        else {
            result = host === filter.host;
        }
    }
    return filter.not ? !result : result;
}
const checkProxyHost = function (proxy, host) {
    const filters = proxy && proxy.hostFilter;
    if (filters) {
        if (!host) {
            return false;
        }
        let hasIncludeFilter;
        let include, exclude;
        for (let i = 0, len = filters.length; i < len; i++) {
            const filter = filters[i];
            hasIncludeFilter = hasIncludeFilter || filter.isInclude;
            if ((filter.isInclude ? !include : !exclude) && checkProxyHostFn(host, filter)) {
                if (filter.isInclude) {
                    include = true;
                }
                else {
                    exclude = true;
                }
            }
        }
        return hasIncludeFilter ? include && !exclude : !exclude;
    }
    return true;
};
exports.checkProxyHost = checkProxyHost;
