"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const net_1 = tslib_1.__importDefault(require("net"));
const safe_buffer_1 = require("safe-buffer");
const config_1 = tslib_1.__importDefault(require("../config"));
const socket_mgr_1 = require("../socket-mgr");
const logger_1 = tslib_1.__importDefault(require("./logger"));
const index_1 = require("./index");
const version = config_1.default.version;
const nodeVersion = process.version.substring(1);
if (!(config_1.default.reqCacheSize > 0) || config_1.default.reqCacheSize < 600) {
    config_1.default.reqCacheSize = 600;
}
if (!(config_1.default.frameCacheSize > 0) || config_1.default.frameCacheSize < 720) {
    config_1.default.frameCacheSize = 600;
}
const CLEAR_INTERVAL = 6000;
const CACHE_TIME = 1000 * 60 * 2;
const MAX_CACHE_TIME = 1000 * 60 * 6;
const MAX_LENGTH = config_1.default.reqCacheSize;
const OVERFLOW_LENGTH = MAX_LENGTH * 3;
const MAX_CACHE_SIZE = MAX_LENGTH * 2;
const PRESERVE_LEN = 360;
const MAX_FRAMES_LENGTH = config_1.default.frameCacheSize;
const COUNT = 100;
let count = 0;
let ids = [];
const reqData = {};
const framesCache = [];
let framesMap = {};
let clearCount = 0;
let proxy;
let binded;
function enable() {
    if (binded) {
        return;
    }
    binded = true;
    proxy.on('request', handleRequest);
    proxy.on('frame', handleFrame);
    setInterval(clearCache, CLEAR_INTERVAL);
}
/**
 * 如果超过最大缓存数，清理如下请求数据：
 * 1. 已经请求结束且结束时间超过10秒
 * 2. 请求#1前面的未结束且未被ui读取过的请求
 */
const MAX_BUF_LEN1 = 1024 * 512;
const MAX_BUF_LEN2 = 1024 * 256;
const MAX_BUF_LEN3 = 1024 * 128;
const MAX_BUF_LEN4 = 1024 * 64;
const MIN1 = 1000 * 60;
const MIN2 = MIN1 * 2;
const MIN3 = MIN1 * 6;
const MIN4 = MIN1 * 12;
function reduceFrameSize(frame, len, interval, now) {
    const id = frame.frameId;
    if (now - id.substring(0, id.indexOf('-')) < interval) {
        return;
    }
    frame.len = len;
    let bin = frame.bin;
    const base64 = frame.base64;
    if (base64) {
        frame.base64 = null;
        bin = safe_buffer_1.Buffer.from(base64, 'base64');
    }
    if (bin) {
        frame.bin = bin.slice(0, len);
    }
}
const clearFrames = function (frame, now) {
    const len = frame.len || frame.length;
    if (!len || len <= MAX_BUF_LEN4) {
        return;
    }
    if (len > MAX_BUF_LEN1) {
        return reduceFrameSize(frame, MAX_BUF_LEN1, MIN1, now);
    }
    if (len > MAX_BUF_LEN2) {
        return reduceFrameSize(frame, MAX_BUF_LEN2, MIN2, now);
    }
    if (len > MAX_BUF_LEN3) {
        return reduceFrameSize(frame, MAX_BUF_LEN3, MIN3, now);
    }
    reduceFrameSize(frame, MAX_BUF_LEN4, MIN4, now);
};
function clearCache() {
    let overflow = framesCache.length - MAX_FRAMES_LENGTH;
    const now = Date.now();
    // 1 分钟触发一次
    ++clearCount;
    if (clearCount > 10) {
        clearCount = 0;
    }
    if (overflow > 0) {
        framesCache.splice(0, overflow + 60);
        framesMap = {};
        framesCache.forEach(function (frame) {
            framesMap[frame.reqId] = frame;
            !clearCount && clearFrames(frame, now);
        });
    }
    else if (!clearCount) {
        framesCache.forEach(function (frame) {
            clearFrames(frame, now);
        });
    }
    const len = ids.length;
    if (len <= MAX_LENGTH) {
        return;
    }
    const _ids = [];
    let preserveLen = len;
    overflow = -1;
    if (len >= OVERFLOW_LENGTH) {
        overflow = len - MAX_CACHE_SIZE;
        preserveLen = len - PRESERVE_LEN;
    }
    const isTimeout = (curData, i) => {
        if (i < overflow) {
            return true;
        }
        return (curData.endTime &&
            now - curData.endTime > (i >= preserveLen ? MAX_CACHE_TIME : CACHE_TIME));
    };
    for (let i = 0; i < len; i++) {
        const id = ids[i];
        const curData = reqData[id];
        if (isTimeout(curData, i)) {
            curData.abort && curData.abort(true);
            delete reqData[id];
        }
        else {
            if (curData.abort && now - curData.startTime > MAX_CACHE_TIME) {
                curData.abort(true);
            }
            _ids.push(id);
        }
    }
    ids = _ids;
}
// 不存在startTime相等的id
function getIndex(startTime, start, end) {
    const midIndex = Math.floor((start + end) / 2);
    if (midIndex == start) {
        return end;
    }
    if (ids[midIndex] < startTime) {
        return getIndex(startTime, midIndex, end);
    }
    return getIndex(startTime, start, midIndex);
}
function getIds(startTime, count, lastRowId) {
    startTime = startTime || lastRowId;
    if (!startTime) {
        return ids.slice(-count);
    }
    let index = 0;
    if (startTime !== '0') {
        index = ids.indexOf(startTime) + 1;
        if (!index && startTime.length > 6) {
            const startId = ids[0];
            if (startId && startId < startTime) {
                const end = ids.length - 1;
                if (ids[end] < startTime) {
                    return [];
                }
                index = getIndex(startTime, 0, end);
            }
        }
    }
    return ids.slice(index, index + count);
}
function getList(ids) {
    if (!Array.isArray(ids)) {
        return [];
    }
    return ids.map(function (id) {
        return reqData[id];
    });
}
function handleRequest(req, data) {
    const id = (data.id = data.id || data.startTime + '-' + ++count);
    const removeAbort = function () {
        if (data.abort) {
            delete data.abort;
        }
    };
    req.on('end', removeAbort);
    req.on('error', removeAbort);
    req.on('abort', removeAbort);
    data.version = version;
    data.nodeVersion = nodeVersion;
    reqData[id] = data;
    ids.indexOf(id) === -1 && ids.push(id);
}
function decodeData(frame) {
    if (frame.base64 == null) {
        frame.base64 = frame.bin ? frame.bin.toString('base64') : '';
        frame.bin = '';
    }
    return frame;
}
function handleFrame(data) {
    framesCache.push(data);
    framesMap[data.reqId] = data;
}
function getFrames(curReqId, lastFrameId) {
    if (!curReqId) {
        return [];
    }
    const result = [];
    const lastFrame = framesMap[curReqId];
    if (lastFrame && (!lastFrameId || lastFrame.frameId > lastFrameId)) {
        let count = 16;
        for (let i = 0, len = framesCache.length; i < len; i++) {
            const frame = framesCache[i];
            if (frame.reqId === curReqId &&
                (!lastFrameId || frame.frameId > lastFrameId)) {
                result.push(decodeData(frame));
                if (--count <= 0) {
                    return result;
                }
            }
        }
    }
    return result;
}
function getLastFrame(curReqId) {
    const frame = framesMap[curReqId];
    if (frame && frame.reqId === curReqId) {
        return decodeData(frame);
    }
    return undefined;
}
function init(_proxy) {
    proxy = _proxy;
    enable();
    /**
     * options: {
     * 		startTime: timestamp || timestamp + '-' + count
     * 		count: 获取新数据的数量
     * 		ids: 请未结束的id列表
     * }
     *
     * @param options
     */
    function formatFilter(filter, clientIp, clientId) {
        if (!filter.url && !filter.name && !filter.value && !filter.ip) {
            return;
        }
        const url = (0, index_1.trimStr)(filter.url).toLowerCase();
        let ip = (0, index_1.trimStr)(filter.ip);
        const list = [];
        let cid;
        let result = {};
        if (ip === 'self') {
            ip = clientIp;
            cid = clientId;
        }
        else if (ip === 'clientIp') {
            ip = clientIp;
        }
        if (ip === 'clientId') {
            if (clientId) {
                cid = clientId;
            }
            else {
                result = { clientIp: clientIp };
            }
            ip = undefined;
        }
        else if (ip && !net_1.default.isIP(ip)) {
            ip.split(',').forEach(function (item) {
                item = item.trim();
                if (item === 'clientId') {
                    cid = clientId;
                }
                else {
                    if (item === 'self') {
                        cid = clientId;
                        item = clientIp;
                    }
                    else if (item === 'clientIp') {
                        item = clientIp;
                    }
                    if (list.indexOf(item) === -1) {
                        list.push(item);
                    }
                }
            });
            ip = undefined;
        }
        if (url) {
            result.url = url;
        }
        let headers = [];
        for (let i = 0; i < 6; i++) {
            const key = 'name' + (i || '');
            const name = (0, index_1.trimStr)(filter[key]).toLowerCase();
            if (name) {
                result = result || {};
                const value = (0, index_1.trimStr)(filter['value' + (i || '')]).toLowerCase();
                if (i) {
                    headers = headers || [];
                    result.headers = headers;
                    headers.push({
                        name: name,
                        value: value
                    });
                }
                else {
                    result.name = name;
                    result.value = value;
                }
            }
        }
        if (ip) {
            result.ip = ip;
        }
        if (cid) {
            result.clientId = cid;
        }
        if (list.length) {
            result.ipList = result.idList = list.slice(0, 16);
        }
        if (result && (result.name || headers) && filter.mtype == 1) {
            result.exact = 1;
        }
        return result;
    }
    function checkClientIp(item, filter) {
        const clientId = getClientId(item);
        const ipList = filter.ipList;
        const clientIp = item.req.ip;
        if (filter.clientIp) {
            return clientId === filter.clientIp;
        }
        if (filter.ip && clientIp === filter.ip) {
            return true;
        }
        // 有 clientId 过滤条件时，必须匹配 clientId
        if (filter.clientId) {
            if (clientId === filter.clientId) {
                return true;
            }
            if (!ipList) {
                return false;
            }
        }
        else if (!ipList) {
            return true;
        }
        const len = ipList.length;
        if (len < 3) {
            if (ipList[0] === clientIp || ipList[0] === clientId) {
                return true;
            }
            if (ipList[1] && (ipList[1] === clientIp || ipList[1] === clientId)) {
                return true;
            }
        }
        else {
            for (let i = 0; i < len; i++) {
                const ip = ipList[i];
                if (ip === clientIp || ip === clientId) {
                    return true;
                }
            }
        }
        return false;
    }
    function checkHeader(text, keyword, exact) {
        if (!keyword) {
            return text != null;
        }
        if (!text || typeof text !== 'string') {
            if (!Array.isArray(text)) {
                return false;
            }
            text = text.join('\n');
        }
        text = text.toLowerCase();
        if (exact) {
            return (text === keyword || text === (0, index_1.encodeURIComponent)(keyword).toLowerCase());
        }
        return (text.indexOf(keyword) !== -1 ||
            text.indexOf((0, index_1.encodeURIComponent)(keyword).toLowerCase()) !== -1);
    }
    function getClientId(item) {
        return (item._clientId ||
            item.req.headers[config_1.default.CLIENT_ID_HEADER] ||
            item.clientId);
    }
    function checkItem(item, filter) {
        if (!item || !checkClientIp(item, filter)) {
            return false;
        }
        const h = item.req.headers;
        if (filter.filterKey && h[filter.filterKey] != filter.filterValue) {
            return false;
        }
        if (filter.filterClientId && getClientId(item) != filter.filterClientId) {
            return false;
        }
        if (filter.name &&
            !checkHeader(h[filter.name], filter.value, filter.exact)) {
            return false;
        }
        if (filter.url &&
            !checkHeader((item.isHttps ? 'tunnel://' : '') + item.url, filter.url)) {
            return false;
        }
        const headers = filter.headers;
        if (headers) {
            for (let i = 0, len = headers.length; i < len; i++) {
                const header = headers[i];
                if (!checkHeader(h[header.name], header.value, filter.exact)) {
                    return false;
                }
            }
        }
        return true;
    }
    proxy.getLastDataId = function () {
        return ids[ids.length - 1];
    };
    function toBase64String(data) {
        if (safe_buffer_1.Buffer.isBuffer(data.body)) {
            data.base64 = data.body.toString('base64');
            data.body = '';
        }
    }
    proxy.getItem = function (id) {
        const item = reqData[id];
        if (item) {
            toBase64String(item.req);
            toBase64String(item.res);
        }
        return item;
    };
    proxy.abortRequest = function (id) {
        const item = id && reqData[id];
        item && item.abort && item.abort();
    };
    proxy.getFrames = function (options) {
        return getFrames(options.curReqId, options.lastFrameId);
    };
    proxy.getData = function (options, clientIp, key, value, filterClientId, clientId) {
        options = options || {};
        let filter = formatFilter(options, clientIp, clientId);
        const data = {};
        let count = options.count;
        let startTime = options.startTime;
        const clearNetwork = !(options.dumpCount > 0) && (count == 0 || startTime == -2);
        if (!clearNetwork) {
            count = count > 0 && count < COUNT ? +count : COUNT;
            if (options.dumpCount > 0) {
                const len = ids.length;
                startTime = ids[len > options.dumpCount ? len - options.dumpCount : 0];
            }
        }
        if (key && value) {
            filter = filter || {};
            filter.filterKey = key;
            filter.filterValue = value;
        }
        if (filterClientId) {
            filter = filter || {};
            filter.filterClientId = filterClientId;
        }
        let newIds = clearNetwork || startTime == -1
            ? []
            : getIds(startTime, count, options.lastRowId);
        const setData = function (item) {
            if (item) {
                const req = item.req;
                const res = item.res;
                toBase64String(req);
                toBase64String(res);
                if (config_1.default.secureFilter) {
                    try {
                        item = config_1.default.secureFilter(item, clientIp, filter) || item;
                    }
                    catch (e) {
                        if (config_1.default.debugMode) {
                            /* eslint-disable no-console */
                            console.log(e);
                        }
                        logger_1.default.error(e);
                    }
                }
                data[item.id] = item;
            }
        };
        if (newIds.length > 0) {
            if (filter) {
                let id = newIds[0];
                let index = ids.indexOf(newIds[0]);
                newIds = [];
                while (id && count > 0) {
                    const item = reqData[id];
                    if (checkItem(item, filter)) {
                        setData(item);
                        newIds.push(id);
                        --count;
                    }
                    id = ids[++index];
                }
            }
            else if (!filter) {
                getList(newIds).forEach(setData);
            }
        }
        getList(options.ids).forEach(setData);
        const endId = ids[ids.length - 1];
        let lastFrameId;
        let frames = [];
        if (options.lastFrameId == -3) {
            const lastFrame = getLastFrame(options.curReqId);
            if (lastFrame) {
                if (lastFrame.closed || lastFrame.err) {
                    frames = [lastFrame];
                }
                else {
                    lastFrameId = lastFrame.frameId;
                }
            }
        }
        else {
            frames = getFrames(options.curReqId, options.lastFrameId);
        }
        const lastNewId = newIds[newIds.length - 1];
        const lastNewFrameId = frames[frames.length - 1]?.frameId;
        const hasNew = (lastNewId && endId !== lastNewId) ||
            (lastNewFrameId && lastNewFrameId !== lastFrameId);
        const tunnelIds = options.tunnelIds;
        const tunnelIps = {};
        if (Array.isArray(tunnelIds) && tunnelIds.length > 0) {
            tunnelIds.forEach(function (id) {
                tunnelIps[id] = proxy.getTunnelIp(id);
            });
        }
        return {
            ids: options.ids || [],
            tunnelIps: tunnelIps,
            newIds: newIds,
            data: data,
            hasNew: hasNew,
            lastId: clearNetwork ? endId : lastNewId,
            endId: endId,
            frames: frames,
            lastFrameId: lastFrameId,
            socketStatus: (0, socket_mgr_1.getStatus)(options.curReqId)
        };
    };
}
exports.default = init;
