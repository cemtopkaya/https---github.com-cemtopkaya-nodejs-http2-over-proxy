"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const hagent_1 = require("hagent");
const hparser_1 = require("hparser");
const import_pkg_1 = require("../import-pkg");
const common = tslib_1.__importStar(require("../util/common"));
const getServer = (0, hagent_1.create)(function () {
    return import_pkg_1.net.createServer({ pauseOnConnect: true });
}, 51500);
const socketProto = import_pkg_1.net.Socket.prototype;
const originConnect = socketProto.connect;
const SPEC_HOST_RE = /.whistle-policy(?:-(internal|capture|tunnel|connect)(?:-([A-Za-z\d]+))?)?(?:\.proto-([\w%.-]+))?$/;
const lru = new import_pkg_1.LRU({ max: 5120, maxAge: 30000 });
let PROXY_ID_HEADER;
let proxyIp;
let proxyPort;
function toNumber(x) {
    x = Number(x);
    return x >= 0 ? x : false;
}
function isPipeName(s) {
    return typeof s === 'string' && toNumber(s) === false;
}
function normalizeArgs(args) {
    if (args.length === 0) {
        return [{}, null];
    }
    const arg0 = args[0];
    if (Array.isArray(arg0)) {
        return arg0;
    }
    let options = {};
    if (typeof arg0 === 'object' && arg0 !== null) {
        // (options[...][, cb])
        options = arg0;
    }
    else if (isPipeName(arg0)) {
        // (path[...][, cb])
        options.path = arg0;
    }
    else {
        // ([port][, host][...][, cb])
        options.port = arg0;
        if (args.length > 1 && typeof args[1] === 'string') {
            options.host = args[1];
        }
    }
    const cb = args[args.length - 1];
    if (typeof cb !== 'function') {
        return [options, null];
    }
    return [options, cb];
}
function createSocket(opts, cb) {
    let done;
    let client;
    const headers = common.lowerCaseify(opts.headers);
    const handleCb = function (err, socket, res) {
        if (!done) {
            done = true;
            cb && cb(err, socket, res);
        }
        if (err && client) {
            client.destroy();
            client = null;
        }
    };
    if (opts.isHttp) {
        headers['x-whistle-policy'] = 'capture';
    }
    else if (opts.isConnect) {
        headers['x-whistle-policy'] = 'connect';
    }
    else if (!headers['x-whistle-policy']) {
        headers['x-whistle-policy'] = 'tunnel';
    }
    if (opts.reqId && typeof opts.reqId === 'string') {
        headers['x-whistle-plugin-request-id'] = opts.reqId;
    }
    if (opts.isInternal) {
        headers[PROXY_ID_HEADER] = '1';
    }
    if (opts.proto) {
        headers['x-whistle-transport-protocol'] = opts.proto;
    }
    opts.path = opts.path || opts.host + ':' + (opts.port || 80);
    headers.host = opts.path;
    const clientIp = common.removeIPV6Prefix(opts.clientIp);
    const clientPort = opts.clientPort;
    if (clientIp && import_pkg_1.net.isIP(clientIp)) {
        headers['x-forwarded-for'] = clientIp;
    }
    if (clientPort > 0 && clientPort < 65536) {
        headers['x-whistle-client-port'] = clientPort;
    }
    headers['x-whistle-request-tunnel-ack'] = '1';
    client = import_pkg_1.http.request({
        host: proxyIp,
        port: proxyPort,
        method: 'CONNECT',
        agent: false,
        path: opts.path,
        headers: headers
    });
    client.once('connect', function (res, socket) {
        socket.on('error', handleCb);
        if (res.statusCode !== 200) {
            const err = new Error('Tunneling socket could not be established, statusCode=' + res.statusCode);
            err.statusCode = res.statusCode;
            socket.destroy();
            return handleCb(err);
        }
        if (res.headers['x-whistle-allow-tunnel-ack']) {
            socket.write('1');
        }
        handleCb(null, socket, res);
    });
    client.on('error', handleCb);
    client.end();
}
function default_1(options, cb) {
    PROXY_ID_HEADER = options.PROXY_ID_HEADER;
    proxyIp = options.proxyIp;
    proxyPort = options.proxyPort;
    const wrapWsReader = options.wrapWsReader;
    const wrapWsWriter = options.wrapWsWriter;
    getServer(function (server, port) {
        const tempServerOpts = {
            host: '127.0.0.1',
            port: port
        };
        server.on('connection', function (socket) {
            let destroyed;
            let sock;
            const destroy = function () {
                if (!destroyed) {
                    destroyed = true;
                    socket.destroy();
                    sock && sock.destroy();
                }
            };
            const handleProxy = function (connOpts) {
                createSocket(connOpts, function (err, sock) {
                    if (err) {
                        return destroy();
                    }
                    sock.on('error', destroy);
                    socket.pipe(sock).pipe(socket);
                    socket.resume();
                });
            };
            const key = `${socket.remotePort}:${port}`;
            const opts = lru.peek(key);
            if (opts) {
                lru.del(key);
                handleProxy(opts);
            }
            else {
                lru.set(key, handleProxy);
            }
        });
        const handleTempCache = function (socket, opts) {
            socket.once('connect', function () {
                const key = `${socket.localPort}:${port}`;
                const handler = lru.get(key);
                if (typeof handler === 'function') {
                    lru.del(key);
                    handler(opts);
                }
                else {
                    lru.set(key, opts);
                }
            });
            return socket;
        };
        const connect = function (opts, cb) {
            const socket = import_pkg_1.net.connect(tempServerOpts, cb);
            handleTempCache(socket, opts);
            socket.on('error', common.noop);
            return socket;
        };
        const request = function (opts, cb) {
            if (typeof opts === 'string') {
                opts = { url: opts };
            }
            else {
                opts = (0, import_pkg_1.extend)({}, opts);
            }
            opts.url = common.setProtocol(opts.url);
            const uri = (0, import_pkg_1.parseUrl)(opts.url);
            let client;
            if (common.isConnect(uri)) {
                client = connect({
                    host: uri.hostname,
                    port: uri.port,
                    headers: opts.proxyHeaders
                }, cb);
                client.isConnect = true;
                client.isTunnel = true;
                return client;
            }
            const protocol = uri.protocol;
            const isHttp = protocol === 'https:' || protocol === 'http:';
            const isWs = common.isWebSocket(uri, opts.headers);
            if (!isHttp && !isWs) {
                return cb && cb(new Error('Bad URL'));
            }
            const rawNames = {};
            const headers = common.lowerCaseify(opts.headers, rawNames);
            const isHttps = protocol === 'https:' || protocol === 'wss:';
            if (isWs) {
                headers.connection = 'Upgrade';
                headers.upgrade = 'websocket';
                rawNames.connection = 'Connection';
                rawNames.upgrade = 'Upgrade';
            }
            if (!opts.reserveHost && uri.host) {
                headers.host = uri.host;
            }
            client = import_pkg_1.http.request({
                path: opts.url || '/',
                method: opts.method,
                agent: null,
                createConnection: function () {
                    return connect({
                        host: uri.hostname || 'localhost',
                        port: uri.port || (isHttps ? 443 : 80),
                        headers: opts.proxyHeaders,
                        isHttp: true,
                        isInternal: opts.isInternal,
                        clientIp: opts.clientIp,
                        clientPort: opts.clientPort
                    });
                },
                headers: (0, hparser_1.formatHeaders)(headers, rawNames)
            }, cb);
            if (isWs) {
                client.once('upgrade', function (res, socket) {
                    socket.headers = res.headers;
                    if (!opts.needRawData) {
                        wrapWsReader(socket, opts.maxPayload);
                        wrapWsWriter(socket);
                        opts.stopPing && socket.stopPing();
                    }
                });
            }
            client.isHttps = isHttps;
            client.isHttp = isHttp;
            client.isWebSocket = isWs;
            client.on('error', common.noop);
            return client;
        };
        socketProto.connect = function () {
            const args = normalizeArgs(arguments);
            const opts = args[0];
            const cb = args[1];
            if (!opts || !SPEC_HOST_RE.test(opts.host)) {
                return originConnect.apply(this, arguments);
            }
            const policy = RegExp.$1;
            const reqId = RegExp.$2;
            const proto = RegExp.$3;
            const host = opts.host.slice(0, -RegExp['$&'].length);
            originConnect.call(this, tempServerOpts, cb);
            handleTempCache(this, {
                host: host || 'localhost',
                port: opts.port,
                reqId: reqId,
                proto: proto,
                headers: opts.proxyHeaders,
                isInternal: policy === 'internal',
                isTunnel: !policy || policy === 'tunnel',
                isConnect: policy === 'connect',
                clientIp: opts.clientIp,
                clientPort: opts.clientPort
            });
            return this;
        };
        cb({
            connect: connect,
            request: request
        });
    });
}
exports.default = default_1;
