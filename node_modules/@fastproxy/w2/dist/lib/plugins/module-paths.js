"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPaths = void 0;
const tslib_1 = require("tslib");
/* eslint-disable no-inner-declarations */
const path_1 = tslib_1.__importDefault(require("path"));
const config_1 = tslib_1.__importDefault(require("../config"));
function formatPath(dir, prefix) {
    if (typeof dir !== 'string' || !(dir = dir.trim())) {
        return undefined;
    }
    if (/(?:^|\/|\\)node_modules[\\\/]?$/.test(dir)) {
        return dir.replace(/\\/g, '/');
    }
    return path_1.default.resolve(dir, typeof prefix === 'string' ? prefix : '', 'node_modules').replace(/\\/g, '/');
}
const MODULE_PATHS = [];
const uniqueArr = function (list) {
    const result = [];
    list.forEach(function (item) {
        if (result.indexOf(item) === -1) {
            result.push(item);
        }
    });
    return result;
};
const resolvePath = function (str) {
    return path_1.default.resolve(str);
};
config_1.default.addInitHook(config => {
    console.log('module paths init after config inited');
    const prePlugins = (config.prePluginsPath || []).map(resolvePath);
    let addon = (config.addon || []).map(resolvePath);
    addon = addon.concat(addon.map(formatPath));
    function addDebugPaths(plugins) {
        if (config.debugMode) {
            const cwd = process.cwd();
            plugins.unshift(cwd);
            config.projectPluginPaths = config.projectPluginPaths || [];
            config.projectPluginPaths.push(cwd);
            const pluginDirRe = /[/\\]whistle\.[a-z\d_-]+[/\\]?$/;
            if (pluginDirRe.test(cwd)) {
                plugins.unshift(cwd.replace(pluginDirRe, '/'));
            }
        }
    }
    let pluginPaths = config.pluginPaths;
    if (pluginPaths.length) {
        pluginPaths = prePlugins.concat(pluginPaths.concat(pluginPaths.map(formatPath).concat(addon)));
        addDebugPaths(pluginPaths);
        pluginPaths = uniqueArr(pluginPaths);
        MODULE_PATHS.push(...pluginPaths);
    }
    else {
        addon = prePlugins.concat(addon);
        if (config.noGlobalPlugins) {
            addDebugPaths(addon);
            addon = uniqueArr(addon);
            MODULE_PATHS.push(...addon);
        }
        else {
            const env = process.env || {};
            let execPath = process.execPath;
            const isWin = process.platform === 'win32';
            const globalDir = formatPath(getGlobalDir());
            const appDataDir = formatPath(env.APPDATA, 'npm');
            let pluginsPath = formatPath(config.baseDir);
            if (typeof execPath !== 'string') {
                execPath = '';
            }
            // TODO: esm规范里的module.paths是空的, 而在commonjs里是一直到根路径
            let paths = (module.paths || []).map((str, prefix) => formatPath(str, prefix));
            paths =
                paths.filter(function (p) {
                    return p;
                }) || [];
            if (paths.indexOf(pluginsPath) == -1) {
                paths.unshift(pluginsPath);
            }
            pluginsPath = formatPath(env.WHISTLE_PLUGINS_PATH);
            if (pluginsPath && paths.indexOf(pluginsPath) == -1) {
                paths.unshift(pluginsPath);
            }
            if (!config.customPluginPaths || !config.customPluginPaths.length) {
                paths.unshift(config.CUSTOM_PLUGIN_PATH);
            }
            paths = addon.concat(paths);
            addDebugPaths(paths);
            let nvmBin = env.NVM_BIN;
            if (nvmBin && typeof nvmBin === 'string') {
                nvmBin = formatPath(path_1.default.join(nvmBin, '../lib'));
                if (paths.indexOf(nvmBin) == -1) {
                    paths.push(nvmBin);
                }
            }
            if (appDataDir && paths.indexOf(appDataDir) == -1) {
                paths.push(appDataDir);
            }
            if (globalDir && paths.indexOf(globalDir) == -1) {
                paths.push(globalDir);
            }
            if (env.PATH && typeof env.PATH === 'string') {
                const list = env.PATH.trim().split(isWin ? ';' : ':');
                ['', '../', '../lib'].forEach(function (prefix) {
                    list.forEach(function (dir) {
                        dir = formatPath(dir, prefix);
                        addPluginPath(dir);
                    });
                });
            }
            function addPluginPath(dir) {
                dir && paths.indexOf(dir) == -1 && paths.push(dir);
            }
            function getGlobalDir() {
                let globalPrefix;
                if (env.PREFIX) {
                    globalPrefix = env.PREFIX;
                }
                else if (isWin) {
                    globalPrefix = execPath && path_1.default.dirname(execPath);
                }
                else {
                    globalPrefix = execPath && path_1.default.dirname(path_1.default.dirname(execPath));
                    if (env.DESTDIR && typeof env.DESTDIR === 'string') {
                        globalPrefix = path_1.default.join(env.DESTDIR, globalPrefix);
                    }
                }
                if (typeof globalPrefix !== 'string') {
                    return;
                }
                return formatPath(globalPrefix, isWin ? '' : 'lib');
            }
            paths = uniqueArr(paths);
            MODULE_PATHS.push(...paths.filter(item => !!item));
        }
    }
});
const getPaths = () => MODULE_PATHS;
exports.getPaths = getPaths;
