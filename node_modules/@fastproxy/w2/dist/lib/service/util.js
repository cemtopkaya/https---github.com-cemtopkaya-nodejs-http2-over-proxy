"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseFrames = exports.removeIPV6Prefix = exports.toISOString = exports.getFilename = exports.parseJSON = exports.getRes = exports.getReq = exports.getResRaw = exports.getReqRaw = void 0;
const tslib_1 = require("tslib");
const import_pkg_1 = require("../import-pkg");
const zlib = tslib_1.__importStar(require("../util/zlib"));
const STATUS_CODES = import_pkg_1.http.STATUS_CODES;
const CRLF = import_pkg_1.Buffer.from('\r\n');
const TYPE_RE = /(request|response)-length:/i;
let frameIndex = 100000;
const TYPES = ['whistle', 'Fiddler', 'har'];
function dechunkify(body) {
    const result = [];
    let index;
    while ((index = indexOfBuffer(body, CRLF)) > 0) {
        const size = parseInt(body.slice(0, index).toString(), 16) || 0;
        if (!size) {
            break;
        }
        index += 2;
        result.push(body.slice(index, (index += size)));
        body = body.slice(index + 2);
    }
    return result.length ? import_pkg_1.Buffer.concat(result) : body;
}
function getMethod(method) {
    if (typeof method !== 'string') {
        return 'GET';
    }
    return method.trim().toUpperCase() || 'GET';
}
function getHeadersRaw(headers, rawHeaderNames) {
    const result = [];
    if (headers) {
        rawHeaderNames = rawHeaderNames || {};
        Object.keys(headers).forEach(function (name) {
            const value = headers[name];
            const key = rawHeaderNames[name] || name;
            if (!Array.isArray(value)) {
                result.push(key + ': ' + value);
                return;
            }
            value.forEach(function (val) {
                result.push(key + ': ' + val);
            });
        });
    }
    return result;
}
function decodeRaw(headers, data) {
    const body = getBodyBuffer(data);
    const raw = import_pkg_1.Buffer.from(headers.join('\r\n') + '\r\n\r\n');
    return body ? import_pkg_1.Buffer.concat([raw, body]) : raw;
}
function removeEncodingFields(headers) {
    if (headers) {
        delete headers['content-encoding'];
        delete headers['transfer-encoding'];
    }
}
function getBodyBuffer(data) {
    if (data.base64) {
        try {
            return import_pkg_1.Buffer.from(data.base64 + '', 'base64');
        }
        catch (e) { }
        return import_pkg_1.Buffer.from(data.base64 + '');
    }
    if (data.body) {
        return import_pkg_1.Buffer.from(data.body + '');
    }
    return undefined;
}
function getReqRaw(req) {
    removeEncodingFields(req.headers);
    const headers = getHeadersRaw(req.headers, req.rawHeaderNames);
    const url = String(req.url || '').replace(/^ws/, 'http');
    headers.unshift([getMethod(req.method), url, 'HTTP/1.1'].join(' '));
    return decodeRaw(headers, req);
}
exports.getReqRaw = getReqRaw;
function getResRaw(res) {
    removeEncodingFields(res.headers);
    const headers = getHeadersRaw(res.headers, res.rawHeaderNames);
    const statusCode = res.statusCode === 'aborted' ? 502 : res.statusCode;
    const statusMessage = !statusCode
        ? ''
        : res.statusMessage || STATUS_CODES[statusCode] || 'unknown';
    headers.unshift(['HTTP/1.1', statusCode, statusMessage].join(' '));
    return decodeRaw(headers, res);
}
exports.getResRaw = getResRaw;
const BODY_SEP = import_pkg_1.Buffer.from('\r\n\r\n');
function getBodyOffset(raw) {
    const index = indexOfBuffer(raw, BODY_SEP);
    if (index !== -1) {
        return [index, index + 4];
    }
    return undefined;
}
function indexOfBuffer(buf, subBuf, start = 0) {
    if (buf.indexOf) {
        return buf.indexOf(subBuf, start);
    }
    const subLen = subBuf.length;
    if (subLen) {
        for (let i = start, len = buf.length - subLen; i <= len; i++) {
            let j = 0;
            for (; j < subLen; j++) {
                if (subBuf[j] !== buf[i + j]) {
                    break;
                }
            }
            if (j == subLen) {
                return i;
            }
        }
    }
    return -1;
}
function getBody(body, headers, callback) {
    if (body) {
        let chunked = headers['transfer-encoding'];
        if (typeof chunked === 'string') {
            chunked = chunked.trim().toLowerCase();
        }
        if (chunked === 'chunked') {
            body = dechunkify(body);
        }
    }
    zlib.unzip(headers['content-encoding'], body, function (err, result) {
        if (!err && result) {
            body = result;
        }
        return callback(body && body.toString('base64'));
    });
}
function parseRawData(raw, callback) {
    const offset = getBodyOffset(raw);
    let body = '';
    if (offset) {
        body = raw.slice(offset[1]);
        raw = raw.slice(0, offset[0]);
    }
    raw = raw.toString();
    raw = raw.trim().split(/\r\n?|\n/);
    const statusLine = raw.shift().split(/\s+/);
    const firstLine = statusLine.splice(0, 2);
    firstLine[2] = statusLine.join(' ');
    const headers = {};
    const rawHeaderNames = {};
    raw.forEach(function (line) {
        const index = line.indexOf(':');
        if (index === -1) {
            return;
        }
        const name = line.substring(0, index).trim();
        if (!name) {
            return;
        }
        const key = name.toLowerCase();
        let value = headers[key];
        const val = line.substring(index + 1).trim();
        if (value != null) {
            if (Array.isArray(value)) {
                value.push(val);
            }
            else {
                value = [value, val];
            }
        }
        else {
            value = val;
        }
        rawHeaderNames[key] = name;
        headers[key] = value;
    });
    getBody(body, headers, function (base64) {
        callback({
            firstLine: firstLine,
            headers: headers,
            size: base64 ? base64.length : 0,
            rawHeaderNames: rawHeaderNames,
            base64: base64
        });
    });
}
function getReq(raw, callback) {
    raw = parseRawData(raw, function (raw) {
        const method = raw.firstLine[0] || 'GET';
        callback(raw
            ? {
                method: method,
                httpVersion: '1.1',
                rawHeaderNames: raw.rawHeaderNames,
                url: raw.firstLine[1],
                headers: raw.headers,
                size: /^get$/i.test(method) ? 0 : raw.size,
                base64: raw.base64
            }
            : null);
    });
}
exports.getReq = getReq;
function getRes(raw, callback) {
    parseRawData(raw, function (raw) {
        callback(raw
            ? {
                statusCode: raw.firstLine[1],
                httpVersion: '1.1',
                rawHeaderNames: raw.rawHeaderNames,
                statusMessage: raw.firstLine[2],
                headers: raw.headers,
                size: raw.size,
                base64: raw.base64
            }
            : {});
    });
}
exports.getRes = getRes;
function parseJSON(str) {
    try {
        return JSON.parse(str);
    }
    catch (e) { }
}
exports.parseJSON = parseJSON;
function padding(num) {
    return num < 10 ? '0' + num : num;
}
function paddingMS(ms) {
    if (ms > 99) {
        return ms;
    }
    if (ms > 9) {
        return '0' + ms;
    }
    return '00' + ms;
}
function formatDate() {
    const date = new Date();
    const result = [];
    result.push(date.getFullYear());
    result.push(padding(date.getMonth() + 1));
    result.push(padding(date.getDate()));
    result.push(padding(date.getHours()));
    result.push(padding(date.getMinutes()));
    result.push(padding(date.getSeconds()));
    result.push(paddingMS(date.getMilliseconds()));
    return result.join('');
}
function getFilename(type, filename) {
    if (TYPES.indexOf(type) === -1) {
        type = 'whistle';
    }
    if (typeof filename !== 'string') {
        filename = '';
    }
    if (type === 'whistle') {
        if (filename) {
            if (!/\.(json|txt)$/i.test(filename)) {
                filename += '.txt';
            }
        }
        else {
            filename = 'whistle_' + formatDate() + '.txt';
        }
    }
    else if (type === 'har') {
        if (filename) {
            if (!/\.har$/i.test(filename)) {
                filename += '.har';
            }
        }
        else {
            filename = 'har_' + formatDate() + '.har';
        }
    }
    else {
        if (filename) {
            if (!/\.saz$/i.test(filename)) {
                filename += '.saz';
            }
        }
        else {
            filename = 'fiddler_' + formatDate() + '.saz';
        }
    }
    return filename;
}
exports.getFilename = getFilename;
const ONE_MINUTE = 60 * 1000;
function toISOString(time) {
    const date = new Date();
    let offet = -date.getTimezoneOffset();
    time += offet * ONE_MINUTE;
    offet /= 60;
    time = time >= 0 ? new Date(time) : new Date();
    return (time.toISOString().slice(0, -1) +
        '0000' +
        (offet >= 0 ? '+' : '-') +
        padding(Math.abs(offet)) +
        ':00');
}
exports.toISOString = toISOString;
function removeIPV6Prefix(ip) {
    if (typeof ip !== 'string') {
        return '';
    }
    return ip.indexOf('::ffff:') === 0 ? ip.substring(7) : ip;
}
exports.removeIPV6Prefix = removeIPV6Prefix;
function getIndex() {
    if (frameIndex > 10000000) {
        frameIndex = 100000;
    }
    return ++frameIndex;
}
function noop() { }
function resolveFrames(res, frames, callback) {
    const len = frames.length;
    const result = [];
    if (!len) {
        return callback(result);
    }
    res.headers = res.headers || {};
    let receiver = import_pkg_1.wsParser.getReceiver(res);
    const execCallback = function () {
        if (receiver) {
            receiver.onData = noop;
            receiver = null;
            callback(result);
        }
    };
    let index = 0;
    receiver.onerror = execCallback;
    receiver.onclose = execCallback;
    receiver.onData = function (chunk, opts) {
        const frame = frames[index];
        ++index;
        if (frame) {
            result.push({
                frameId: frame.frameId,
                isClient: frame.type === 'request',
                mask: opts.mask,
                base64: chunk.toString('base64'),
                compressed: opts.compressed,
                length: opts.length,
                opcode: opts.opcode
            });
        }
        if (!frame || len === index) {
            setImmediate(execCallback);
        }
    };
    setTimeout(execCallback, 3000);
    frames.forEach((frame) => {
        receiver.add(frame.bin);
    });
}
function parseFrames(res, content, callback) {
    let end = content.indexOf(CRLF, 0);
    let start = 2;
    const frames = [];
    while (end !== -1) {
        let line = content.slice(start, end).toString();
        if (TYPE_RE.test(line)) {
            const frame = { type: RegExp.$1.toLowerCase() };
            frame.length = line.substring(line.indexOf(':') + 1).trim();
            start = content.indexOf(CRLF, start + 90);
            if (start === -1) {
                break;
            }
            start += 2;
            end = content.indexOf(CRLF, start);
            if (end === -1) {
                break;
            }
            line = content.slice(start, end).toString();
            const time = new Date(line.substring(line.indexOf(':') + 1).trim() || 0).getTime();
            frame.frameId = time + '-' + getIndex();
            start = end + 4;
            end = content.indexOf(CRLF, start);
            if (end === -1) {
                break;
            }
            frame.bin = content.slice(start, end);
            frames.push(frame);
        }
        start = end + 2;
        end = content.indexOf(CRLF, start);
    }
    resolveFrames(res, frames, callback);
}
exports.parseFrames = parseFrames;
