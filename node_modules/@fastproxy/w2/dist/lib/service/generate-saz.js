"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const import_pkg_1 = require("../import-pkg");
const util = tslib_1.__importStar(require("./util"));
const fiddlerAssets = import_pkg_1.path.join(__dirname, '../../assets/fiddler/');
const fiddlerMeta = import_pkg_1.fs.readFileSync(fiddlerAssets + 'meta.xml', 'utf8');
function filterSessions(sessions) {
    return sessions.filter(function (item) {
        if (!item || !item.url || !item.req || !(item.startTime >= 0)) {
            return false;
        }
        return true;
    });
}
function renderTpl(tpl, locals) {
    locals = getMetaData(locals);
    Object.keys(locals).forEach(function (name) {
        tpl = tpl.replace('${' + name + '}', locals[name]);
    });
    return tpl;
}
function getMetaData(item) {
    const meta = {
        SID: item.index + 1
    };
    [
        'ClientConnected',
        'ClientDoneRequest',
        'ServerGotRequest',
        'ServerBeginResponse',
        'ServerDoneResponse',
        'ClientBeginResponse',
        'ClientDoneResponse'
    ].forEach(function (name) {
        meta[name] = '0001-01-01T00:00:00';
    });
    ['GatewayTime', 'DNSTime', 'TCPConnectTime'].forEach(function (name) {
        meta[name] = 0;
    });
    ['ttfb', 'ttlb', 'transfer-size', 'clientip', 'hostip'].forEach(function (name) {
        meta[name] = 0;
    });
    meta.ClientConnected = util.toISOString(item.startTime);
    if (item.dnsTime >= item.startTime) {
        meta.DNSTime = item.dnsTime - item.startTime;
    }
    if (item.requestTime > 0) {
        meta.ClientDoneRequest =
            meta.ServerGotRequest =
                meta.ServerBeginResponse =
                    util.toISOString(item.requestTime);
    }
    if (item.responseTime > 0) {
        meta.ClientBeginResponse = util.toISOString(item.responseTime);
        meta.ttfb = item.responseTime - item.startTime;
    }
    if (item.endTime > 0) {
        meta.ServerDoneResponse = meta.ClientDoneResponse = util.toISOString(item.endTime);
        meta.ttlb = item.endTime - item.startTime;
    }
    const req = item.req || {};
    const res = item.res || {};
    if (res.size > 0) {
        meta['transfer-size'] = res.size;
    }
    meta.clientip = req.ip || '127.0.0.1';
    meta.hostip = res.ip || '127.0.0.1';
    meta.clientport = req.port || 0;
    meta.serverport = res.port || 0;
    return meta;
}
function getFiddler2Meta(item) {
    return renderTpl(fiddlerMeta, item);
}
function default_1(body) {
    let sessions = util.parseJSON(body.sessions);
    if (!Array.isArray(sessions)) {
        return '';
    }
    sessions = filterSessions(sessions);
    let index = 0;
    const getName = function () {
        const name = String(index);
        ++index;
        const paddingCount = 4 - name.length;
        return paddingCount <= 0
            ? name
            : new Array(paddingCount + 1).join('0') + name;
    };
    const zip = new import_pkg_1.Zip();
    sessions.map(function (item, index) {
        item.req.url = item.url;
        const req = util.getReqRaw(item.req);
        const res = !item.res || item.res.statusCode == null
            ? import_pkg_1.Buffer.from('')
            : util.getResRaw(item.res);
        const name = getName();
        item.index = index;
        zip.add('raw/' + name + '_c.txt', req);
        zip.add('raw/' + name + '_m.xml', import_pkg_1.Buffer.from(getFiddler2Meta(item)));
        zip.add('raw/' + name + '_s.txt', res);
        zip.add('raw/' + name + '_whistle.json', import_pkg_1.Buffer.from(JSON.stringify({
            version: item.version,
            nodeVersion: item.nodeVersion,
            realUrl: item.realUrl,
            fwdHost: item.fwdHost,
            rules: item.rules,
            frames: item.frames,
            useHttp: item.useHttp,
            httpsTime: item.httpsTime,
            useH2: item.useH2,
            mark: item.mark,
            sniPlugin: item.sniPlugin,
            trailers: item.res && item.res.trailers,
            rawTrailerNames: item.res && item.res.rawTrailerNames,
            times: {
                startTime: item.startTime,
                dnsTime: item.dnsTime,
                requestTime: item.requestTime,
                responseTime: item.responseTime,
                endTime: item.endTime
            }
        })));
    });
    return zip.toBuffer();
}
exports.default = default_1;
