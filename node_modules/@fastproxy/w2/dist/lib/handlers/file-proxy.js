"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fileProxy = void 0;
const tslib_1 = require("tslib");
const import_pkg_1 = require("../import-pkg");
const util = tslib_1.__importStar(require("../util"));
const protoMgr = tslib_1.__importStar(require("../rules/protocols"));
const plugins_1 = require("../plugins");
const config_1 = tslib_1.__importDefault(require("../config"));
const CRLF_RE = /\r\n|\r|\n/g;
const RAW_FILE_RE = /rawfile/;
const HEADERS_SEP_RE = /(\r?\n(?:\r\n|\r|\n)|\r\r\n?)/;
const MAX_HEADERS_SIZE = 256 * 1024;
const TPL_RE = /(?:dust|tpl|jsonp):$/;
function isRawFileProtocol(protocol) {
    return RAW_FILE_RE.test(protocol);
}
function readFiles(files, callback) {
    let file = files.shift();
    const execCallback = function (err, stat) {
        if (!err && stat && stat.isFile()) {
            callback(null, file, stat.size);
        }
        else if (file && file.pluginName) {
            plugins_1.pluginMgr.requestBin(file, function (buffer, err, res) {
                file = file.originalKey;
                callback(err, file, buffer ? buffer.length : 0, buffer, res);
            });
        }
        else if (files.length) {
            readFiles(files, callback);
        }
        else {
            callback(err || new Error('Not found file ' + file), file);
        }
    };
    !file || typeof file !== 'string'
        ? execCallback()
        : import_pkg_1.fs.stat(file, execCallback);
}
function parseRes(str, rawHeaderNames, fromValue) {
    if (!str) {
        return {
            statusCode: 200,
            headers: {}
        };
    }
    let headers = str.split(CRLF_RE);
    const statusLine = headers.shift().trim().split(/\s+/g);
    headers = util.parseHeaders(headers, rawHeaderNames);
    if (fromValue) {
        delete headers['content-encoding'];
    }
    return {
        statusCode: statusLine[1] || 200,
        headers: headers
    };
}
function addLength(reader, length) {
    reader.headers['content-length'] = length;
}
function getRawResByValue(body) {
    let headers;
    if (HEADERS_SEP_RE.test(body)) {
        const crlfStr = RegExp.$1;
        const index = body.indexOf(crlfStr);
        headers = body.substring(0, index);
        body = body.substring(index + crlfStr.length);
    }
    const rawHeaderNames = {};
    const reader = parseRes(headers, rawHeaderNames, true);
    reader.rawHeaderNames = rawHeaderNames;
    reader.body = body;
    addLength(reader, body ? import_pkg_1.Buffer.byteLength(body) : 0);
    return reader;
}
function getRawResByPath(protocol, path, req, size, callback, body) {
    const isRawFile = isRawFileProtocol(protocol);
    const range = isRawFile ? undefined : util.parseRange(req, req.localFileSize);
    let reader;
    if (body == null) {
        reader = import_pkg_1.fs.createReadStream(path, range);
    }
    else {
        reader = new import_pkg_1.PassThrough();
        if (!body || !range) {
            reader.end(body);
        }
        else {
            reader.end(body.slice(range.start, range.end + 1));
        }
    }
    const rawHeaderNames = {};
    reader.rawHeaderNames = rawHeaderNames;
    if (isRawFile) {
        let buffer;
        const response = function (err, crlf) {
            reader.removeAllListeners();
            reader.on('error', util.noop);
            const stream = reader;
            reader = new import_pkg_1.PassThrough();
            if (err) {
                const stack = util.getErrorStack(err);
                reader.statusCode = 500;
                reader.push(stack);
                reader.push(null);
                size = import_pkg_1.Buffer.byteLength(stack);
            }
            else {
                if (crlf) {
                    crlf = util.toBuffer(crlf);
                    const index = util.indexOfList(buffer, crlf);
                    if (index != -1) {
                        (0, import_pkg_1.extend)(reader, parseRes(buffer.slice(0, index) + '', rawHeaderNames));
                        const headerLen = index + crlf.length;
                        size -= headerLen;
                        buffer = buffer.slice(headerLen);
                    }
                }
                buffer && reader.push(buffer);
                stream.on('error', function (err) {
                    reader.emit('error', err);
                });
                stream.pipe(reader);
            }
            callback(reader, null, size);
        };
        reader.on('data', function (data) {
            buffer = buffer ? import_pkg_1.Buffer.concat([buffer, data]) : data;
            if (HEADERS_SEP_RE.test(buffer + '')) {
                response(null, RegExp.$1);
            }
            else if (buffer.length > MAX_HEADERS_SIZE) {
                response();
            }
        });
        reader.on('error', response);
        reader.on('end', response);
    }
    else {
        callback(reader, range, size);
    }
}
function addRangeHeaders(res, range, size) {
    if (!range) {
        return;
    }
    const headers = res.headers;
    headers['content-range'] =
        'bytes ' + (range.start + '-' + range.end) + '/' + size;
    headers['accept-ranges'] = 'bytes';
    headers['content-length'] = range.end - range.start + 1;
    res.statusCode = 206;
}
function fileProxy(req, res, next) {
    const options = req.options;
    const protocol = options && options.protocol;
    if (!protoMgr.isFileProxy(protocol)) {
        return next();
    }
    const isTpl = TPL_RE.test(protocol);
    const defaultType = import_pkg_1.mime.lookup(req.fullUrl.replace(/[?#].*$/, ''), 'text/html');
    const rules = req.rules;
    const rule = rules.rule;
    delete rules.proxy;
    delete rules.host;
    if (rule.value) {
        let body = util.removeProtocol(rule.value, true);
        const isRawFile = isRawFileProtocol(protocol);
        let reader = isRawFile
            ? getRawResByValue(body)
            : {
                statusCode: 200,
                body: body,
                headers: {
                    'content-type': (rule.key ? import_pkg_1.mime.lookup(rule.key, defaultType) : defaultType) +
                        '; charset=utf-8'
                }
            };
        if (isTpl) {
            reader.realUrl = rule.matcher;
            render(reader);
        }
        else {
            if (!isRawFile) {
                const size = import_pkg_1.Buffer.byteLength(body);
                const range = util.parseRange(req, size);
                if (range) {
                    body = import_pkg_1.Buffer.from(body);
                    reader.body = body.slice(range.start, range.end + 1);
                    addRangeHeaders(reader, range, size);
                }
                else {
                    addLength(reader, size);
                }
            }
            reader = util.wrapResponse(reader);
            reader.realUrl = rule.matcher;
            res.response(reader);
        }
        return;
    }
    readFiles(util.getRuleFiles(rule, req), function (err, path, size, buffer, svrRes) {
        if (err) {
            if (/^x/.test(protocol)) {
                const fullUrl = /^xs/.test(protocol)
                    ? req.fullUrl.replace(/^http:/, 'https:')
                    : req.fullUrl;
                (0, import_pkg_1.extend)(options, util.parseUrl(fullUrl));
                next();
            }
            else {
                const is502 = err.code > 0 && err.code != 404;
                const notFound = util.wrapResponse({
                    statusCode: is502 ? 502 : 404,
                    body: is502
                        ? err.message
                        : 'Not found file <strong>' + path + '</strong>',
                    headers: {
                        'content-type': 'text/html; charset=utf-8'
                    }
                });
                notFound.realUrl = rule.matcher;
                res.response(notFound);
            }
            return;
        }
        const type = buffer != null &&
            svrRes &&
            svrRes.headers &&
            svrRes.headers['x-whistle-response-type'];
        const headers = {
            server: config_1.default.name,
            'content-type': type || import_pkg_1.mime.lookup(path, defaultType) + '; charset=utf-8'
        };
        if (isTpl) {
            const reader = {
                statusCode: 200,
                realUrl: path,
                headers: headers
            };
            if (buffer != null) {
                reader.body = buffer + '';
                render(reader);
            }
            else {
                import_pkg_1.fs.readFile(path, { encoding: 'utf8' }, function (err, data) {
                    if (err) {
                        return util.emitError(req, err);
                    }
                    reader.body = data;
                    render(reader);
                });
            }
        }
        else {
            req.localFileSize = size;
            getRawResByPath(protocol, path, req, size, function (reader, range, realSize) {
                reader.realUrl = path;
                reader.statusCode = reader.statusCode || 200;
                reader.headers = reader.headers || headers;
                addRangeHeaders(reader, range, size);
                !range && addLength(reader, realSize);
                res.response(reader);
            }, buffer);
        }
    });
    function render(reader) {
        if (reader.body) {
            const data = import_pkg_1.qs.parse(util.getQueryString(req.fullUrl));
            if (Object.keys(data).length) {
                reader.body = reader.body.replace(/\$?\{([\w\-$]+)\}/g, function (all, matched) {
                    const value = data[matched];
                    if (value === undefined) {
                        return all;
                    }
                    return util.getQueryValue(value);
                });
            }
            addLength(reader, import_pkg_1.Buffer.byteLength(reader.body));
        }
        else {
            addLength(reader, 0);
        }
        const realUrl = reader.realUrl;
        reader = util.wrapResponse(reader);
        reader.realUrl = realUrl;
        res.response(reader);
    }
}
exports.fileProxy = fileProxy;
