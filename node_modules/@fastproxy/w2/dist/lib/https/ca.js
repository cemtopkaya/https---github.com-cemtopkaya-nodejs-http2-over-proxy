"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.uploadCerts = exports.removeCert = exports.hasInvalidCerts = exports.getSNIServer = exports.getHttp2Server = exports.serverAgent = exports.getCustomCertsFiles = exports.getCustomCertsInfo = exports.getRootCA = exports.SNICallback = exports.getRootCAFile = exports.createRootCA = exports.createCertificate = exports.hasCustomCerts = exports.existsCustomCert = exports.getDomain = exports.remoteCerts = exports.CUSTOM_CERTS_DIR = exports.createSecureContext = void 0;
const tslib_1 = require("tslib");
const import_pkg_1 = require("../import-pkg");
const util = tslib_1.__importStar(require("../util"));
const config_1 = tslib_1.__importDefault(require("../config"));
const h2 = tslib_1.__importStar(require("./h2"));
exports.createSecureContext = import_pkg_1.tls.createSecureContext || import_pkg_1.crypto.createCredentials;
const pki = import_pkg_1.forge.pki;
const workerIndex = util.workerIndex;
const CUR_VERSION = process.version;
const requiredVersion = parseInt(CUR_VERSION.slice(1), 10) >= 6;
const HTTPS_DIR = mkdir(import_pkg_1.path.join(config_1.default.getDataDir(), 'certs'));
const ROOT_NEW_KEY_FILE = import_pkg_1.path.join(HTTPS_DIR, 'root_new.key');
const ROOT_NEW_CRT_FILE = import_pkg_1.path.join(HTTPS_DIR, 'root_new.crt');
exports.CUSTOM_CERTS_DIR = config_1.default.disableCustomCerts
    ? null
    : config_1.default.CUSTOM_CERTS_DIR;
const useNewKey = import_pkg_1.fs.existsSync(ROOT_NEW_KEY_FILE) && import_pkg_1.fs.existsSync(ROOT_NEW_CRT_FILE);
let ROOT_KEY_FILE = useNewKey
    ? ROOT_NEW_KEY_FILE
    : import_pkg_1.path.join(HTTPS_DIR, 'root.key');
let ROOT_CRT_FILE = useNewKey
    ? ROOT_NEW_CRT_FILE
    : import_pkg_1.path.join(HTTPS_DIR, 'root.crt');
const customCertDir = config_1.default.certDir;
let customPairs = {};
let customCertsInfo = {};
let customCertsFiles = {};
let allCustomCerts = {};
let customCertCount = 0;
const cachePairs = new import_pkg_1.LRU({ max: 5120 });
const certsCache = new import_pkg_1.LRU({ max: 256 });
exports.remoteCerts = new import_pkg_1.LRU({ max: 1280 });
const ILEGAL_CHAR_RE = /[^a-z\d-]/i;
const RANDOM_SERIAL = '.' + Date.now() + '.' + Math.floor(Math.random() * 10000);
const CLEAR_CERTS_INTERVAL = 1000 * 60 * 60 * 24 * 20;
const MAX_INNTERFAL = 18;
const PORT_RE = /:\d*$/;
let customRoot;
let ROOT_KEY;
let ROOT_CRT;
let rootKey;
let rootCrt;
// When delay is larger than 2147483647 or less than 1, the delay will be set to 1. Non-integer delays are truncated to an integer.
let intervalCount = 0;
const timer = setInterval(function () {
    if (++intervalCount >= MAX_INNTERFAL) {
        intervalCount = 0;
        cachePairs.reset();
        certsCache.reset();
    }
}, CLEAR_CERTS_INTERVAL);
if (timer && typeof timer.unref === 'function') {
    timer.unref();
}
if (!useNewKey && requiredVersion && !checkCertificate()) {
    try {
        import_pkg_1.fs.unlinkSync(ROOT_KEY_FILE);
        import_pkg_1.fs.unlinkSync(ROOT_CRT_FILE);
    }
    catch (e) { }
}
function mkdir(path) {
    !import_pkg_1.fs.existsSync(path) && import_pkg_1.fs.mkdirSync(path);
    return path;
}
function checkCertificate() {
    try {
        const crt = pki.certificateFromPem(import_pkg_1.fs.readFileSync(ROOT_CRT_FILE).toString());
        if (crt.publicKey.n.toString(2).length < 2048) {
            return false;
        }
        return /^whistle\.\d+$/.test(getCommonName(crt));
    }
    catch (e) { }
    return true;
}
function getCommonName(crt) {
    const attrs = crt.issuer && crt.issuer.attributes;
    if (Array.isArray(attrs)) {
        for (let i = 0, len = attrs.length; i < len; i++) {
            const attr = attrs[i];
            if (attr && attr.name === 'commonName') {
                return attr.value;
            }
        }
    }
    return '';
}
function getDomain(hostname) {
    if (getCacheCert(hostname) || import_pkg_1.net.isIP(hostname)) {
        return hostname;
    }
    const list = hostname.split('.');
    const prefix = list[0];
    list[0] = '*';
    const wildDomain = list.join('.');
    if (getCacheCert(wildDomain)) {
        return wildDomain;
    }
    const len = list.length;
    if (len < 3) {
        return hostname;
    }
    if (len > 3 ||
        ILEGAL_CHAR_RE.test(prefix) ||
        list[1].length > 3 ||
        list[2] === 'com' ||
        list[1] === 'url') {
        // For tencent cdn
        return wildDomain;
    }
    return hostname;
}
exports.getDomain = getDomain;
const existsCustomCert = function (hostname) {
    if (!customCertCount) {
        return false;
    }
    hostname = hostname.replace(PORT_RE, '');
    const cert = customPairs[hostname];
    if (cert) {
        return true;
    }
    hostname = hostname.split('.');
    hostname[0] = '*';
    return customPairs[hostname.join('.')];
};
exports.existsCustomCert = existsCustomCert;
const hasCustomCerts = function () {
    return customCertCount;
};
exports.hasCustomCerts = hasCustomCerts;
function getCacheCert(hostname) {
    return (customPairs[hostname] ||
        cachePairs.get(hostname) ||
        certsCache.get(hostname));
}
let curIndex = 0;
function getIndex() {
    ++curIndex;
    if (curIndex < 10) {
        return '0' + curIndex;
    }
    if (curIndex > 99) {
        curIndex = 0;
        return '00';
    }
    return curIndex;
}
function createSelfCert(hostname) {
    const serialNumber = import_pkg_1.crypto
        .createHash('sha1')
        .update(hostname + RANDOM_SERIAL, 'binary')
        .digest('hex') +
        getIndex() +
        workerIndex;
    const cert = createCert(pki.setRsaPublicKey(ROOT_KEY.n, ROOT_KEY.e), serialNumber, true);
    cert.setSubject([
        {
            name: 'commonName',
            value: hostname
        }
    ]);
    cert.setIssuer(ROOT_CRT.subject.attributes);
    cert.setExtensions([
        {
            name: 'subjectAltName',
            altNames: [
                import_pkg_1.net.isIP(hostname)
                    ? {
                        type: 7,
                        ip: hostname
                    }
                    : {
                        type: 2,
                        value: hostname
                    }
            ]
        }
    ]);
    cert.sign(ROOT_KEY, import_pkg_1.forge.md.sha256.create());
    return {
        key: pki.privateKeyToPem(ROOT_KEY),
        cert: pki.certificateToPem(cert)
    };
}
const createCertificate = function (hostname) {
    hostname = getDomain(hostname);
    let cert = cachePairs.get(hostname); // 确保使用自己生成的证书，防止把用户证书下载出去
    if (!cert) {
        cert = createSelfCert(hostname);
        certsCache.set(hostname, cert);
    }
    return cert;
};
exports.createCertificate = createCertificate;
function parseCert(cert) {
    const pem = pki.certificateFromPem(cert.cert);
    const altNames = getAltNames(pem.extensions);
    if (!altNames || !altNames.length) {
        return;
    }
    return { cert: cert, altNames: altNames, validity: pem.validity };
}
function parseAllCustomCerts() {
    const pairs = {};
    const certsInfo = {};
    const certFiles = {};
    const keys = Object.keys(allCustomCerts).sort(function (key1, key2) {
        return util.compare(allCustomCerts[key1].cert.mtime, allCustomCerts[key2].cert.mtime);
    });
    keys.forEach(function (filename) {
        const info = allCustomCerts[filename];
        const cert = info.cert;
        const mtime = cert.mtime;
        const validity = info.validity;
        const altNames = info.altNames;
        const dnsName = [];
        altNames.forEach(function (item) {
            if ((item.type === 2 || item.type === 7) && !pairs[item.value]) {
                const preCert = customPairs[item.value];
                if (preCert && preCert.key === cert.key && preCert.cert === cert.cert) {
                    if (preCert.mtime < mtime) {
                        preCert.mtime = mtime;
                    }
                    pairs[item.value] = preCert;
                }
                else {
                    pairs[item.value] = cert;
                }
                dnsName.push(item.value);
                certsInfo[item.value] = (0, import_pkg_1.extend)({ filename: filename, mtime: mtime, domain: item.value }, validity);
            }
        });
        if (dnsName.length) {
            certFiles[filename] = (0, import_pkg_1.extend)({ mtime: mtime, dir: cert.dir, dnsName: dnsName.join(', ') }, validity);
        }
    });
    customPairs = pairs;
    customCertsInfo = certsInfo;
    customCertsFiles = certFiles;
    customCertCount = Object.keys(customPairs).length;
    checkExpired();
}
function loadCustomCerts(certDir, isCustom) {
    if (!certDir) {
        return;
    }
    const certs = {};
    try {
        import_pkg_1.fs.readdirSync(certDir).forEach(function (name) {
            if (!/^(.+)\.(crt|key)$/.test(name)) {
                return;
            }
            const filename = RegExp.$1;
            let suffix = RegExp.$2;
            const cert = (certs[filename] = certs[filename] || {});
            if (suffix === 'crt') {
                suffix = 'cert';
            }
            try {
                const filePath = import_pkg_1.path.join(certDir, name);
                cert.dir = certDir;
                cert[suffix] = import_pkg_1.fs.readFileSync(filePath, { encoding: 'utf8' });
                const mtime = import_pkg_1.fs.statSync(filePath).mtime.getTime();
                if (cert.mtime == null || cert.mtime < mtime) {
                    cert.mtime = mtime;
                }
            }
            catch (e) { }
        });
    }
    catch (e) { }
    const rootCA = certs.root;
    delete certs.root;
    if (rootCA && rootCA.key && rootCA.cert && !customRoot) {
        customRoot = rootCA;
        ROOT_KEY_FILE = import_pkg_1.path.join(certDir, 'root.key');
        ROOT_CRT_FILE = import_pkg_1.path.join(certDir, 'root.crt');
    }
    Object.keys(certs).filter(function (key) {
        let cert = certs[key];
        if (cert && cert.mtime != null && cert.key && cert.cert) {
            try {
                cert = parseCert(cert);
                if (cert) {
                    allCustomCerts[isCustom ? 'z/' + key : key] = cert;
                }
            }
            catch (e) { }
        }
    });
}
function getAltNames(exts) {
    for (let i = 0, len = exts.length; i < len; i++) {
        const item = exts[i];
        if (item.name === 'subjectAltName') {
            return Array.isArray(item.altNames) && item.altNames.filter(util.noop);
        }
    }
}
function createRootCAFn() {
    allCustomCerts = {};
    loadCustomCerts(customCertDir, true);
    loadCustomCerts(exports.CUSTOM_CERTS_DIR);
    parseAllCustomCerts();
    if (ROOT_KEY && ROOT_CRT) {
        return;
    }
    try {
        ROOT_KEY = import_pkg_1.fs.readFileSync(ROOT_KEY_FILE);
        ROOT_CRT = import_pkg_1.fs.readFileSync(ROOT_CRT_FILE);
        rootKey = ROOT_KEY.toString();
        rootCrt = ROOT_CRT.toString();
    }
    catch (e) {
        ROOT_KEY = ROOT_CRT = null;
    }
    if (ROOT_KEY && ROOT_CRT && ROOT_KEY.length && ROOT_CRT.length) {
        ROOT_KEY = pki.privateKeyFromPem(ROOT_KEY);
        ROOT_CRT = pki.certificateFromPem(ROOT_CRT);
        if (customRoot) {
            customCertsFiles.root = (0, import_pkg_1.extend)({
                mtime: customRoot.mtime,
                dir: customRoot.dir,
                dnsName: ''
            }, ROOT_CRT.validity);
        }
        try {
            const altNames = getAltNames(ROOT_CRT.extensions);
            const dnsName = [];
            altNames.forEach(function (item) {
                if ((item.type === 2 || item.type === 7) &&
                    dnsName.indexOf(item.value) === -1) {
                    dnsName.push(item.value);
                }
            });
            customCertsFiles.root.dnsName = dnsName.join(', ');
        }
        catch (e) { }
    }
    else {
        const cert = createCACertFn();
        ROOT_CRT = cert.cert;
        ROOT_KEY = cert.key;
        rootKey = pki.privateKeyToPem(ROOT_KEY).toString();
        rootCrt = pki.certificateToPem(ROOT_CRT).toString();
        import_pkg_1.fs.writeFileSync(ROOT_KEY_FILE, rootKey);
        import_pkg_1.fs.writeFileSync(ROOT_CRT_FILE, rootCrt);
    }
}
function getRandom() {
    const random = Math.floor(Math.random() * 1000);
    if (random < 10) {
        return '00' + random;
    }
    if (random < 100) {
        return '0' + random;
    }
    return '' + random;
}
function createCACertFn(opts = {}) {
    const keys = pki.rsa.generateKeyPair(requiredVersion ? 2048 : 1024);
    const cert = createCert(keys.publicKey);
    const now = Date.now() + getRandom();
    const attrs = [
        {
            name: 'commonName',
            value: opts.commonname || opts.commonName || 'whistle.' + now
        },
        {
            name: 'countryName',
            value: opts.countryname || opts.countryName || 'CN'
        },
        {
            shortName: 'ST',
            value: opts.st || opts.ST || 'ZJ'
        },
        {
            name: 'localityName',
            value: opts.localityname || opts.localityName || 'HZ'
        },
        {
            name: 'organizationName',
            value: opts.organizationname || opts.organizationName || now + '.wproxy.org'
        },
        {
            shortName: 'OU',
            value: opts.ou || opts.OU || 'wproxy.org'
        }
    ];
    cert.setSubject(attrs);
    cert.setIssuer(attrs);
    cert.setExtensions([
        {
            name: 'basicConstraints',
            cA: true
        },
        {
            name: 'keyUsage',
            keyCertSign: true,
            digitalSignature: true,
            nonRepudiation: true,
            keyEncipherment: true,
            dataEncipherment: true
        },
        {
            name: 'extKeyUsage',
            serverAuth: true,
            clientAuth: true,
            codeSigning: true,
            emailProtection: true,
            timeStamping: true
        },
        {
            name: 'nsCertType',
            client: true,
            server: true,
            email: true,
            objsign: true,
            sslCA: true,
            emailCA: true,
            objCA: true
        }
    ]);
    cert.sign(keys.privateKey, import_pkg_1.forge.md.sha256.create());
    return {
        key: keys.privateKey,
        cert: cert
    };
}
const createRootCA = function (opts) {
    const cert = createCACertFn(opts);
    cert.key = pki.privateKeyToPem(cert.key).toString();
    cert.cert = pki.certificateToPem(cert.cert).toString();
    return cert;
};
exports.createRootCA = createRootCA;
function createCert(publicKey, serialNumber, isShortPeriod) {
    const cert = pki.createCertificate();
    cert.publicKey = publicKey;
    cert.serialNumber = serialNumber || '01';
    const curYear = new Date().getFullYear();
    cert.validity.notBefore = new Date();
    cert.validity.notAfter = new Date();
    cert.validity.notBefore.setFullYear(curYear - 1);
    // https://chromium.googlesource.com/chromium/src/+/refs/heads/master/net/cert/cert_verify_proc.cc#900
    cert.validity.notAfter.setFullYear(curYear + (isShortPeriod ? 1 : 10));
    return cert;
}
function getRootCAFile() {
    return ROOT_CRT_FILE;
}
exports.getRootCAFile = getRootCAFile;
createRootCAFn(); // 启动生成ca
function getOrCreateCert(servername) {
    const requestCert = servername[0] === ':';
    if (requestCert) {
        servername = servername.substring(1);
    }
    let cert = exports.remoteCerts.get(servername);
    if (!cert) {
        servername = getDomain(servername);
        cert = getCacheCert(servername);
        if (!cert) {
            cert = createSelfCert(servername);
            cachePairs.set(servername, cert);
        }
    }
    return requestCert
        ? (0, import_pkg_1.extend)({
            requestCert: true,
            rejectUnauthorized: false
        }, cert)
        : cert;
}
import_pkg_1.hagent.serverAgent.createCertificate = getOrCreateCert;
const getHttp2ServerVar = import_pkg_1.hagent.create(h2.getHttpServer, 42900);
const getHttpsServer = import_pkg_1.hagent.create(h2.getServer, 43900);
const cbs = {};
const ports = {};
const TIMEOUT = 6000;
const SNICallback = function (servername, cb) {
    const options = getOrCreateCert(servername);
    if (!options._ctx) {
        try {
            options._ctx = (0, exports.createSecureContext)(options);
        }
        catch (e) { }
    }
    cb(null, options._ctx);
};
exports.SNICallback = SNICallback;
const getRootCA = function () {
    return {
        key: rootKey,
        cert: rootCrt
    };
};
exports.getRootCA = getRootCA;
const getCustomCertsInfo = function () {
    return customCertsInfo;
};
exports.getCustomCertsInfo = getCustomCertsInfo;
const getCustomCertsFiles = function () {
    return customCertsFiles;
};
exports.getCustomCertsFiles = getCustomCertsFiles;
exports.serverAgent = import_pkg_1.hagent.serverAgent;
function addCallback(name, callback) {
    let cbList = cbs[name];
    if (!cbList) {
        cbList = [];
        cbs[name] = cbList;
    }
    cbList.push(callback);
    return cbList;
}
function createServer(name, cbList, listener, options) {
    const removeServer = function () {
        ports[name] = null;
        try {
            this.close();
        }
        catch (e) { } //重复关闭会导致异常
    };
    ports[name] = false; // pending
    const getServer = options ? getHttpsServer : getHttp2ServerVar;
    getServer(options, listener, function (server, port) {
        server.on('error', removeServer);
        const timeout = setTimeout(removeServer, TIMEOUT);
        const clearup = function () {
            clearTimeout(timeout);
        };
        if (options) {
            server.once('tlsClientError', clearup);
            server.once('secureConnection', clearup);
        }
        else {
            server.once('connection', clearup);
        }
        ports[name] = port;
        cbList.forEach(function (cb) {
            cb(port);
        });
        cbs[name] = [];
    });
}
const getHttp2Server = function (listener, callback) {
    const name = 'httpH2';
    const curPort = ports[name];
    if (curPort) {
        return callback(curPort);
    }
    const cbList = addCallback(name, callback);
    if (curPort === false) {
        return;
    }
    createServer(name, cbList, listener);
};
exports.getHttp2Server = getHttp2Server;
const getSNIServer = function (listener, callback, disableH2, requestCert) {
    const enableH2 = config_1.default.enableH2 && !disableH2;
    const name = (enableH2 ? 'h2Sni' : 'sni') + (requestCert ? 'WithCert' : '');
    const curPort = ports[name];
    if (curPort) {
        return callback(curPort);
    }
    const cbList = addCallback(name, callback);
    if (curPort === false) {
        return;
    }
    let options = { SNICallback: exports.SNICallback };
    options.allowHTTP1 = enableH2; // 是否启用http2
    if (requestCert) {
        options = (0, import_pkg_1.extend)({
            requestCert: true,
            rejectUnauthorized: false
        }, options);
    }
    createServer(name, cbList, listener, options);
};
exports.getSNIServer = getSNIServer;
var checkTimer = undefined;
exports.hasInvalidCerts = false;
function checkExpired() {
    clearTimeout(checkTimer);
    const now = Date.now();
    const files = Object.keys(customCertsFiles);
    exports.hasInvalidCerts = false;
    for (let i = 0, len = files.length; i < len; i++) {
        const file = customCertsFiles[files[i]];
        try {
            const startDate = new Date(file.notBefore);
            const endDate = new Date(file.notAfter);
            if (startDate.getTime() > now) {
                exports.hasInvalidCerts = true;
                return;
            }
            else if (endDate.getTime() < now) {
                exports.hasInvalidCerts = true;
                return;
            }
        }
        catch (e) { }
    }
    checkTimer = setTimeout(checkExpired, 600000);
}
function removeFile(filename) {
    import_pkg_1.fs.unlink(filename, function (err) {
        err && import_pkg_1.fs.unlink(filename, util.noop);
    });
}
function writeFile(filename, ctn, callback) {
    import_pkg_1.fs.writeFile(filename, ctn, function (err) {
        if (!err) {
            return callback();
        }
        import_pkg_1.fs.writeFile(filename, ctn, callback);
    });
}
// 异步重试，出错重试即可
function removeCertFile(filename) {
    removeFile(import_pkg_1.path.join(exports.CUSTOM_CERTS_DIR, filename + '.key'));
    removeFile(import_pkg_1.path.join(exports.CUSTOM_CERTS_DIR, filename + '.crt'));
}
// 异步写入，出错重试即可
function writeCertFile(filename, cert, mtime) {
    const keyFile = import_pkg_1.path.join(exports.CUSTOM_CERTS_DIR, filename + '.key');
    const certFile = import_pkg_1.path.join(exports.CUSTOM_CERTS_DIR, filename + '.crt');
    writeFile(keyFile, cert.key, function () {
        import_pkg_1.fs.utimes && import_pkg_1.fs.utimes(keyFile, mtime, mtime, util.noop);
    });
    writeFile(certFile, cert.cert, function () {
        import_pkg_1.fs.utimes && import_pkg_1.fs.utimes(certFile, mtime, mtime, util.noop);
    });
}
const ILLEGAL_PATH_RE = /[/\\]/;
function checkFilename(name) {
    return name && !ILLEGAL_PATH_RE.test(name) && name !== 'root';
}
const removeCert = function (filename) {
    if (!exports.CUSTOM_CERTS_DIR) {
        return;
    }
    if (checkFilename(filename) && allCustomCerts[filename]) {
        removeCertFile(filename);
        delete allCustomCerts[filename];
        parseAllCustomCerts();
    }
};
exports.removeCert = removeCert;
const uploadCerts = function (certs) {
    if (!exports.CUSTOM_CERTS_DIR) {
        return;
    }
    const now = Date.now();
    let hasChanged;
    let index = 0;
    Object.keys(certs).forEach(function (filename) {
        if (!checkFilename(filename) || filename.length > 128) {
            return;
        }
        let cert = certs[filename];
        if (!cert) {
            return;
        }
        let keyStr;
        let certStr;
        if (Array.isArray(cert)) {
            keyStr = cert[0];
            certStr = cert[1];
        }
        else {
            keyStr = cert.key;
            certStr = cert.cert;
        }
        if (util.isString(keyStr) && util.isString(certStr)) {
            const mtime = now + index * 1000;
            ++index;
            try {
                cert = parseCert({
                    key: keyStr,
                    cert: certStr,
                    mtime: mtime
                });
                if (cert) {
                    writeCertFile(filename, cert.cert, new Date(mtime));
                    allCustomCerts[filename] = cert;
                    hasChanged = true;
                }
            }
            catch (e) { }
        }
    });
    hasChanged && parseAllCustomCerts();
};
exports.uploadCerts = uploadCerts;
