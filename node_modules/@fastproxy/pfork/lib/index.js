"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.exists = exports.kill = exports.fork = void 0;
const tslib_1 = require("tslib");
const child_process_1 = tslib_1.__importDefault(require("child_process"));
const path_1 = tslib_1.__importDefault(require("path"));
const assert_1 = tslib_1.__importDefault(require("assert"));
const events_1 = require("events");
const q_1 = tslib_1.__importDefault(require("q"));
const debug_1 = tslib_1.__importDefault(require("debug"));
const util_1 = require("./util");
const debug = (0, debug_1.default)('@w2.pfork.index');
const MAIN = path_1.default.join(__dirname, './main');
const cache = {};
function getKey(options) {
    let key = options && options.script;
    if (typeof key !== 'string' || !(key = key.trim())) {
        return;
    }
    if (typeof options.value === 'string') {
        key = encodeURIComponent(key) + '?value=' + encodeURIComponent(options.value);
    }
    return key;
}
function fork(options, callback) {
    const key = getKey(options);
    if (!key) {
        return callback('options.script is required.');
    }
    let promise = cache[key];
    let defer;
    if (!promise) {
        defer = q_1.default.defer();
        cache[key] = promise = defer.promise;
        promise._firstCall = true;
    }
    promise.done(function (result) {
        callback(null, result[0], result[1], promise._firstCall);
        promise._firstCall = false;
    }, function (err) {
        callback(err, undefined, undefined, promise._firstCall);
        promise._firstCall = false;
    });
    if (!defer) {
        return;
    }
    let child, timeout, heartbeatTimeout, done, errMsg;
    const emitter = new events_1.EventEmitter();
    const args = Array.isArray(options._args) ? options._args : [];
    delete options._args;
    if (options._inspect || process.env.PFORK_MODE === 'inline') {
        const script = options.script;
        const execScript = require(script);
        (0, assert_1.default)(typeof execScript === 'function', script + ' not a function');
        execScript(options, function (err, data) {
            if (done) {
                return;
            }
            done = true;
            if (err) {
                defer.reject(err);
            }
            else {
                emitter.kill = util_1.noop;
                emitter.sendData = function (data) {
                    try {
                        process.emit('data', data);
                    }
                    catch (e) { }
                };
                defer.resolve([data, emitter]);
            }
        });
        return;
    }
    args.push(MAIN, encodeURIComponent(JSON.stringify(options)));
    const execPath = options.execPath || process.env.PFORK_EXEC_PATH;
    (0, util_1.getArgs)(execPath, function (version, flag) {
        flag && args.unshift(flag + '=64');
        if (version) {
            version = version.substring(1).split('.');
            const supportTlsMinV1 = version[0] > 11;
            const supportMaxHeaderSize = (version[0] == 10 && version[1] >= 15) || (version[0] == 11 && version[1] > 5) || version[0] > 11;
            if (supportMaxHeaderSize) {
                let maxSize = options.maxHttpHeadersSize || options.maxHttpHeaderSize;
                maxSize = maxSize > 0 ? maxSize : process.env.PFORK_MAX_HTTP_HEADER_SIZE;
                args.unshift('--max-http-header-size=' + (maxSize > 0 ? maxSize : 256000));
            }
            supportTlsMinV1 && args.unshift('--tls-min-v1.0');
        }
        try {
            let spawnOpts = options._detached === false || process.env.PFORK_MODE === 'bind';
            spawnOpts = spawnOpts
                ? { stdio: [0, 1, 2, 'ipc'] }
                : {
                    detached: true,
                    stdio: ['ipc']
                };
            child = child_process_1.default.spawn(execPath || 'node', args, spawnOpts);
            child.on('error', errorHandler);
            child.on('close', errorHandler);
            child.on('exit', errorHandler);
            child.on('disconnect', errorHandler);
            child.on('message', function (msg) {
                debug(`child.onmessage with msg:${msg} from plugin: ${options.name}`);
                clearTimeout(heartbeatTimeout);
                heartbeatTimeout = null;
                if (msg == util_1.MESSAGE) {
                    return;
                }
                try {
                    if ((msg = JSON.parse(msg))) {
                        if (msg.type == util_1.MESSAGE) {
                            callbackHandler(null, msg.data);
                        }
                        else if (msg.type == util_1.DATA) {
                            emitter.emit('data', msg.data);
                        }
                        else if (msg.type == util_1.ERROR) {
                            errorHandler(msg.data);
                        }
                    }
                }
                catch (e) { }
            });
            if (child.stderr) {
                child.stderr.on('data', function (data) {
                    if (done || !Buffer.isBuffer(data)) {
                        return;
                    }
                    errMsg = errMsg ? Buffer.concat([errMsg, data]) : data;
                });
            }
            child.unref();
            keepAlive();
            promise.kill = killChild;
        }
        catch (err) {
            errorHandler(err);
        }
    });
    function keepAlive() {
        timeout = setTimeout(function () {
            try {
                child.send(util_1.MESSAGE, util_1.noop);
                keepAlive();
            }
            catch (err) { }
        }, util_1.HEARTBEAT_INTERVAL);
        if (!heartbeatTimeout) {
            heartbeatTimeout = setTimeout(errorHandler, util_1.HEARTBEAT_TIMEOUT);
        }
    }
    function errorHandler(err) {
        debug('errorHandler ~ err: %o', err);
        killChild();
        errMsg = errMsg && errMsg + '';
        err = typeof err === 'string' ? err : err && err.stack;
        errMsg = err || errMsg || 'unknown';
        try {
            process.emit('pforkError', {
                script: options.script,
                value: options.value,
                message: errMsg
            });
        }
        catch (e) { }
        process.nextTick(function () {
            callbackHandler(errMsg);
        });
    }
    function killChild(delay) {
        clearTimeout(heartbeatTimeout);
        clearTimeout(timeout);
        delete cache[key];
        emitter.emit('close');
        const _kill = function () {
            try {
                process.kill(child.pid);
            }
            catch (e) { }
            try {
                child.removeAllListeners();
                child.on('error', util_1.noop);
                if (child.stderr) {
                    child.stderr.removeAllListeners();
                }
            }
            catch (e) { }
            emitter.kill = util_1.noop;
            emitter.sendData = util_1.noop;
            emitter.emit('exit');
        };
        delay && delay > 0 ? setTimeout(_kill, delay) : _kill();
    }
    function callbackHandler(err, data) {
        if (done) {
            return;
        }
        done = true;
        if (err) {
            defer.reject(err);
        }
        else {
            emitter.kill = killChild;
            emitter.sendData = function (data) {
                try {
                    child.send(JSON.stringify({
                        type: util_1.DATA,
                        data: data
                    }), util_1.noop);
                }
                catch (e) { }
            };
            defer.resolve([data, emitter]);
        }
    }
}
exports.fork = fork;
function kill(options, delay) {
    const key = getKey(options);
    if (!key) {
        return;
    }
    const child = cache[key];
    if (!child) {
        return;
    }
    debug(`kill child process with key: ${key}`);
    child.kill(delay);
}
exports.kill = kill;
function exists(options) {
    const key = getKey(options);
    if (!key || !cache[key]) {
        return false;
    }
    return true;
}
exports.exists = exists;
