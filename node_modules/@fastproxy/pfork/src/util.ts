import cp from 'child_process';

export const HEARTBEAT_INTERVAL = 10000;
export const HEARTBEAT_TIMEOUT = HEARTBEAT_INTERVAL * 3;

function execCmd(execPath, args, callback) {
  let data;
  let done;
  let timer;
  const execCb = function () {
    if (!done) {
      clearTimeout(timer);
      done = true;
      callback(data ? String(data) : '');
    }
  };
  try {
    const child = cp.spawn(execPath || 'node', args, {detached: true});
    timer = setTimeout(function () {
      try {
        process.kill(child.pid!);
      } catch (e) {}
    }, 5000);
    child.on('error', execCb);
    child.on('close', execCb);
    child.on('exit', execCb);
    child.stdout.on('data', function (chunk) {
      data = data ? Buffer.concat([data, chunk]) : chunk;
    });
    child.stdout.on('end', execCb);
    child.unref();
  } catch (err) {
    execCb();
  }
}

function getVersion(execPath, callback) {
  if (!execPath) {
    return callback(process.version);
  }
  execCmd(execPath, ['--version'], function (str) {
    if (/v\d+\.\d+\.\d+/.test(str)) {
      callback(RegExp['$&']);
    } else {
      callback('');
    }
  });
}

function getMaxSemiSpaceFlag(version) {
  const major = parseInt(version.substring(1, version.indexOf('.')), 10);
  if (major < 6) {
    return;
  }
  return major > 9 ? '--max-semi-space-size' : '--max_semi_space_size';
}

export const noop = function () {
  /** nothing */
};

export const MESSAGE = 'pforkMessage';
export const DATA = 'pforkData';
export const ERROR = 'pforkError';

export const getArgs = function (execPath, callback) {
  getVersion(execPath, function (version) {
    callback(version, getMaxSemiSpaceFlag(version));
  });
};
