import cp from 'child_process';
import path from 'path';
import assert from 'assert';
import {EventEmitter} from 'events';
import Q from 'q';
import createDebug from 'debug';
import {DATA, ERROR, HEARTBEAT_INTERVAL, HEARTBEAT_TIMEOUT, MESSAGE, getArgs, noop} from './util';

const debug = createDebug('@w2.pfork');
const MAIN = path.join(__dirname, './main');
const cache = {};

function getKey(options) {
  let key = options && options.script;
  if (typeof key !== 'string' || !(key = key.trim())) {
    return;
  }

  if (typeof options.value === 'string') {
    key = encodeURIComponent(key) + '?value=' + encodeURIComponent(options.value);
  }
  return key;
}

export function fork(options, callback) {
  const key = getKey(options);
  if (!key) {
    return callback('options.script is required.');
  }
  let promise = cache[key];
  let defer;

  if (!promise) {
    defer = Q.defer();
    cache[key] = promise = defer.promise;
    promise._firstCall = true;
  }

  promise.done(
    function (result) {
      callback(null, result[0], result[1], promise._firstCall);
      promise._firstCall = false;
    },
    function (err) {
      callback(err, undefined, undefined, promise._firstCall);
      promise._firstCall = false;
    }
  );

  if (!defer) {
    return;
  }

  let child, timeout, heartbeatTimeout, done, errMsg;
  const emitter = new EventEmitter() as any;
  const args = Array.isArray(options._args) ? options._args : [];
  delete options._args;
  if (options._inspect || process.env.PFORK_MODE === 'inline') {
    const script = options.script;
    const execScript = require(script);
    assert(typeof execScript === 'function', script + ' not a function');
    execScript(options, function (err, data) {
      if (done) {
        return;
      }
      done = true;
      if (err) {
        defer.reject(err);
      } else {
        emitter.kill = noop;
        emitter.sendData = function (data) {
          try {
            process.emit('data' as any, data);
          } catch (e) {}
        };
        defer.resolve([data, emitter]);
      }
    });
    return;
  }
  args.push(MAIN, encodeURIComponent(JSON.stringify(options)));
  const execPath = options.execPath || process.env.PFORK_EXEC_PATH;
  getArgs(execPath, function (version, flag) {
    flag && args.unshift(flag + '=64');
    if (version) {
      version = version.substring(1).split('.');
      const supportTlsMinV1 = version[0] > 11;
      const supportMaxHeaderSize =
        (version[0] == 10 && version[1] >= 15) || (version[0] == 11 && version[1] > 5) || version[0] > 11;
      if (supportMaxHeaderSize) {
        let maxSize = options.maxHttpHeadersSize || options.maxHttpHeaderSize;
        maxSize = maxSize > 0 ? maxSize : process.env.PFORK_MAX_HTTP_HEADER_SIZE;
        args.unshift('--max-http-header-size=' + (maxSize > 0 ? maxSize : 256000));
      }
      supportTlsMinV1 && args.unshift('--tls-min-v1.0');
    }
    try {
      let spawnOpts: any = options._detached === false || process.env.PFORK_MODE === 'bind';
      spawnOpts = spawnOpts
        ? {stdio: [0, 1, 2, 'ipc']}
        : {
            detached: true,
            stdio: ['ipc']
          };
      child = cp.spawn(execPath || 'node', args, spawnOpts);
      child.on('error', errorHandler);
      child.on('close', errorHandler);
      child.on('exit', errorHandler);
      child.on('disconnect', errorHandler);
      child.on('message', function (msg) {
        debug(`child.onmessage with msg:${msg} from plugin: ${options.name}`);
        clearTimeout(heartbeatTimeout);
        heartbeatTimeout = null;
        if (msg == MESSAGE) {
          return;
        }

        try {
          if ((msg = JSON.parse(msg))) {
            if (msg.type == MESSAGE) {
              callbackHandler(null, msg.data);
            } else if (msg.type == DATA) {
              emitter.emit('data', msg.data);
            } else if (msg.type == ERROR) {
              errorHandler(msg.data);
            }
          }
        } catch (e) {}
      });
      if (child.stderr) {
        child.stderr.on('data', function (data) {
          if (done || !Buffer.isBuffer(data)) {
            return;
          }
          errMsg = errMsg ? Buffer.concat([errMsg, data]) : data;
        });
      }
      child.unref();
      keepAlive();
      promise.kill = killChild;
    } catch (err) {
      errorHandler(err);
    }
  });

  function keepAlive() {
    timeout = setTimeout(function () {
      try {
        child.send(MESSAGE, noop);
        keepAlive();
      } catch (err) {}
    }, HEARTBEAT_INTERVAL);
    if (!heartbeatTimeout) {
      heartbeatTimeout = setTimeout(errorHandler, HEARTBEAT_TIMEOUT);
    }
  }

  function errorHandler(err) {
    debug('errorHandler ~ err: %o', err);
    killChild();
    errMsg = errMsg && errMsg + '';
    err = typeof err === 'string' ? err : err && err.stack;
    errMsg = err || errMsg || 'unknown';
    try {
      process.emit(
        'pforkError' as any,
        {
          script: options.script,
          value: options.value,
          message: errMsg
        } as any
      );
    } catch (e) {}
    process.nextTick(function () {
      callbackHandler(errMsg);
    });
  }

  function killChild(delay?: number) {
    clearTimeout(heartbeatTimeout);
    clearTimeout(timeout);
    delete cache[key];
    emitter.emit('close');
    const _kill = function () {
      try {
        process.kill(child.pid);
      } catch (e) {}
      try {
        child.removeAllListeners();
        child.on('error', noop);
        if (child.stderr) {
          child.stderr.removeAllListeners();
        }
      } catch (e) {}
      emitter.kill = noop;
      emitter.sendData = noop;
      emitter.emit('exit');
    };
    delay && delay > 0 ? setTimeout(_kill, delay) : _kill();
  }

  function callbackHandler(err, data?: any) {
    if (done) {
      return;
    }
    done = true;
    if (err) {
      defer.reject(err);
    } else {
      emitter.kill = killChild;
      emitter.sendData = function (data) {
        try {
          child.send(
            JSON.stringify({
              type: DATA,
              data: data
            }),
            noop
          );
        } catch (e) {}
      };
      defer.resolve([data, emitter]);
    }
  }
}

export function kill(options, delay) {
  const key = getKey(options);
  if (!key) {
    return;
  }
  const child = cache[key];
  if (!child) {
    return;
  }
  debug(`kill child process with key: ${key}`);
  child.kill(delay);
}

export function exists(options) {
  const key = getKey(options);
  if (!key || !cache[key]) {
    return false;
  }

  return true;
}
